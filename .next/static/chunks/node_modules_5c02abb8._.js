(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push([typeof document === "object" ? document.currentScript : undefined, {

"[project]/node_modules/marked/lib/marked.esm.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * marked v15.0.8 - a markdown parser
 * Copyright (c) 2011-2025, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/markedjs/marked
 */ /**
 * DO NOT EDIT THIS FILE
 * The code in this file is generated from files in ./src/
 */ /**
 * Gets the original marked default options.
 */ __turbopack_context__.s({
    "Hooks": (()=>_Hooks),
    "Lexer": (()=>_Lexer),
    "Marked": (()=>Marked),
    "Parser": (()=>_Parser),
    "Renderer": (()=>_Renderer),
    "TextRenderer": (()=>_TextRenderer),
    "Tokenizer": (()=>_Tokenizer),
    "defaults": (()=>_defaults),
    "getDefaults": (()=>_getDefaults),
    "lexer": (()=>lexer),
    "marked": (()=>marked),
    "options": (()=>options),
    "parse": (()=>parse),
    "parseInline": (()=>parseInline),
    "parser": (()=>parser),
    "setOptions": (()=>setOptions),
    "use": (()=>use),
    "walkTokens": (()=>walkTokens)
});
function _getDefaults() {
    return {
        async: false,
        breaks: false,
        extensions: null,
        gfm: true,
        hooks: null,
        pedantic: false,
        renderer: null,
        silent: false,
        tokenizer: null,
        walkTokens: null
    };
}
let _defaults = _getDefaults();
function changeDefaults(newDefaults) {
    _defaults = newDefaults;
}
const noopTest = {
    exec: ()=>null
};
function edit(regex, opt = '') {
    let source = typeof regex === 'string' ? regex : regex.source;
    const obj = {
        replace: (name, val)=>{
            let valSource = typeof val === 'string' ? val : val.source;
            valSource = valSource.replace(other.caret, '$1');
            source = source.replace(name, valSource);
            return obj;
        },
        getRegex: ()=>{
            return new RegExp(source, opt);
        }
    };
    return obj;
}
const other = {
    codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm,
    outputLinkReplace: /\\([\[\]])/g,
    indentCodeCompensation: /^(\s+)(?:```)/,
    beginningSpace: /^\s+/,
    endingHash: /#$/,
    startingSpaceChar: /^ /,
    endingSpaceChar: / $/,
    nonSpaceChar: /[^ ]/,
    newLineCharGlobal: /\n/g,
    tabCharGlobal: /\t/g,
    multipleSpaceGlobal: /\s+/g,
    blankLine: /^[ \t]*$/,
    doubleBlankLine: /\n[ \t]*\n[ \t]*$/,
    blockquoteStart: /^ {0,3}>/,
    blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g,
    blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm,
    listReplaceTabs: /^\t+/,
    listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,
    listIsTask: /^\[[ xX]\] /,
    listReplaceTask: /^\[[ xX]\] +/,
    anyLine: /\n.*\n/,
    hrefBrackets: /^<(.*)>$/,
    tableDelimiter: /[:|]/,
    tableAlignChars: /^\||\| *$/g,
    tableRowBlankLine: /\n[ \t]*$/,
    tableAlignRight: /^ *-+: *$/,
    tableAlignCenter: /^ *:-+: *$/,
    tableAlignLeft: /^ *:-+ *$/,
    startATag: /^<a /i,
    endATag: /^<\/a>/i,
    startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i,
    endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i,
    startAngleBracket: /^</,
    endAngleBracket: />$/,
    pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/,
    unicodeAlphaNumeric: /[\p{L}\p{N}]/u,
    escapeTest: /[&<>"']/,
    escapeReplace: /[&<>"']/g,
    escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,
    escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g,
    unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig,
    caret: /(^|[^\[])\^/g,
    percentDecode: /%25/g,
    findPipe: /\|/g,
    splitPipe: / \|/,
    slashPipe: /\\\|/g,
    carriageReturn: /\r\n|\r/g,
    spaceLine: /^ +$/gm,
    notSpaceStart: /^\S*/,
    endingNewline: /\n$/,
    listItemRegex: (bull)=>new RegExp(`^( {0,3}${bull})((?:[\t ][^\\n]*)?(?:\\n|$))`),
    nextBulletRegex: (indent)=>new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ \t][^\\n]*)?(?:\\n|$))`),
    hrRegex: (indent)=>new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`),
    fencesBeginRegex: (indent)=>new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`),
    headingBeginRegex: (indent)=>new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`),
    htmlBeginRegex: (indent)=>new RegExp(`^ {0,${Math.min(3, indent - 1)}}<(?:[a-z].*>|!--)`, 'i')
};
/**
 * Block-Level Grammar
 */ const newline = /^(?:[ \t]*(?:\n|$))+/;
const blockCode = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/;
const fences = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/;
const hr = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/;
const heading = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/;
const bullet = /(?:[*+-]|\d{1,9}[.)])/;
const lheadingCore = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/;
const lheading = edit(lheadingCore).replace(/bull/g, bullet) // lists can interrupt
.replace(/blockCode/g, /(?: {4}| {0,3}\t)/) // indented code blocks can interrupt
.replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt
.replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt
.replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt
.replace(/html/g, / {0,3}<[^\n>]+>\n/) // block html can interrupt
.replace(/\|table/g, '') // table not in commonmark
.getRegex();
const lheadingGfm = edit(lheadingCore).replace(/bull/g, bullet) // lists can interrupt
.replace(/blockCode/g, /(?: {4}| {0,3}\t)/) // indented code blocks can interrupt
.replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt
.replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt
.replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt
.replace(/html/g, / {0,3}<[^\n>]+>\n/) // block html can interrupt
.replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/) // table can interrupt
.getRegex();
const _paragraph = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/;
const blockText = /^[^\n]+/;
const _blockLabel = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
const def = edit(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace('label', _blockLabel).replace('title', /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex();
const list = edit(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, bullet).getRegex();
const _tag = 'address|article|aside|base|basefont|blockquote|body|caption' + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption' + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe' + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option' + '|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title' + '|tr|track|ul';
const _comment = /<!--(?:-?>|[\s\S]*?(?:-->|$))/;
const html = edit('^ {0,3}(?:' // optional indentation
 + '<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)' // (1)
 + '|comment[^\\n]*(\\n+|$)' // (2)
 + '|<\\?[\\s\\S]*?(?:\\?>\\n*|$)' // (3)
 + '|<![A-Z][\\s\\S]*?(?:>\\n*|$)' // (4)
 + '|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)' // (5)
 + '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ \t]*)+\\n|$)' // (6)
 + '|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ \t]*)+\\n|$)' // (7) open tag
 + '|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ \t]*)+\\n|$)' // (7) closing tag
 + ')', 'i').replace('comment', _comment).replace('tag', _tag).replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
const paragraph = edit(_paragraph).replace('hr', hr).replace('heading', ' {0,3}#{1,6}(?:\\s|$)').replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs
.replace('|table', '').replace('blockquote', ' {0,3}>').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
.replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', _tag) // pars can be interrupted by type (6) html blocks
.getRegex();
const blockquote = edit(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace('paragraph', paragraph).getRegex();
/**
 * Normal Block Grammar
 */ const blockNormal = {
    blockquote,
    code: blockCode,
    def,
    fences,
    heading,
    hr,
    html,
    lheading,
    list,
    newline,
    paragraph,
    table: noopTest,
    text: blockText
};
/**
 * GFM Block Grammar
 */ const gfmTable = edit('^ *([^\\n ].*)\\n' // Header
 + ' {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)' // Align
 + '(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)') // Cells
.replace('hr', hr).replace('heading', ' {0,3}#{1,6}(?:\\s|$)').replace('blockquote', ' {0,3}>').replace('code', '(?: {4}| {0,3}\t)[^\\n]').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
.replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', _tag) // tables can be interrupted by type (6) html blocks
.getRegex();
const blockGfm = {
    ...blockNormal,
    lheading: lheadingGfm,
    table: gfmTable,
    paragraph: edit(_paragraph).replace('hr', hr).replace('heading', ' {0,3}#{1,6}(?:\\s|$)').replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs
    .replace('table', gfmTable) // interrupt paragraphs with table
    .replace('blockquote', ' {0,3}>').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
    .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', _tag) // pars can be interrupted by type (6) html blocks
    .getRegex()
};
/**
 * Pedantic grammar (original John Gruber's loose markdown specification)
 */ const blockPedantic = {
    ...blockNormal,
    html: edit('^ *(?:comment *(?:\\n|\\s*$)' + '|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)' // closed tag
     + '|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))').replace('comment', _comment).replace(/tag/g, '(?!(?:' + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub' + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)' + '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b').getRegex(),
    def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
    heading: /^(#{1,6})(.*)(?:\n+|$)/,
    fences: noopTest,
    lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
    paragraph: edit(_paragraph).replace('hr', hr).replace('heading', ' *#{1,6} *[^\n]').replace('lheading', lheading).replace('|table', '').replace('blockquote', ' {0,3}>').replace('|fences', '').replace('|list', '').replace('|html', '').replace('|tag', '').getRegex()
};
/**
 * Inline-Level Grammar
 */ const escape$1 = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/;
const inlineCode = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/;
const br = /^( {2,}|\\)\n(?!\s*$)/;
const inlineText = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/;
// list of unicode punctuation marks, plus any missing characters from CommonMark spec
const _punctuation = /[\p{P}\p{S}]/u;
const _punctuationOrSpace = /[\s\p{P}\p{S}]/u;
const _notPunctuationOrSpace = /[^\s\p{P}\p{S}]/u;
const punctuation = edit(/^((?![*_])punctSpace)/, 'u').replace(/punctSpace/g, _punctuationOrSpace).getRegex();
// GFM allows ~ inside strong and em for strikethrough
const _punctuationGfmStrongEm = /(?!~)[\p{P}\p{S}]/u;
const _punctuationOrSpaceGfmStrongEm = /(?!~)[\s\p{P}\p{S}]/u;
const _notPunctuationOrSpaceGfmStrongEm = /(?:[^\s\p{P}\p{S}]|~)/u;
// sequences em should skip over [title](link), `code`, <html>
const blockSkip = /\[[^[\]]*?\]\((?:\\.|[^\\\(\)]|\((?:\\.|[^\\\(\)])*\))*\)|`[^`]*?`|<[^<>]*?>/g;
const emStrongLDelimCore = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/;
const emStrongLDelim = edit(emStrongLDelimCore, 'u').replace(/punct/g, _punctuation).getRegex();
const emStrongLDelimGfm = edit(emStrongLDelimCore, 'u').replace(/punct/g, _punctuationGfmStrongEm).getRegex();
const emStrongRDelimAstCore = '^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)' // Skip orphan inside strong
 + '|[^*]+(?=[^*])' // Consume to delim
 + '|(?!\\*)punct(\\*+)(?=[\\s]|$)' // (1) #*** can only be a Right Delimiter
 + '|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)' // (2) a***#, a*** can only be a Right Delimiter
 + '|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)' // (3) #***a, ***a can only be Left Delimiter
 + '|[\\s](\\*+)(?!\\*)(?=punct)' // (4) ***# can only be Left Delimiter
 + '|(?!\\*)punct(\\*+)(?!\\*)(?=punct)' // (5) #***# can be either Left or Right Delimiter
 + '|notPunctSpace(\\*+)(?=notPunctSpace)'; // (6) a***a can be either Left or Right Delimiter
const emStrongRDelimAst = edit(emStrongRDelimAstCore, 'gu').replace(/notPunctSpace/g, _notPunctuationOrSpace).replace(/punctSpace/g, _punctuationOrSpace).replace(/punct/g, _punctuation).getRegex();
const emStrongRDelimAstGfm = edit(emStrongRDelimAstCore, 'gu').replace(/notPunctSpace/g, _notPunctuationOrSpaceGfmStrongEm).replace(/punctSpace/g, _punctuationOrSpaceGfmStrongEm).replace(/punct/g, _punctuationGfmStrongEm).getRegex();
// (6) Not allowed for _
const emStrongRDelimUnd = edit('^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)' // Skip orphan inside strong
 + '|[^_]+(?=[^_])' // Consume to delim
 + '|(?!_)punct(_+)(?=[\\s]|$)' // (1) #___ can only be a Right Delimiter
 + '|notPunctSpace(_+)(?!_)(?=punctSpace|$)' // (2) a___#, a___ can only be a Right Delimiter
 + '|(?!_)punctSpace(_+)(?=notPunctSpace)' // (3) #___a, ___a can only be Left Delimiter
 + '|[\\s](_+)(?!_)(?=punct)' // (4) ___# can only be Left Delimiter
 + '|(?!_)punct(_+)(?!_)(?=punct)', 'gu') // (5) #___# can be either Left or Right Delimiter
.replace(/notPunctSpace/g, _notPunctuationOrSpace).replace(/punctSpace/g, _punctuationOrSpace).replace(/punct/g, _punctuation).getRegex();
const anyPunctuation = edit(/\\(punct)/, 'gu').replace(/punct/g, _punctuation).getRegex();
const autolink = edit(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace('scheme', /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace('email', /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex();
const _inlineComment = edit(_comment).replace('(?:-->|$)', '-->').getRegex();
const tag = edit('^comment' + '|^</[a-zA-Z][\\w:-]*\\s*>' // self-closing tag
 + '|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>' // open tag
 + '|^<\\?[\\s\\S]*?\\?>' // processing instruction, e.g. <?php ?>
 + '|^<![a-zA-Z]+\\s[\\s\\S]*?>' // declaration, e.g. <!DOCTYPE html>
 + '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>') // CDATA section
.replace('comment', _inlineComment).replace('attribute', /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex();
const _inlineLabel = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
const link = edit(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/).replace('label', _inlineLabel).replace('href', /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/).replace('title', /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex();
const reflink = edit(/^!?\[(label)\]\[(ref)\]/).replace('label', _inlineLabel).replace('ref', _blockLabel).getRegex();
const nolink = edit(/^!?\[(ref)\](?:\[\])?/).replace('ref', _blockLabel).getRegex();
const reflinkSearch = edit('reflink|nolink(?!\\()', 'g').replace('reflink', reflink).replace('nolink', nolink).getRegex();
/**
 * Normal Inline Grammar
 */ const inlineNormal = {
    _backpedal: noopTest,
    anyPunctuation,
    autolink,
    blockSkip,
    br,
    code: inlineCode,
    del: noopTest,
    emStrongLDelim,
    emStrongRDelimAst,
    emStrongRDelimUnd,
    escape: escape$1,
    link,
    nolink,
    punctuation,
    reflink,
    reflinkSearch,
    tag,
    text: inlineText,
    url: noopTest
};
/**
 * Pedantic Inline Grammar
 */ const inlinePedantic = {
    ...inlineNormal,
    link: edit(/^!?\[(label)\]\((.*?)\)/).replace('label', _inlineLabel).getRegex(),
    reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace('label', _inlineLabel).getRegex()
};
/**
 * GFM Inline Grammar
 */ const inlineGfm = {
    ...inlineNormal,
    emStrongRDelimAst: emStrongRDelimAstGfm,
    emStrongLDelim: emStrongLDelimGfm,
    url: edit(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, 'i').replace('email', /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),
    _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
    del: /^(~~?)(?=[^\s~])((?:\\.|[^\\])*?(?:\\.|[^\s~\\]))\1(?=[^~]|$)/,
    text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
};
/**
 * GFM + Line Breaks Inline Grammar
 */ const inlineBreaks = {
    ...inlineGfm,
    br: edit(br).replace('{2,}', '*').getRegex(),
    text: edit(inlineGfm.text).replace('\\b_', '\\b_| {2,}\\n').replace(/\{2,\}/g, '*').getRegex()
};
/**
 * exports
 */ const block = {
    normal: blockNormal,
    gfm: blockGfm,
    pedantic: blockPedantic
};
const inline = {
    normal: inlineNormal,
    gfm: inlineGfm,
    breaks: inlineBreaks,
    pedantic: inlinePedantic
};
/**
 * Helpers
 */ const escapeReplacements = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
};
const getEscapeReplacement = (ch)=>escapeReplacements[ch];
function escape(html, encode) {
    if (encode) {
        if (other.escapeTest.test(html)) {
            return html.replace(other.escapeReplace, getEscapeReplacement);
        }
    } else {
        if (other.escapeTestNoEncode.test(html)) {
            return html.replace(other.escapeReplaceNoEncode, getEscapeReplacement);
        }
    }
    return html;
}
function cleanUrl(href) {
    try {
        href = encodeURI(href).replace(other.percentDecode, '%');
    } catch  {
        return null;
    }
    return href;
}
function splitCells(tableRow, count) {
    // ensure that every cell-delimiting pipe has a space
    // before it to distinguish it from an escaped pipe
    const row = tableRow.replace(other.findPipe, (match, offset, str)=>{
        let escaped = false;
        let curr = offset;
        while(--curr >= 0 && str[curr] === '\\')escaped = !escaped;
        if (escaped) {
            // odd number of slashes means | is escaped
            // so we leave it alone
            return '|';
        } else {
            // add space before unescaped |
            return ' |';
        }
    }), cells = row.split(other.splitPipe);
    let i = 0;
    // First/last cell in a row cannot be empty if it has no leading/trailing pipe
    if (!cells[0].trim()) {
        cells.shift();
    }
    if (cells.length > 0 && !cells.at(-1)?.trim()) {
        cells.pop();
    }
    if (count) {
        if (cells.length > count) {
            cells.splice(count);
        } else {
            while(cells.length < count)cells.push('');
        }
    }
    for(; i < cells.length; i++){
        // leading or trailing whitespace is ignored per the gfm spec
        cells[i] = cells[i].trim().replace(other.slashPipe, '|');
    }
    return cells;
}
/**
 * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
 * /c*$/ is vulnerable to REDOS.
 *
 * @param str
 * @param c
 * @param invert Remove suffix of non-c chars instead. Default falsey.
 */ function rtrim(str, c, invert) {
    const l = str.length;
    if (l === 0) {
        return '';
    }
    // Length of suffix matching the invert condition.
    let suffLen = 0;
    // Step left until we fail to match the invert condition.
    while(suffLen < l){
        const currChar = str.charAt(l - suffLen - 1);
        if (currChar === c && true) {
            suffLen++;
        } else {
            break;
        }
    }
    return str.slice(0, l - suffLen);
}
function findClosingBracket(str, b) {
    if (str.indexOf(b[1]) === -1) {
        return -1;
    }
    let level = 0;
    for(let i = 0; i < str.length; i++){
        if (str[i] === '\\') {
            i++;
        } else if (str[i] === b[0]) {
            level++;
        } else if (str[i] === b[1]) {
            level--;
            if (level < 0) {
                return i;
            }
        }
    }
    return -1;
}
function outputLink(cap, link, raw, lexer, rules) {
    const href = link.href;
    const title = link.title || null;
    const text = cap[1].replace(rules.other.outputLinkReplace, '$1');
    if (cap[0].charAt(0) !== '!') {
        lexer.state.inLink = true;
        const token = {
            type: 'link',
            raw,
            href,
            title,
            text,
            tokens: lexer.inlineTokens(text)
        };
        lexer.state.inLink = false;
        return token;
    }
    return {
        type: 'image',
        raw,
        href,
        title,
        text
    };
}
function indentCodeCompensation(raw, text, rules) {
    const matchIndentToCode = raw.match(rules.other.indentCodeCompensation);
    if (matchIndentToCode === null) {
        return text;
    }
    const indentToCode = matchIndentToCode[1];
    return text.split('\n').map((node)=>{
        const matchIndentInNode = node.match(rules.other.beginningSpace);
        if (matchIndentInNode === null) {
            return node;
        }
        const [indentInNode] = matchIndentInNode;
        if (indentInNode.length >= indentToCode.length) {
            return node.slice(indentToCode.length);
        }
        return node;
    }).join('\n');
}
/**
 * Tokenizer
 */ class _Tokenizer {
    options;
    rules;
    lexer;
    constructor(options){
        this.options = options || _defaults;
    }
    space(src) {
        const cap = this.rules.block.newline.exec(src);
        if (cap && cap[0].length > 0) {
            return {
                type: 'space',
                raw: cap[0]
            };
        }
    }
    code(src) {
        const cap = this.rules.block.code.exec(src);
        if (cap) {
            const text = cap[0].replace(this.rules.other.codeRemoveIndent, '');
            return {
                type: 'code',
                raw: cap[0],
                codeBlockStyle: 'indented',
                text: !this.options.pedantic ? rtrim(text, '\n') : text
            };
        }
    }
    fences(src) {
        const cap = this.rules.block.fences.exec(src);
        if (cap) {
            const raw = cap[0];
            const text = indentCodeCompensation(raw, cap[3] || '', this.rules);
            return {
                type: 'code',
                raw,
                lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, '$1') : cap[2],
                text
            };
        }
    }
    heading(src) {
        const cap = this.rules.block.heading.exec(src);
        if (cap) {
            let text = cap[2].trim();
            // remove trailing #s
            if (this.rules.other.endingHash.test(text)) {
                const trimmed = rtrim(text, '#');
                if (this.options.pedantic) {
                    text = trimmed.trim();
                } else if (!trimmed || this.rules.other.endingSpaceChar.test(trimmed)) {
                    // CommonMark requires space before trailing #s
                    text = trimmed.trim();
                }
            }
            return {
                type: 'heading',
                raw: cap[0],
                depth: cap[1].length,
                text,
                tokens: this.lexer.inline(text)
            };
        }
    }
    hr(src) {
        const cap = this.rules.block.hr.exec(src);
        if (cap) {
            return {
                type: 'hr',
                raw: rtrim(cap[0], '\n')
            };
        }
    }
    blockquote(src) {
        const cap = this.rules.block.blockquote.exec(src);
        if (cap) {
            let lines = rtrim(cap[0], '\n').split('\n');
            let raw = '';
            let text = '';
            const tokens = [];
            while(lines.length > 0){
                let inBlockquote = false;
                const currentLines = [];
                let i;
                for(i = 0; i < lines.length; i++){
                    // get lines up to a continuation
                    if (this.rules.other.blockquoteStart.test(lines[i])) {
                        currentLines.push(lines[i]);
                        inBlockquote = true;
                    } else if (!inBlockquote) {
                        currentLines.push(lines[i]);
                    } else {
                        break;
                    }
                }
                lines = lines.slice(i);
                const currentRaw = currentLines.join('\n');
                const currentText = currentRaw// precede setext continuation with 4 spaces so it isn't a setext
                .replace(this.rules.other.blockquoteSetextReplace, '\n    $1').replace(this.rules.other.blockquoteSetextReplace2, '');
                raw = raw ? `${raw}\n${currentRaw}` : currentRaw;
                text = text ? `${text}\n${currentText}` : currentText;
                // parse blockquote lines as top level tokens
                // merge paragraphs if this is a continuation
                const top = this.lexer.state.top;
                this.lexer.state.top = true;
                this.lexer.blockTokens(currentText, tokens, true);
                this.lexer.state.top = top;
                // if there is no continuation then we are done
                if (lines.length === 0) {
                    break;
                }
                const lastToken = tokens.at(-1);
                if (lastToken?.type === 'code') {
                    break;
                } else if (lastToken?.type === 'blockquote') {
                    // include continuation in nested blockquote
                    const oldToken = lastToken;
                    const newText = oldToken.raw + '\n' + lines.join('\n');
                    const newToken = this.blockquote(newText);
                    tokens[tokens.length - 1] = newToken;
                    raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;
                    text = text.substring(0, text.length - oldToken.text.length) + newToken.text;
                    break;
                } else if (lastToken?.type === 'list') {
                    // include continuation in nested list
                    const oldToken = lastToken;
                    const newText = oldToken.raw + '\n' + lines.join('\n');
                    const newToken = this.list(newText);
                    tokens[tokens.length - 1] = newToken;
                    raw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;
                    text = text.substring(0, text.length - oldToken.raw.length) + newToken.raw;
                    lines = newText.substring(tokens.at(-1).raw.length).split('\n');
                    continue;
                }
            }
            return {
                type: 'blockquote',
                raw,
                tokens,
                text
            };
        }
    }
    list(src) {
        let cap = this.rules.block.list.exec(src);
        if (cap) {
            let bull = cap[1].trim();
            const isordered = bull.length > 1;
            const list = {
                type: 'list',
                raw: '',
                ordered: isordered,
                start: isordered ? +bull.slice(0, -1) : '',
                loose: false,
                items: []
            };
            bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
            if (this.options.pedantic) {
                bull = isordered ? bull : '[*+-]';
            }
            // Get next list item
            const itemRegex = this.rules.other.listItemRegex(bull);
            let endsWithBlankLine = false;
            // Check if current bullet point can start a new List Item
            while(src){
                let endEarly = false;
                let raw = '';
                let itemContents = '';
                if (!(cap = itemRegex.exec(src))) {
                    break;
                }
                if (this.rules.block.hr.test(src)) {
                    break;
                }
                raw = cap[0];
                src = src.substring(raw.length);
                let line = cap[2].split('\n', 1)[0].replace(this.rules.other.listReplaceTabs, (t)=>' '.repeat(3 * t.length));
                let nextLine = src.split('\n', 1)[0];
                let blankLine = !line.trim();
                let indent = 0;
                if (this.options.pedantic) {
                    indent = 2;
                    itemContents = line.trimStart();
                } else if (blankLine) {
                    indent = cap[1].length + 1;
                } else {
                    indent = cap[2].search(this.rules.other.nonSpaceChar); // Find first non-space char
                    indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent
                    itemContents = line.slice(indent);
                    indent += cap[1].length;
                }
                if (blankLine && this.rules.other.blankLine.test(nextLine)) {
                    raw += nextLine + '\n';
                    src = src.substring(nextLine.length + 1);
                    endEarly = true;
                }
                if (!endEarly) {
                    const nextBulletRegex = this.rules.other.nextBulletRegex(indent);
                    const hrRegex = this.rules.other.hrRegex(indent);
                    const fencesBeginRegex = this.rules.other.fencesBeginRegex(indent);
                    const headingBeginRegex = this.rules.other.headingBeginRegex(indent);
                    const htmlBeginRegex = this.rules.other.htmlBeginRegex(indent);
                    // Check if following lines should be included in List Item
                    while(src){
                        const rawLine = src.split('\n', 1)[0];
                        let nextLineWithoutTabs;
                        nextLine = rawLine;
                        // Re-align to follow commonmark nesting rules
                        if (this.options.pedantic) {
                            nextLine = nextLine.replace(this.rules.other.listReplaceNesting, '  ');
                            nextLineWithoutTabs = nextLine;
                        } else {
                            nextLineWithoutTabs = nextLine.replace(this.rules.other.tabCharGlobal, '    ');
                        }
                        // End list item if found code fences
                        if (fencesBeginRegex.test(nextLine)) {
                            break;
                        }
                        // End list item if found start of new heading
                        if (headingBeginRegex.test(nextLine)) {
                            break;
                        }
                        // End list item if found start of html block
                        if (htmlBeginRegex.test(nextLine)) {
                            break;
                        }
                        // End list item if found start of new bullet
                        if (nextBulletRegex.test(nextLine)) {
                            break;
                        }
                        // Horizontal rule found
                        if (hrRegex.test(nextLine)) {
                            break;
                        }
                        if (nextLineWithoutTabs.search(this.rules.other.nonSpaceChar) >= indent || !nextLine.trim()) {
                            itemContents += '\n' + nextLineWithoutTabs.slice(indent);
                        } else {
                            // not enough indentation
                            if (blankLine) {
                                break;
                            }
                            // paragraph continuation unless last line was a different block level element
                            if (line.replace(this.rules.other.tabCharGlobal, '    ').search(this.rules.other.nonSpaceChar) >= 4) {
                                break;
                            }
                            if (fencesBeginRegex.test(line)) {
                                break;
                            }
                            if (headingBeginRegex.test(line)) {
                                break;
                            }
                            if (hrRegex.test(line)) {
                                break;
                            }
                            itemContents += '\n' + nextLine;
                        }
                        if (!blankLine && !nextLine.trim()) {
                            blankLine = true;
                        }
                        raw += rawLine + '\n';
                        src = src.substring(rawLine.length + 1);
                        line = nextLineWithoutTabs.slice(indent);
                    }
                }
                if (!list.loose) {
                    // If the previous item ended with a blank line, the list is loose
                    if (endsWithBlankLine) {
                        list.loose = true;
                    } else if (this.rules.other.doubleBlankLine.test(raw)) {
                        endsWithBlankLine = true;
                    }
                }
                let istask = null;
                let ischecked;
                // Check for task list items
                if (this.options.gfm) {
                    istask = this.rules.other.listIsTask.exec(itemContents);
                    if (istask) {
                        ischecked = istask[0] !== '[ ] ';
                        itemContents = itemContents.replace(this.rules.other.listReplaceTask, '');
                    }
                }
                list.items.push({
                    type: 'list_item',
                    raw,
                    task: !!istask,
                    checked: ischecked,
                    loose: false,
                    text: itemContents,
                    tokens: []
                });
                list.raw += raw;
            }
            // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic
            const lastItem = list.items.at(-1);
            if (lastItem) {
                lastItem.raw = lastItem.raw.trimEnd();
                lastItem.text = lastItem.text.trimEnd();
            } else {
                // not a list since there were no items
                return;
            }
            list.raw = list.raw.trimEnd();
            // Item child tokens handled here at end because we needed to have the final item to trim it first
            for(let i = 0; i < list.items.length; i++){
                this.lexer.state.top = false;
                list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);
                if (!list.loose) {
                    // Check if list should be loose
                    const spacers = list.items[i].tokens.filter((t)=>t.type === 'space');
                    const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t)=>this.rules.other.anyLine.test(t.raw));
                    list.loose = hasMultipleLineBreaks;
                }
            }
            // Set all items to loose if list is loose
            if (list.loose) {
                for(let i = 0; i < list.items.length; i++){
                    list.items[i].loose = true;
                }
            }
            return list;
        }
    }
    html(src) {
        const cap = this.rules.block.html.exec(src);
        if (cap) {
            const token = {
                type: 'html',
                block: true,
                raw: cap[0],
                pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',
                text: cap[0]
            };
            return token;
        }
    }
    def(src) {
        const cap = this.rules.block.def.exec(src);
        if (cap) {
            const tag = cap[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, ' ');
            const href = cap[2] ? cap[2].replace(this.rules.other.hrefBrackets, '$1').replace(this.rules.inline.anyPunctuation, '$1') : '';
            const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, '$1') : cap[3];
            return {
                type: 'def',
                tag,
                raw: cap[0],
                href,
                title
            };
        }
    }
    table(src) {
        const cap = this.rules.block.table.exec(src);
        if (!cap) {
            return;
        }
        if (!this.rules.other.tableDelimiter.test(cap[2])) {
            // delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading
            return;
        }
        const headers = splitCells(cap[1]);
        const aligns = cap[2].replace(this.rules.other.tableAlignChars, '').split('|');
        const rows = cap[3]?.trim() ? cap[3].replace(this.rules.other.tableRowBlankLine, '').split('\n') : [];
        const item = {
            type: 'table',
            raw: cap[0],
            header: [],
            align: [],
            rows: []
        };
        if (headers.length !== aligns.length) {
            // header and align columns must be equal, rows can be different.
            return;
        }
        for (const align of aligns){
            if (this.rules.other.tableAlignRight.test(align)) {
                item.align.push('right');
            } else if (this.rules.other.tableAlignCenter.test(align)) {
                item.align.push('center');
            } else if (this.rules.other.tableAlignLeft.test(align)) {
                item.align.push('left');
            } else {
                item.align.push(null);
            }
        }
        for(let i = 0; i < headers.length; i++){
            item.header.push({
                text: headers[i],
                tokens: this.lexer.inline(headers[i]),
                header: true,
                align: item.align[i]
            });
        }
        for (const row of rows){
            item.rows.push(splitCells(row, item.header.length).map((cell, i)=>{
                return {
                    text: cell,
                    tokens: this.lexer.inline(cell),
                    header: false,
                    align: item.align[i]
                };
            }));
        }
        return item;
    }
    lheading(src) {
        const cap = this.rules.block.lheading.exec(src);
        if (cap) {
            return {
                type: 'heading',
                raw: cap[0],
                depth: cap[2].charAt(0) === '=' ? 1 : 2,
                text: cap[1],
                tokens: this.lexer.inline(cap[1])
            };
        }
    }
    paragraph(src) {
        const cap = this.rules.block.paragraph.exec(src);
        if (cap) {
            const text = cap[1].charAt(cap[1].length - 1) === '\n' ? cap[1].slice(0, -1) : cap[1];
            return {
                type: 'paragraph',
                raw: cap[0],
                text,
                tokens: this.lexer.inline(text)
            };
        }
    }
    text(src) {
        const cap = this.rules.block.text.exec(src);
        if (cap) {
            return {
                type: 'text',
                raw: cap[0],
                text: cap[0],
                tokens: this.lexer.inline(cap[0])
            };
        }
    }
    escape(src) {
        const cap = this.rules.inline.escape.exec(src);
        if (cap) {
            return {
                type: 'escape',
                raw: cap[0],
                text: cap[1]
            };
        }
    }
    tag(src) {
        const cap = this.rules.inline.tag.exec(src);
        if (cap) {
            if (!this.lexer.state.inLink && this.rules.other.startATag.test(cap[0])) {
                this.lexer.state.inLink = true;
            } else if (this.lexer.state.inLink && this.rules.other.endATag.test(cap[0])) {
                this.lexer.state.inLink = false;
            }
            if (!this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(cap[0])) {
                this.lexer.state.inRawBlock = true;
            } else if (this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(cap[0])) {
                this.lexer.state.inRawBlock = false;
            }
            return {
                type: 'html',
                raw: cap[0],
                inLink: this.lexer.state.inLink,
                inRawBlock: this.lexer.state.inRawBlock,
                block: false,
                text: cap[0]
            };
        }
    }
    link(src) {
        const cap = this.rules.inline.link.exec(src);
        if (cap) {
            const trimmedUrl = cap[2].trim();
            if (!this.options.pedantic && this.rules.other.startAngleBracket.test(trimmedUrl)) {
                // commonmark requires matching angle brackets
                if (!this.rules.other.endAngleBracket.test(trimmedUrl)) {
                    return;
                }
                // ending angle bracket cannot be escaped
                const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\');
                if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
                    return;
                }
            } else {
                // find closing parenthesis
                const lastParenIndex = findClosingBracket(cap[2], '()');
                if (lastParenIndex > -1) {
                    const start = cap[0].indexOf('!') === 0 ? 5 : 4;
                    const linkLen = start + cap[1].length + lastParenIndex;
                    cap[2] = cap[2].substring(0, lastParenIndex);
                    cap[0] = cap[0].substring(0, linkLen).trim();
                    cap[3] = '';
                }
            }
            let href = cap[2];
            let title = '';
            if (this.options.pedantic) {
                // split pedantic href and title
                const link = this.rules.other.pedanticHrefTitle.exec(href);
                if (link) {
                    href = link[1];
                    title = link[3];
                }
            } else {
                title = cap[3] ? cap[3].slice(1, -1) : '';
            }
            href = href.trim();
            if (this.rules.other.startAngleBracket.test(href)) {
                if (this.options.pedantic && !this.rules.other.endAngleBracket.test(trimmedUrl)) {
                    // pedantic allows starting angle bracket without ending angle bracket
                    href = href.slice(1);
                } else {
                    href = href.slice(1, -1);
                }
            }
            return outputLink(cap, {
                href: href ? href.replace(this.rules.inline.anyPunctuation, '$1') : href,
                title: title ? title.replace(this.rules.inline.anyPunctuation, '$1') : title
            }, cap[0], this.lexer, this.rules);
        }
    }
    reflink(src, links) {
        let cap;
        if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
            const linkString = (cap[2] || cap[1]).replace(this.rules.other.multipleSpaceGlobal, ' ');
            const link = links[linkString.toLowerCase()];
            if (!link) {
                const text = cap[0].charAt(0);
                return {
                    type: 'text',
                    raw: text,
                    text
                };
            }
            return outputLink(cap, link, cap[0], this.lexer, this.rules);
        }
    }
    emStrong(src, maskedSrc, prevChar = '') {
        let match = this.rules.inline.emStrongLDelim.exec(src);
        if (!match) return;
        // _ can't be between two alphanumerics. \p{L}\p{N} includes non-english alphabet/numbers as well
        if (match[3] && prevChar.match(this.rules.other.unicodeAlphaNumeric)) return;
        const nextChar = match[1] || match[2] || '';
        if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {
            // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)
            const lLength = [
                ...match[0]
            ].length - 1;
            let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
            const endReg = match[0][0] === '*' ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
            endReg.lastIndex = 0;
            // Clip maskedSrc to same section of string as src (move to lexer?)
            maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
            while((match = endReg.exec(maskedSrc)) != null){
                rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
                if (!rDelim) continue; // skip single * in __abc*abc__
                rLength = [
                    ...rDelim
                ].length;
                if (match[3] || match[4]) {
                    delimTotal += rLength;
                    continue;
                } else if (match[5] || match[6]) {
                    if (lLength % 3 && !((lLength + rLength) % 3)) {
                        midDelimTotal += rLength;
                        continue; // CommonMark Emphasis Rules 9-10
                    }
                }
                delimTotal -= rLength;
                if (delimTotal > 0) continue; // Haven't found enough closing delimiters
                // Remove extra characters. *a*** -> *a*
                rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
                // char length can be >1 for unicode characters;
                const lastCharLength = [
                    ...match[0]
                ][0].length;
                const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);
                // Create `em` if smallest delimiter has odd char count. *a***
                if (Math.min(lLength, rLength) % 2) {
                    const text = raw.slice(1, -1);
                    return {
                        type: 'em',
                        raw,
                        text,
                        tokens: this.lexer.inlineTokens(text)
                    };
                }
                // Create 'strong' if smallest delimiter has even char count. **a***
                const text = raw.slice(2, -2);
                return {
                    type: 'strong',
                    raw,
                    text,
                    tokens: this.lexer.inlineTokens(text)
                };
            }
        }
    }
    codespan(src) {
        const cap = this.rules.inline.code.exec(src);
        if (cap) {
            let text = cap[2].replace(this.rules.other.newLineCharGlobal, ' ');
            const hasNonSpaceChars = this.rules.other.nonSpaceChar.test(text);
            const hasSpaceCharsOnBothEnds = this.rules.other.startingSpaceChar.test(text) && this.rules.other.endingSpaceChar.test(text);
            if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
                text = text.substring(1, text.length - 1);
            }
            return {
                type: 'codespan',
                raw: cap[0],
                text
            };
        }
    }
    br(src) {
        const cap = this.rules.inline.br.exec(src);
        if (cap) {
            return {
                type: 'br',
                raw: cap[0]
            };
        }
    }
    del(src) {
        const cap = this.rules.inline.del.exec(src);
        if (cap) {
            return {
                type: 'del',
                raw: cap[0],
                text: cap[2],
                tokens: this.lexer.inlineTokens(cap[2])
            };
        }
    }
    autolink(src) {
        const cap = this.rules.inline.autolink.exec(src);
        if (cap) {
            let text, href;
            if (cap[2] === '@') {
                text = cap[1];
                href = 'mailto:' + text;
            } else {
                text = cap[1];
                href = text;
            }
            return {
                type: 'link',
                raw: cap[0],
                text,
                href,
                tokens: [
                    {
                        type: 'text',
                        raw: text,
                        text
                    }
                ]
            };
        }
    }
    url(src) {
        let cap;
        if (cap = this.rules.inline.url.exec(src)) {
            let text, href;
            if (cap[2] === '@') {
                text = cap[0];
                href = 'mailto:' + text;
            } else {
                // do extended autolink path validation
                let prevCapZero;
                do {
                    prevCapZero = cap[0];
                    cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? '';
                }while (prevCapZero !== cap[0])
                text = cap[0];
                if (cap[1] === 'www.') {
                    href = 'http://' + cap[0];
                } else {
                    href = cap[0];
                }
            }
            return {
                type: 'link',
                raw: cap[0],
                text,
                href,
                tokens: [
                    {
                        type: 'text',
                        raw: text,
                        text
                    }
                ]
            };
        }
    }
    inlineText(src) {
        const cap = this.rules.inline.text.exec(src);
        if (cap) {
            const escaped = this.lexer.state.inRawBlock;
            return {
                type: 'text',
                raw: cap[0],
                text: cap[0],
                escaped
            };
        }
    }
}
/**
 * Block Lexer
 */ class _Lexer {
    tokens;
    options;
    state;
    tokenizer;
    inlineQueue;
    constructor(options){
        // TokenList cannot be created in one go
        this.tokens = [];
        this.tokens.links = Object.create(null);
        this.options = options || _defaults;
        this.options.tokenizer = this.options.tokenizer || new _Tokenizer();
        this.tokenizer = this.options.tokenizer;
        this.tokenizer.options = this.options;
        this.tokenizer.lexer = this;
        this.inlineQueue = [];
        this.state = {
            inLink: false,
            inRawBlock: false,
            top: true
        };
        const rules = {
            other,
            block: block.normal,
            inline: inline.normal
        };
        if (this.options.pedantic) {
            rules.block = block.pedantic;
            rules.inline = inline.pedantic;
        } else if (this.options.gfm) {
            rules.block = block.gfm;
            if (this.options.breaks) {
                rules.inline = inline.breaks;
            } else {
                rules.inline = inline.gfm;
            }
        }
        this.tokenizer.rules = rules;
    }
    /**
     * Expose Rules
     */ static get rules() {
        return {
            block,
            inline
        };
    }
    /**
     * Static Lex Method
     */ static lex(src, options) {
        const lexer = new _Lexer(options);
        return lexer.lex(src);
    }
    /**
     * Static Lex Inline Method
     */ static lexInline(src, options) {
        const lexer = new _Lexer(options);
        return lexer.inlineTokens(src);
    }
    /**
     * Preprocessing
     */ lex(src) {
        src = src.replace(other.carriageReturn, '\n');
        this.blockTokens(src, this.tokens);
        for(let i = 0; i < this.inlineQueue.length; i++){
            const next = this.inlineQueue[i];
            this.inlineTokens(next.src, next.tokens);
        }
        this.inlineQueue = [];
        return this.tokens;
    }
    blockTokens(src, tokens = [], lastParagraphClipped = false) {
        if (this.options.pedantic) {
            src = src.replace(other.tabCharGlobal, '    ').replace(other.spaceLine, '');
        }
        while(src){
            let token;
            if (this.options.extensions?.block?.some((extTokenizer)=>{
                if (token = extTokenizer.call({
                    lexer: this
                }, src, tokens)) {
                    src = src.substring(token.raw.length);
                    tokens.push(token);
                    return true;
                }
                return false;
            })) {
                continue;
            }
            // newline
            if (token = this.tokenizer.space(src)) {
                src = src.substring(token.raw.length);
                const lastToken = tokens.at(-1);
                if (token.raw.length === 1 && lastToken !== undefined) {
                    // if there's a single \n as a spacer, it's terminating the last line,
                    // so move it there so that we don't get unnecessary paragraph tags
                    lastToken.raw += '\n';
                } else {
                    tokens.push(token);
                }
                continue;
            }
            // code
            if (token = this.tokenizer.code(src)) {
                src = src.substring(token.raw.length);
                const lastToken = tokens.at(-1);
                // An indented code block cannot interrupt a paragraph.
                if (lastToken?.type === 'paragraph' || lastToken?.type === 'text') {
                    lastToken.raw += '\n' + token.raw;
                    lastToken.text += '\n' + token.text;
                    this.inlineQueue.at(-1).src = lastToken.text;
                } else {
                    tokens.push(token);
                }
                continue;
            }
            // fences
            if (token = this.tokenizer.fences(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // heading
            if (token = this.tokenizer.heading(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // hr
            if (token = this.tokenizer.hr(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // blockquote
            if (token = this.tokenizer.blockquote(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // list
            if (token = this.tokenizer.list(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // html
            if (token = this.tokenizer.html(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // def
            if (token = this.tokenizer.def(src)) {
                src = src.substring(token.raw.length);
                const lastToken = tokens.at(-1);
                if (lastToken?.type === 'paragraph' || lastToken?.type === 'text') {
                    lastToken.raw += '\n' + token.raw;
                    lastToken.text += '\n' + token.raw;
                    this.inlineQueue.at(-1).src = lastToken.text;
                } else if (!this.tokens.links[token.tag]) {
                    this.tokens.links[token.tag] = {
                        href: token.href,
                        title: token.title
                    };
                }
                continue;
            }
            // table (gfm)
            if (token = this.tokenizer.table(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // lheading
            if (token = this.tokenizer.lheading(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // top-level paragraph
            // prevent paragraph consuming extensions by clipping 'src' to extension start
            let cutSrc = src;
            if (this.options.extensions?.startBlock) {
                let startIndex = Infinity;
                const tempSrc = src.slice(1);
                let tempStart;
                this.options.extensions.startBlock.forEach((getStartIndex)=>{
                    tempStart = getStartIndex.call({
                        lexer: this
                    }, tempSrc);
                    if (typeof tempStart === 'number' && tempStart >= 0) {
                        startIndex = Math.min(startIndex, tempStart);
                    }
                });
                if (startIndex < Infinity && startIndex >= 0) {
                    cutSrc = src.substring(0, startIndex + 1);
                }
            }
            if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
                const lastToken = tokens.at(-1);
                if (lastParagraphClipped && lastToken?.type === 'paragraph') {
                    lastToken.raw += '\n' + token.raw;
                    lastToken.text += '\n' + token.text;
                    this.inlineQueue.pop();
                    this.inlineQueue.at(-1).src = lastToken.text;
                } else {
                    tokens.push(token);
                }
                lastParagraphClipped = cutSrc.length !== src.length;
                src = src.substring(token.raw.length);
                continue;
            }
            // text
            if (token = this.tokenizer.text(src)) {
                src = src.substring(token.raw.length);
                const lastToken = tokens.at(-1);
                if (lastToken?.type === 'text') {
                    lastToken.raw += '\n' + token.raw;
                    lastToken.text += '\n' + token.text;
                    this.inlineQueue.pop();
                    this.inlineQueue.at(-1).src = lastToken.text;
                } else {
                    tokens.push(token);
                }
                continue;
            }
            if (src) {
                const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
                if (this.options.silent) {
                    console.error(errMsg);
                    break;
                } else {
                    throw new Error(errMsg);
                }
            }
        }
        this.state.top = true;
        return tokens;
    }
    inline(src, tokens = []) {
        this.inlineQueue.push({
            src,
            tokens
        });
        return tokens;
    }
    /**
     * Lexing/Compiling
     */ inlineTokens(src, tokens = []) {
        // String with links masked to avoid interference with em and strong
        let maskedSrc = src;
        let match = null;
        // Mask out reflinks
        if (this.tokens.links) {
            const links = Object.keys(this.tokens.links);
            if (links.length > 0) {
                while((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null){
                    if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {
                        maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
                    }
                }
            }
        }
        // Mask out escaped characters
        while((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null){
            maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
        }
        // Mask out other blocks
        while((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null){
            maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
        }
        let keepPrevChar = false;
        let prevChar = '';
        while(src){
            if (!keepPrevChar) {
                prevChar = '';
            }
            keepPrevChar = false;
            let token;
            // extensions
            if (this.options.extensions?.inline?.some((extTokenizer)=>{
                if (token = extTokenizer.call({
                    lexer: this
                }, src, tokens)) {
                    src = src.substring(token.raw.length);
                    tokens.push(token);
                    return true;
                }
                return false;
            })) {
                continue;
            }
            // escape
            if (token = this.tokenizer.escape(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // tag
            if (token = this.tokenizer.tag(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // link
            if (token = this.tokenizer.link(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // reflink, nolink
            if (token = this.tokenizer.reflink(src, this.tokens.links)) {
                src = src.substring(token.raw.length);
                const lastToken = tokens.at(-1);
                if (token.type === 'text' && lastToken?.type === 'text') {
                    lastToken.raw += token.raw;
                    lastToken.text += token.text;
                } else {
                    tokens.push(token);
                }
                continue;
            }
            // em & strong
            if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // code
            if (token = this.tokenizer.codespan(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // br
            if (token = this.tokenizer.br(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // del (gfm)
            if (token = this.tokenizer.del(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // autolink
            if (token = this.tokenizer.autolink(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // url (gfm)
            if (!this.state.inLink && (token = this.tokenizer.url(src))) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // text
            // prevent inlineText consuming extensions by clipping 'src' to extension start
            let cutSrc = src;
            if (this.options.extensions?.startInline) {
                let startIndex = Infinity;
                const tempSrc = src.slice(1);
                let tempStart;
                this.options.extensions.startInline.forEach((getStartIndex)=>{
                    tempStart = getStartIndex.call({
                        lexer: this
                    }, tempSrc);
                    if (typeof tempStart === 'number' && tempStart >= 0) {
                        startIndex = Math.min(startIndex, tempStart);
                    }
                });
                if (startIndex < Infinity && startIndex >= 0) {
                    cutSrc = src.substring(0, startIndex + 1);
                }
            }
            if (token = this.tokenizer.inlineText(cutSrc)) {
                src = src.substring(token.raw.length);
                if (token.raw.slice(-1) !== '_') {
                    prevChar = token.raw.slice(-1);
                }
                keepPrevChar = true;
                const lastToken = tokens.at(-1);
                if (lastToken?.type === 'text') {
                    lastToken.raw += token.raw;
                    lastToken.text += token.text;
                } else {
                    tokens.push(token);
                }
                continue;
            }
            if (src) {
                const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
                if (this.options.silent) {
                    console.error(errMsg);
                    break;
                } else {
                    throw new Error(errMsg);
                }
            }
        }
        return tokens;
    }
}
/**
 * Renderer
 */ class _Renderer {
    options;
    parser;
    constructor(options){
        this.options = options || _defaults;
    }
    space(token) {
        return '';
    }
    code({ text, lang, escaped }) {
        const langString = (lang || '').match(other.notSpaceStart)?.[0];
        const code = text.replace(other.endingNewline, '') + '\n';
        if (!langString) {
            return '<pre><code>' + (escaped ? code : escape(code, true)) + '</code></pre>\n';
        }
        return '<pre><code class="language-' + escape(langString) + '">' + (escaped ? code : escape(code, true)) + '</code></pre>\n';
    }
    blockquote({ tokens }) {
        const body = this.parser.parse(tokens);
        return `<blockquote>\n${body}</blockquote>\n`;
    }
    html({ text }) {
        return text;
    }
    heading({ tokens, depth }) {
        return `<h${depth}>${this.parser.parseInline(tokens)}</h${depth}>\n`;
    }
    hr(token) {
        return '<hr>\n';
    }
    list(token) {
        const ordered = token.ordered;
        const start = token.start;
        let body = '';
        for(let j = 0; j < token.items.length; j++){
            const item = token.items[j];
            body += this.listitem(item);
        }
        const type = ordered ? 'ol' : 'ul';
        const startAttr = ordered && start !== 1 ? ' start="' + start + '"' : '';
        return '<' + type + startAttr + '>\n' + body + '</' + type + '>\n';
    }
    listitem(item) {
        let itemBody = '';
        if (item.task) {
            const checkbox = this.checkbox({
                checked: !!item.checked
            });
            if (item.loose) {
                if (item.tokens[0]?.type === 'paragraph') {
                    item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;
                    if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {
                        item.tokens[0].tokens[0].text = checkbox + ' ' + escape(item.tokens[0].tokens[0].text);
                        item.tokens[0].tokens[0].escaped = true;
                    }
                } else {
                    item.tokens.unshift({
                        type: 'text',
                        raw: checkbox + ' ',
                        text: checkbox + ' ',
                        escaped: true
                    });
                }
            } else {
                itemBody += checkbox + ' ';
            }
        }
        itemBody += this.parser.parse(item.tokens, !!item.loose);
        return `<li>${itemBody}</li>\n`;
    }
    checkbox({ checked }) {
        return '<input ' + (checked ? 'checked="" ' : '') + 'disabled="" type="checkbox">';
    }
    paragraph({ tokens }) {
        return `<p>${this.parser.parseInline(tokens)}</p>\n`;
    }
    table(token) {
        let header = '';
        // header
        let cell = '';
        for(let j = 0; j < token.header.length; j++){
            cell += this.tablecell(token.header[j]);
        }
        header += this.tablerow({
            text: cell
        });
        let body = '';
        for(let j = 0; j < token.rows.length; j++){
            const row = token.rows[j];
            cell = '';
            for(let k = 0; k < row.length; k++){
                cell += this.tablecell(row[k]);
            }
            body += this.tablerow({
                text: cell
            });
        }
        if (body) body = `<tbody>${body}</tbody>`;
        return '<table>\n' + '<thead>\n' + header + '</thead>\n' + body + '</table>\n';
    }
    tablerow({ text }) {
        return `<tr>\n${text}</tr>\n`;
    }
    tablecell(token) {
        const content = this.parser.parseInline(token.tokens);
        const type = token.header ? 'th' : 'td';
        const tag = token.align ? `<${type} align="${token.align}">` : `<${type}>`;
        return tag + content + `</${type}>\n`;
    }
    /**
     * span level renderer
     */ strong({ tokens }) {
        return `<strong>${this.parser.parseInline(tokens)}</strong>`;
    }
    em({ tokens }) {
        return `<em>${this.parser.parseInline(tokens)}</em>`;
    }
    codespan({ text }) {
        return `<code>${escape(text, true)}</code>`;
    }
    br(token) {
        return '<br>';
    }
    del({ tokens }) {
        return `<del>${this.parser.parseInline(tokens)}</del>`;
    }
    link({ href, title, tokens }) {
        const text = this.parser.parseInline(tokens);
        const cleanHref = cleanUrl(href);
        if (cleanHref === null) {
            return text;
        }
        href = cleanHref;
        let out = '<a href="' + href + '"';
        if (title) {
            out += ' title="' + escape(title) + '"';
        }
        out += '>' + text + '</a>';
        return out;
    }
    image({ href, title, text }) {
        const cleanHref = cleanUrl(href);
        if (cleanHref === null) {
            return escape(text);
        }
        href = cleanHref;
        let out = `<img src="${href}" alt="${text}"`;
        if (title) {
            out += ` title="${escape(title)}"`;
        }
        out += '>';
        return out;
    }
    text(token) {
        return 'tokens' in token && token.tokens ? this.parser.parseInline(token.tokens) : 'escaped' in token && token.escaped ? token.text : escape(token.text);
    }
}
/**
 * TextRenderer
 * returns only the textual part of the token
 */ class _TextRenderer {
    // no need for block level renderers
    strong({ text }) {
        return text;
    }
    em({ text }) {
        return text;
    }
    codespan({ text }) {
        return text;
    }
    del({ text }) {
        return text;
    }
    html({ text }) {
        return text;
    }
    text({ text }) {
        return text;
    }
    link({ text }) {
        return '' + text;
    }
    image({ text }) {
        return '' + text;
    }
    br() {
        return '';
    }
}
/**
 * Parsing & Compiling
 */ class _Parser {
    options;
    renderer;
    textRenderer;
    constructor(options){
        this.options = options || _defaults;
        this.options.renderer = this.options.renderer || new _Renderer();
        this.renderer = this.options.renderer;
        this.renderer.options = this.options;
        this.renderer.parser = this;
        this.textRenderer = new _TextRenderer();
    }
    /**
     * Static Parse Method
     */ static parse(tokens, options) {
        const parser = new _Parser(options);
        return parser.parse(tokens);
    }
    /**
     * Static Parse Inline Method
     */ static parseInline(tokens, options) {
        const parser = new _Parser(options);
        return parser.parseInline(tokens);
    }
    /**
     * Parse Loop
     */ parse(tokens, top = true) {
        let out = '';
        for(let i = 0; i < tokens.length; i++){
            const anyToken = tokens[i];
            // Run any renderer extensions
            if (this.options.extensions?.renderers?.[anyToken.type]) {
                const genericToken = anyToken;
                const ret = this.options.extensions.renderers[genericToken.type].call({
                    parser: this
                }, genericToken);
                if (ret !== false || ![
                    'space',
                    'hr',
                    'heading',
                    'code',
                    'table',
                    'blockquote',
                    'list',
                    'html',
                    'paragraph',
                    'text'
                ].includes(genericToken.type)) {
                    out += ret || '';
                    continue;
                }
            }
            const token = anyToken;
            switch(token.type){
                case 'space':
                    {
                        out += this.renderer.space(token);
                        continue;
                    }
                case 'hr':
                    {
                        out += this.renderer.hr(token);
                        continue;
                    }
                case 'heading':
                    {
                        out += this.renderer.heading(token);
                        continue;
                    }
                case 'code':
                    {
                        out += this.renderer.code(token);
                        continue;
                    }
                case 'table':
                    {
                        out += this.renderer.table(token);
                        continue;
                    }
                case 'blockquote':
                    {
                        out += this.renderer.blockquote(token);
                        continue;
                    }
                case 'list':
                    {
                        out += this.renderer.list(token);
                        continue;
                    }
                case 'html':
                    {
                        out += this.renderer.html(token);
                        continue;
                    }
                case 'paragraph':
                    {
                        out += this.renderer.paragraph(token);
                        continue;
                    }
                case 'text':
                    {
                        let textToken = token;
                        let body = this.renderer.text(textToken);
                        while(i + 1 < tokens.length && tokens[i + 1].type === 'text'){
                            textToken = tokens[++i];
                            body += '\n' + this.renderer.text(textToken);
                        }
                        if (top) {
                            out += this.renderer.paragraph({
                                type: 'paragraph',
                                raw: body,
                                text: body,
                                tokens: [
                                    {
                                        type: 'text',
                                        raw: body,
                                        text: body,
                                        escaped: true
                                    }
                                ]
                            });
                        } else {
                            out += body;
                        }
                        continue;
                    }
                default:
                    {
                        const errMsg = 'Token with "' + token.type + '" type was not found.';
                        if (this.options.silent) {
                            console.error(errMsg);
                            return '';
                        } else {
                            throw new Error(errMsg);
                        }
                    }
            }
        }
        return out;
    }
    /**
     * Parse Inline Tokens
     */ parseInline(tokens, renderer = this.renderer) {
        let out = '';
        for(let i = 0; i < tokens.length; i++){
            const anyToken = tokens[i];
            // Run any renderer extensions
            if (this.options.extensions?.renderers?.[anyToken.type]) {
                const ret = this.options.extensions.renderers[anyToken.type].call({
                    parser: this
                }, anyToken);
                if (ret !== false || ![
                    'escape',
                    'html',
                    'link',
                    'image',
                    'strong',
                    'em',
                    'codespan',
                    'br',
                    'del',
                    'text'
                ].includes(anyToken.type)) {
                    out += ret || '';
                    continue;
                }
            }
            const token = anyToken;
            switch(token.type){
                case 'escape':
                    {
                        out += renderer.text(token);
                        break;
                    }
                case 'html':
                    {
                        out += renderer.html(token);
                        break;
                    }
                case 'link':
                    {
                        out += renderer.link(token);
                        break;
                    }
                case 'image':
                    {
                        out += renderer.image(token);
                        break;
                    }
                case 'strong':
                    {
                        out += renderer.strong(token);
                        break;
                    }
                case 'em':
                    {
                        out += renderer.em(token);
                        break;
                    }
                case 'codespan':
                    {
                        out += renderer.codespan(token);
                        break;
                    }
                case 'br':
                    {
                        out += renderer.br(token);
                        break;
                    }
                case 'del':
                    {
                        out += renderer.del(token);
                        break;
                    }
                case 'text':
                    {
                        out += renderer.text(token);
                        break;
                    }
                default:
                    {
                        const errMsg = 'Token with "' + token.type + '" type was not found.';
                        if (this.options.silent) {
                            console.error(errMsg);
                            return '';
                        } else {
                            throw new Error(errMsg);
                        }
                    }
            }
        }
        return out;
    }
}
class _Hooks {
    options;
    block;
    constructor(options){
        this.options = options || _defaults;
    }
    static passThroughHooks = new Set([
        'preprocess',
        'postprocess',
        'processAllTokens'
    ]);
    /**
     * Process markdown before marked
     */ preprocess(markdown) {
        return markdown;
    }
    /**
     * Process HTML after marked is finished
     */ postprocess(html) {
        return html;
    }
    /**
     * Process all tokens before walk tokens
     */ processAllTokens(tokens) {
        return tokens;
    }
    /**
     * Provide function to tokenize markdown
     */ provideLexer() {
        return this.block ? _Lexer.lex : _Lexer.lexInline;
    }
    /**
     * Provide function to parse tokens
     */ provideParser() {
        return this.block ? _Parser.parse : _Parser.parseInline;
    }
}
class Marked {
    defaults = _getDefaults();
    options = this.setOptions;
    parse = this.parseMarkdown(true);
    parseInline = this.parseMarkdown(false);
    Parser = _Parser;
    Renderer = _Renderer;
    TextRenderer = _TextRenderer;
    Lexer = _Lexer;
    Tokenizer = _Tokenizer;
    Hooks = _Hooks;
    constructor(...args){
        this.use(...args);
    }
    /**
     * Run callback for every token
     */ walkTokens(tokens, callback) {
        let values = [];
        for (const token of tokens){
            values = values.concat(callback.call(this, token));
            switch(token.type){
                case 'table':
                    {
                        const tableToken = token;
                        for (const cell of tableToken.header){
                            values = values.concat(this.walkTokens(cell.tokens, callback));
                        }
                        for (const row of tableToken.rows){
                            for (const cell of row){
                                values = values.concat(this.walkTokens(cell.tokens, callback));
                            }
                        }
                        break;
                    }
                case 'list':
                    {
                        const listToken = token;
                        values = values.concat(this.walkTokens(listToken.items, callback));
                        break;
                    }
                default:
                    {
                        const genericToken = token;
                        if (this.defaults.extensions?.childTokens?.[genericToken.type]) {
                            this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens)=>{
                                const tokens = genericToken[childTokens].flat(Infinity);
                                values = values.concat(this.walkTokens(tokens, callback));
                            });
                        } else if (genericToken.tokens) {
                            values = values.concat(this.walkTokens(genericToken.tokens, callback));
                        }
                    }
            }
        }
        return values;
    }
    use(...args) {
        const extensions = this.defaults.extensions || {
            renderers: {},
            childTokens: {}
        };
        args.forEach((pack)=>{
            // copy options to new object
            const opts = {
                ...pack
            };
            // set async to true if it was set to true before
            opts.async = this.defaults.async || opts.async || false;
            // ==-- Parse "addon" extensions --== //
            if (pack.extensions) {
                pack.extensions.forEach((ext)=>{
                    if (!ext.name) {
                        throw new Error('extension name required');
                    }
                    if ('renderer' in ext) {
                        const prevRenderer = extensions.renderers[ext.name];
                        if (prevRenderer) {
                            // Replace extension with func to run new extension but fall back if false
                            extensions.renderers[ext.name] = function(...args) {
                                let ret = ext.renderer.apply(this, args);
                                if (ret === false) {
                                    ret = prevRenderer.apply(this, args);
                                }
                                return ret;
                            };
                        } else {
                            extensions.renderers[ext.name] = ext.renderer;
                        }
                    }
                    if ('tokenizer' in ext) {
                        if (!ext.level || ext.level !== 'block' && ext.level !== 'inline') {
                            throw new Error("extension level must be 'block' or 'inline'");
                        }
                        const extLevel = extensions[ext.level];
                        if (extLevel) {
                            extLevel.unshift(ext.tokenizer);
                        } else {
                            extensions[ext.level] = [
                                ext.tokenizer
                            ];
                        }
                        if (ext.start) {
                            if (ext.level === 'block') {
                                if (extensions.startBlock) {
                                    extensions.startBlock.push(ext.start);
                                } else {
                                    extensions.startBlock = [
                                        ext.start
                                    ];
                                }
                            } else if (ext.level === 'inline') {
                                if (extensions.startInline) {
                                    extensions.startInline.push(ext.start);
                                } else {
                                    extensions.startInline = [
                                        ext.start
                                    ];
                                }
                            }
                        }
                    }
                    if ('childTokens' in ext && ext.childTokens) {
                        extensions.childTokens[ext.name] = ext.childTokens;
                    }
                });
                opts.extensions = extensions;
            }
            // ==-- Parse "overwrite" extensions --== //
            if (pack.renderer) {
                const renderer = this.defaults.renderer || new _Renderer(this.defaults);
                for(const prop in pack.renderer){
                    if (!(prop in renderer)) {
                        throw new Error(`renderer '${prop}' does not exist`);
                    }
                    if ([
                        'options',
                        'parser'
                    ].includes(prop)) {
                        continue;
                    }
                    const rendererProp = prop;
                    const rendererFunc = pack.renderer[rendererProp];
                    const prevRenderer = renderer[rendererProp];
                    // Replace renderer with func to run extension, but fall back if false
                    renderer[rendererProp] = (...args)=>{
                        let ret = rendererFunc.apply(renderer, args);
                        if (ret === false) {
                            ret = prevRenderer.apply(renderer, args);
                        }
                        return ret || '';
                    };
                }
                opts.renderer = renderer;
            }
            if (pack.tokenizer) {
                const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);
                for(const prop in pack.tokenizer){
                    if (!(prop in tokenizer)) {
                        throw new Error(`tokenizer '${prop}' does not exist`);
                    }
                    if ([
                        'options',
                        'rules',
                        'lexer'
                    ].includes(prop)) {
                        continue;
                    }
                    const tokenizerProp = prop;
                    const tokenizerFunc = pack.tokenizer[tokenizerProp];
                    const prevTokenizer = tokenizer[tokenizerProp];
                    // Replace tokenizer with func to run extension, but fall back if false
                    // @ts-expect-error cannot type tokenizer function dynamically
                    tokenizer[tokenizerProp] = (...args)=>{
                        let ret = tokenizerFunc.apply(tokenizer, args);
                        if (ret === false) {
                            ret = prevTokenizer.apply(tokenizer, args);
                        }
                        return ret;
                    };
                }
                opts.tokenizer = tokenizer;
            }
            // ==-- Parse Hooks extensions --== //
            if (pack.hooks) {
                const hooks = this.defaults.hooks || new _Hooks();
                for(const prop in pack.hooks){
                    if (!(prop in hooks)) {
                        throw new Error(`hook '${prop}' does not exist`);
                    }
                    if ([
                        'options',
                        'block'
                    ].includes(prop)) {
                        continue;
                    }
                    const hooksProp = prop;
                    const hooksFunc = pack.hooks[hooksProp];
                    const prevHook = hooks[hooksProp];
                    if (_Hooks.passThroughHooks.has(prop)) {
                        // @ts-expect-error cannot type hook function dynamically
                        hooks[hooksProp] = (arg)=>{
                            if (this.defaults.async) {
                                return Promise.resolve(hooksFunc.call(hooks, arg)).then((ret)=>{
                                    return prevHook.call(hooks, ret);
                                });
                            }
                            const ret = hooksFunc.call(hooks, arg);
                            return prevHook.call(hooks, ret);
                        };
                    } else {
                        // @ts-expect-error cannot type hook function dynamically
                        hooks[hooksProp] = (...args)=>{
                            let ret = hooksFunc.apply(hooks, args);
                            if (ret === false) {
                                ret = prevHook.apply(hooks, args);
                            }
                            return ret;
                        };
                    }
                }
                opts.hooks = hooks;
            }
            // ==-- Parse WalkTokens extensions --== //
            if (pack.walkTokens) {
                const walkTokens = this.defaults.walkTokens;
                const packWalktokens = pack.walkTokens;
                opts.walkTokens = function(token) {
                    let values = [];
                    values.push(packWalktokens.call(this, token));
                    if (walkTokens) {
                        values = values.concat(walkTokens.call(this, token));
                    }
                    return values;
                };
            }
            this.defaults = {
                ...this.defaults,
                ...opts
            };
        });
        return this;
    }
    setOptions(opt) {
        this.defaults = {
            ...this.defaults,
            ...opt
        };
        return this;
    }
    lexer(src, options) {
        return _Lexer.lex(src, options ?? this.defaults);
    }
    parser(tokens, options) {
        return _Parser.parse(tokens, options ?? this.defaults);
    }
    parseMarkdown(blockType) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const parse = (src, options)=>{
            const origOpt = {
                ...options
            };
            const opt = {
                ...this.defaults,
                ...origOpt
            };
            const throwError = this.onError(!!opt.silent, !!opt.async);
            // throw error if an extension set async to true but parse was called with async: false
            if (this.defaults.async === true && origOpt.async === false) {
                return throwError(new Error('marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.'));
            }
            // throw error in case of non string input
            if (typeof src === 'undefined' || src === null) {
                return throwError(new Error('marked(): input parameter is undefined or null'));
            }
            if (typeof src !== 'string') {
                return throwError(new Error('marked(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected'));
            }
            if (opt.hooks) {
                opt.hooks.options = opt;
                opt.hooks.block = blockType;
            }
            const lexer = opt.hooks ? opt.hooks.provideLexer() : blockType ? _Lexer.lex : _Lexer.lexInline;
            const parser = opt.hooks ? opt.hooks.provideParser() : blockType ? _Parser.parse : _Parser.parseInline;
            if (opt.async) {
                return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src)=>lexer(src, opt)).then((tokens)=>opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens).then((tokens)=>opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(()=>tokens) : tokens).then((tokens)=>parser(tokens, opt)).then((html)=>opt.hooks ? opt.hooks.postprocess(html) : html).catch(throwError);
            }
            try {
                if (opt.hooks) {
                    src = opt.hooks.preprocess(src);
                }
                let tokens = lexer(src, opt);
                if (opt.hooks) {
                    tokens = opt.hooks.processAllTokens(tokens);
                }
                if (opt.walkTokens) {
                    this.walkTokens(tokens, opt.walkTokens);
                }
                let html = parser(tokens, opt);
                if (opt.hooks) {
                    html = opt.hooks.postprocess(html);
                }
                return html;
            } catch (e) {
                return throwError(e);
            }
        };
        return parse;
    }
    onError(silent, async) {
        return (e)=>{
            e.message += '\nPlease report this to https://github.com/markedjs/marked.';
            if (silent) {
                const msg = '<p>An error occurred:</p><pre>' + escape(e.message + '', true) + '</pre>';
                if (async) {
                    return Promise.resolve(msg);
                }
                return msg;
            }
            if (async) {
                return Promise.reject(e);
            }
            throw e;
        };
    }
}
const markedInstance = new Marked();
function marked(src, opt) {
    return markedInstance.parse(src, opt);
}
/**
 * Sets the default options.
 *
 * @param options Hash of options
 */ marked.options = marked.setOptions = function(options) {
    markedInstance.setOptions(options);
    marked.defaults = markedInstance.defaults;
    changeDefaults(marked.defaults);
    return marked;
};
/**
 * Gets the original marked default options.
 */ marked.getDefaults = _getDefaults;
marked.defaults = _defaults;
/**
 * Use Extension
 */ marked.use = function(...args) {
    markedInstance.use(...args);
    marked.defaults = markedInstance.defaults;
    changeDefaults(marked.defaults);
    return marked;
};
/**
 * Run callback for every token
 */ marked.walkTokens = function(tokens, callback) {
    return markedInstance.walkTokens(tokens, callback);
};
/**
 * Compiles markdown to HTML without enclosing `p` tag.
 *
 * @param src String of markdown source to be compiled
 * @param options Hash of options
 * @return String of compiled HTML
 */ marked.parseInline = markedInstance.parseInline;
/**
 * Expose
 */ marked.Parser = _Parser;
marked.parser = _Parser.parse;
marked.Renderer = _Renderer;
marked.TextRenderer = _TextRenderer;
marked.Lexer = _Lexer;
marked.lexer = _Lexer.lex;
marked.Tokenizer = _Tokenizer;
marked.Hooks = _Hooks;
marked.parse = marked;
const options = marked.options;
const setOptions = marked.setOptions;
const use = marked.use;
const walkTokens = marked.walkTokens;
const parseInline = marked.parseInline;
const parse = marked;
const parser = _Parser.parse;
const lexer = _Lexer.lex;
;
 //# sourceMappingURL=marked.esm.js.map
}}),
"[project]/node_modules/i18next/dist/esm/i18next.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "changeLanguage": (()=>changeLanguage),
    "createInstance": (()=>createInstance),
    "default": (()=>instance),
    "dir": (()=>dir),
    "exists": (()=>exists),
    "getFixedT": (()=>getFixedT),
    "hasLoadedNamespace": (()=>hasLoadedNamespace),
    "init": (()=>init),
    "loadLanguages": (()=>loadLanguages),
    "loadNamespaces": (()=>loadNamespaces),
    "loadResources": (()=>loadResources),
    "reloadResources": (()=>reloadResources),
    "setDefaultNamespace": (()=>setDefaultNamespace),
    "t": (()=>t),
    "use": (()=>use)
});
const isString = (obj)=>typeof obj === 'string';
const defer = ()=>{
    let res;
    let rej;
    const promise = new Promise((resolve, reject)=>{
        res = resolve;
        rej = reject;
    });
    promise.resolve = res;
    promise.reject = rej;
    return promise;
};
const makeString = (object)=>{
    if (object == null) return '';
    return '' + object;
};
const copy = (a, s, t)=>{
    a.forEach((m)=>{
        if (s[m]) t[m] = s[m];
    });
};
const lastOfPathSeparatorRegExp = /###/g;
const cleanKey = (key)=>key && key.indexOf('###') > -1 ? key.replace(lastOfPathSeparatorRegExp, '.') : key;
const canNotTraverseDeeper = (object)=>!object || isString(object);
const getLastOfPath = (object, path, Empty)=>{
    const stack = !isString(path) ? path : path.split('.');
    let stackIndex = 0;
    while(stackIndex < stack.length - 1){
        if (canNotTraverseDeeper(object)) return {};
        const key = cleanKey(stack[stackIndex]);
        if (!object[key] && Empty) object[key] = new Empty();
        if (Object.prototype.hasOwnProperty.call(object, key)) {
            object = object[key];
        } else {
            object = {};
        }
        ++stackIndex;
    }
    if (canNotTraverseDeeper(object)) return {};
    return {
        obj: object,
        k: cleanKey(stack[stackIndex])
    };
};
const setPath = (object, path, newValue)=>{
    const { obj, k } = getLastOfPath(object, path, Object);
    if (obj !== undefined || path.length === 1) {
        obj[k] = newValue;
        return;
    }
    let e = path[path.length - 1];
    let p = path.slice(0, path.length - 1);
    let last = getLastOfPath(object, p, Object);
    while(last.obj === undefined && p.length){
        e = `${p[p.length - 1]}.${e}`;
        p = p.slice(0, p.length - 1);
        last = getLastOfPath(object, p, Object);
        if (last?.obj && typeof last.obj[`${last.k}.${e}`] !== 'undefined') {
            last.obj = undefined;
        }
    }
    last.obj[`${last.k}.${e}`] = newValue;
};
const pushPath = (object, path, newValue, concat)=>{
    const { obj, k } = getLastOfPath(object, path, Object);
    obj[k] = obj[k] || [];
    obj[k].push(newValue);
};
const getPath = (object, path)=>{
    const { obj, k } = getLastOfPath(object, path);
    if (!obj) return undefined;
    if (!Object.prototype.hasOwnProperty.call(obj, k)) return undefined;
    return obj[k];
};
const getPathWithDefaults = (data, defaultData, key)=>{
    const value = getPath(data, key);
    if (value !== undefined) {
        return value;
    }
    return getPath(defaultData, key);
};
const deepExtend = (target, source, overwrite)=>{
    for(const prop in source){
        if (prop !== '__proto__' && prop !== 'constructor') {
            if (prop in target) {
                if (isString(target[prop]) || target[prop] instanceof String || isString(source[prop]) || source[prop] instanceof String) {
                    if (overwrite) target[prop] = source[prop];
                } else {
                    deepExtend(target[prop], source[prop], overwrite);
                }
            } else {
                target[prop] = source[prop];
            }
        }
    }
    return target;
};
const regexEscape = (str)=>str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
var _entityMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '/': '&#x2F;'
};
const escape = (data)=>{
    if (isString(data)) {
        return data.replace(/[&<>"'\/]/g, (s)=>_entityMap[s]);
    }
    return data;
};
class RegExpCache {
    constructor(capacity){
        this.capacity = capacity;
        this.regExpMap = new Map();
        this.regExpQueue = [];
    }
    getRegExp(pattern) {
        const regExpFromCache = this.regExpMap.get(pattern);
        if (regExpFromCache !== undefined) {
            return regExpFromCache;
        }
        const regExpNew = new RegExp(pattern);
        if (this.regExpQueue.length === this.capacity) {
            this.regExpMap.delete(this.regExpQueue.shift());
        }
        this.regExpMap.set(pattern, regExpNew);
        this.regExpQueue.push(pattern);
        return regExpNew;
    }
}
const chars = [
    ' ',
    ',',
    '?',
    '!',
    ';'
];
const looksLikeObjectPathRegExpCache = new RegExpCache(20);
const looksLikeObjectPath = (key, nsSeparator, keySeparator)=>{
    nsSeparator = nsSeparator || '';
    keySeparator = keySeparator || '';
    const possibleChars = chars.filter((c)=>nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0);
    if (possibleChars.length === 0) return true;
    const r = looksLikeObjectPathRegExpCache.getRegExp(`(${possibleChars.map((c)=>c === '?' ? '\\?' : c).join('|')})`);
    let matched = !r.test(key);
    if (!matched) {
        const ki = key.indexOf(keySeparator);
        if (ki > 0 && !r.test(key.substring(0, ki))) {
            matched = true;
        }
    }
    return matched;
};
const deepFind = function(obj, path) {
    let keySeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '.';
    if (!obj) return undefined;
    if (obj[path]) {
        if (!Object.prototype.hasOwnProperty.call(obj, path)) return undefined;
        return obj[path];
    }
    const tokens = path.split(keySeparator);
    let current = obj;
    for(let i = 0; i < tokens.length;){
        if (!current || typeof current !== 'object') {
            return undefined;
        }
        let next;
        let nextPath = '';
        for(let j = i; j < tokens.length; ++j){
            if (j !== i) {
                nextPath += keySeparator;
            }
            nextPath += tokens[j];
            next = current[nextPath];
            if (next !== undefined) {
                if ([
                    'string',
                    'number',
                    'boolean'
                ].indexOf(typeof next) > -1 && j < tokens.length - 1) {
                    continue;
                }
                i += j - i + 1;
                break;
            }
        }
        current = next;
    }
    return current;
};
const getCleanedCode = (code)=>code?.replace('_', '-');
const consoleLogger = {
    type: 'logger',
    log (args) {
        this.output('log', args);
    },
    warn (args) {
        this.output('warn', args);
    },
    error (args) {
        this.output('error', args);
    },
    output (type, args) {
        console?.[type]?.apply?.(console, args);
    }
};
class Logger {
    constructor(concreteLogger){
        let options1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        this.init(concreteLogger, options1);
    }
    init(concreteLogger) {
        let options1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        this.prefix = options1.prefix || 'i18next:';
        this.logger = concreteLogger || consoleLogger;
        this.options = options1;
        this.debug = options1.debug;
    }
    log() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        return this.forward(args, 'log', '', true);
    }
    warn() {
        for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){
            args[_key2] = arguments[_key2];
        }
        return this.forward(args, 'warn', '', true);
    }
    error() {
        for(var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++){
            args[_key3] = arguments[_key3];
        }
        return this.forward(args, 'error', '');
    }
    deprecate() {
        for(var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++){
            args[_key4] = arguments[_key4];
        }
        return this.forward(args, 'warn', 'WARNING DEPRECATED: ', true);
    }
    forward(args, lvl, prefix, debugOnly) {
        if (debugOnly && !this.debug) return null;
        if (isString(args[0])) args[0] = `${prefix}${this.prefix} ${args[0]}`;
        return this.logger[lvl](args);
    }
    create(moduleName) {
        return new Logger(this.logger, {
            ...{
                prefix: `${this.prefix}:${moduleName}:`
            },
            ...this.options
        });
    }
    clone(options1) {
        options1 = options1 || this.options;
        options1.prefix = options1.prefix || this.prefix;
        return new Logger(this.logger, options1);
    }
}
var baseLogger = new Logger();
class EventEmitter {
    constructor(){
        this.observers = {};
    }
    on(events, listener) {
        events.split(' ').forEach((event)=>{
            if (!this.observers[event]) this.observers[event] = new Map();
            const numListeners = this.observers[event].get(listener) || 0;
            this.observers[event].set(listener, numListeners + 1);
        });
        return this;
    }
    off(event, listener) {
        if (!this.observers[event]) return;
        if (!listener) {
            delete this.observers[event];
            return;
        }
        this.observers[event].delete(listener);
    }
    emit(event) {
        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            args[_key - 1] = arguments[_key];
        }
        if (this.observers[event]) {
            const cloned = Array.from(this.observers[event].entries());
            cloned.forEach((_ref)=>{
                let [observer, numTimesAdded] = _ref;
                for(let i = 0; i < numTimesAdded; i++){
                    observer(...args);
                }
            });
        }
        if (this.observers['*']) {
            const cloned = Array.from(this.observers['*'].entries());
            cloned.forEach((_ref2)=>{
                let [observer, numTimesAdded] = _ref2;
                for(let i = 0; i < numTimesAdded; i++){
                    observer.apply(observer, [
                        event,
                        ...args
                    ]);
                }
            });
        }
    }
}
class ResourceStore extends EventEmitter {
    constructor(data){
        let options1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
            ns: [
                'translation'
            ],
            defaultNS: 'translation'
        };
        super();
        this.data = data || {};
        this.options = options1;
        if (this.options.keySeparator === undefined) {
            this.options.keySeparator = '.';
        }
        if (this.options.ignoreJSONStructure === undefined) {
            this.options.ignoreJSONStructure = true;
        }
    }
    addNamespaces(ns) {
        if (this.options.ns.indexOf(ns) < 0) {
            this.options.ns.push(ns);
        }
    }
    removeNamespaces(ns) {
        const index = this.options.ns.indexOf(ns);
        if (index > -1) {
            this.options.ns.splice(index, 1);
        }
    }
    getResource(lng, ns, key) {
        let options1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        const keySeparator = options1.keySeparator !== undefined ? options1.keySeparator : this.options.keySeparator;
        const ignoreJSONStructure = options1.ignoreJSONStructure !== undefined ? options1.ignoreJSONStructure : this.options.ignoreJSONStructure;
        let path;
        if (lng.indexOf('.') > -1) {
            path = lng.split('.');
        } else {
            path = [
                lng,
                ns
            ];
            if (key) {
                if (Array.isArray(key)) {
                    path.push(...key);
                } else if (isString(key) && keySeparator) {
                    path.push(...key.split(keySeparator));
                } else {
                    path.push(key);
                }
            }
        }
        const result = getPath(this.data, path);
        if (!result && !ns && !key && lng.indexOf('.') > -1) {
            lng = path[0];
            ns = path[1];
            key = path.slice(2).join('.');
        }
        if (result || !ignoreJSONStructure || !isString(key)) return result;
        return deepFind(this.data?.[lng]?.[ns], key, keySeparator);
    }
    addResource(lng, ns, key, value) {
        let options1 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {
            silent: false
        };
        const keySeparator = options1.keySeparator !== undefined ? options1.keySeparator : this.options.keySeparator;
        let path = [
            lng,
            ns
        ];
        if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);
        if (lng.indexOf('.') > -1) {
            path = lng.split('.');
            value = ns;
            ns = path[1];
        }
        this.addNamespaces(ns);
        setPath(this.data, path, value);
        if (!options1.silent) this.emit('added', lng, ns, key, value);
    }
    addResources(lng, ns, resources) {
        let options1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
            silent: false
        };
        for(const m in resources){
            if (isString(resources[m]) || Array.isArray(resources[m])) this.addResource(lng, ns, m, resources[m], {
                silent: true
            });
        }
        if (!options1.silent) this.emit('added', lng, ns, resources);
    }
    addResourceBundle(lng, ns, resources, deep, overwrite) {
        let options1 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {
            silent: false,
            skipCopy: false
        };
        let path = [
            lng,
            ns
        ];
        if (lng.indexOf('.') > -1) {
            path = lng.split('.');
            deep = resources;
            resources = ns;
            ns = path[1];
        }
        this.addNamespaces(ns);
        let pack = getPath(this.data, path) || {};
        if (!options1.skipCopy) resources = JSON.parse(JSON.stringify(resources));
        if (deep) {
            deepExtend(pack, resources, overwrite);
        } else {
            pack = {
                ...pack,
                ...resources
            };
        }
        setPath(this.data, path, pack);
        if (!options1.silent) this.emit('added', lng, ns, resources);
    }
    removeResourceBundle(lng, ns) {
        if (this.hasResourceBundle(lng, ns)) {
            delete this.data[lng][ns];
        }
        this.removeNamespaces(ns);
        this.emit('removed', lng, ns);
    }
    hasResourceBundle(lng, ns) {
        return this.getResource(lng, ns) !== undefined;
    }
    getResourceBundle(lng, ns) {
        if (!ns) ns = this.options.defaultNS;
        return this.getResource(lng, ns);
    }
    getDataByLanguage(lng) {
        return this.data[lng];
    }
    hasLanguageSomeTranslations(lng) {
        const data = this.getDataByLanguage(lng);
        const n = data && Object.keys(data) || [];
        return !!n.find((v)=>data[v] && Object.keys(data[v]).length > 0);
    }
    toJSON() {
        return this.data;
    }
}
var postProcessor = {
    processors: {},
    addPostProcessor (module) {
        this.processors[module.name] = module;
    },
    handle (processors, value, key, options1, translator) {
        processors.forEach((processor)=>{
            value = this.processors[processor]?.process(value, key, options1, translator) ?? value;
        });
        return value;
    }
};
const checkedLoadedFor = {};
const shouldHandleAsObject = (res)=>!isString(res) && typeof res !== 'boolean' && typeof res !== 'number';
class Translator extends EventEmitter {
    constructor(services){
        let options1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        super();
        copy([
            'resourceStore',
            'languageUtils',
            'pluralResolver',
            'interpolator',
            'backendConnector',
            'i18nFormat',
            'utils'
        ], services, this);
        this.options = options1;
        if (this.options.keySeparator === undefined) {
            this.options.keySeparator = '.';
        }
        this.logger = baseLogger.create('translator');
    }
    changeLanguage(lng) {
        if (lng) this.language = lng;
    }
    exists(key) {
        let options1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
            interpolation: {}
        };
        if (key == null) {
            return false;
        }
        const resolved = this.resolve(key, options1);
        return resolved?.res !== undefined;
    }
    extractFromKey(key, opt) {
        let nsSeparator = opt.nsSeparator !== undefined ? opt.nsSeparator : this.options.nsSeparator;
        if (nsSeparator === undefined) nsSeparator = ':';
        const keySeparator = opt.keySeparator !== undefined ? opt.keySeparator : this.options.keySeparator;
        let namespaces = opt.ns || this.options.defaultNS || [];
        const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
        const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !opt.keySeparator && !this.options.userDefinedNsSeparator && !opt.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
        if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
            const m = key.match(this.interpolator.nestingRegexp);
            if (m && m.length > 0) {
                return {
                    key,
                    namespaces: isString(namespaces) ? [
                        namespaces
                    ] : namespaces
                };
            }
            const parts = key.split(nsSeparator);
            if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
            key = parts.join(keySeparator);
        }
        return {
            key,
            namespaces: isString(namespaces) ? [
                namespaces
            ] : namespaces
        };
    }
    translate(keys, opt, lastKey) {
        if (typeof opt !== 'object' && this.options.overloadTranslationOptionHandler) {
            opt = this.options.overloadTranslationOptionHandler(arguments);
        }
        if (typeof options === 'object') opt = {
            ...opt
        };
        if (!opt) opt = {};
        if (keys == null) return '';
        if (!Array.isArray(keys)) keys = [
            String(keys)
        ];
        const returnDetails = opt.returnDetails !== undefined ? opt.returnDetails : this.options.returnDetails;
        const keySeparator = opt.keySeparator !== undefined ? opt.keySeparator : this.options.keySeparator;
        const { key, namespaces } = this.extractFromKey(keys[keys.length - 1], opt);
        const namespace = namespaces[namespaces.length - 1];
        const lng = opt.lng || this.language;
        const appendNamespaceToCIMode = opt.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
        if (lng?.toLowerCase() === 'cimode') {
            if (appendNamespaceToCIMode) {
                const nsSeparator = opt.nsSeparator || this.options.nsSeparator;
                if (returnDetails) {
                    return {
                        res: `${namespace}${nsSeparator}${key}`,
                        usedKey: key,
                        exactUsedKey: key,
                        usedLng: lng,
                        usedNS: namespace,
                        usedParams: this.getUsedParamsDetails(opt)
                    };
                }
                return `${namespace}${nsSeparator}${key}`;
            }
            if (returnDetails) {
                return {
                    res: key,
                    usedKey: key,
                    exactUsedKey: key,
                    usedLng: lng,
                    usedNS: namespace,
                    usedParams: this.getUsedParamsDetails(opt)
                };
            }
            return key;
        }
        const resolved = this.resolve(keys, opt);
        let res = resolved?.res;
        const resUsedKey = resolved?.usedKey || key;
        const resExactUsedKey = resolved?.exactUsedKey || key;
        const noObject = [
            '[object Number]',
            '[object Function]',
            '[object RegExp]'
        ];
        const joinArrays = opt.joinArrays !== undefined ? opt.joinArrays : this.options.joinArrays;
        const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
        const needsPluralHandling = opt.count !== undefined && !isString(opt.count);
        const hasDefaultValue = Translator.hasDefaultValue(opt);
        const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, opt.count, opt) : '';
        const defaultValueSuffixOrdinalFallback = opt.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, opt.count, {
            ordinal: false
        }) : '';
        const needsZeroSuffixLookup = needsPluralHandling && !opt.ordinal && opt.count === 0;
        const defaultValue = needsZeroSuffixLookup && opt[`defaultValue${this.options.pluralSeparator}zero`] || opt[`defaultValue${defaultValueSuffix}`] || opt[`defaultValue${defaultValueSuffixOrdinalFallback}`] || opt.defaultValue;
        let resForObjHndl = res;
        if (handleAsObjectInI18nFormat && !res && hasDefaultValue) {
            resForObjHndl = defaultValue;
        }
        const handleAsObject = shouldHandleAsObject(resForObjHndl);
        const resType = Object.prototype.toString.apply(resForObjHndl);
        if (handleAsObjectInI18nFormat && resForObjHndl && handleAsObject && noObject.indexOf(resType) < 0 && !(isString(joinArrays) && Array.isArray(resForObjHndl))) {
            if (!opt.returnObjects && !this.options.returnObjects) {
                if (!this.options.returnedObjectHandler) {
                    this.logger.warn('accessing an object - but returnObjects options is not enabled!');
                }
                const r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, resForObjHndl, {
                    ...opt,
                    ns: namespaces
                }) : `key '${key} (${this.language})' returned an object instead of string.`;
                if (returnDetails) {
                    resolved.res = r;
                    resolved.usedParams = this.getUsedParamsDetails(opt);
                    return resolved;
                }
                return r;
            }
            if (keySeparator) {
                const resTypeIsArray = Array.isArray(resForObjHndl);
                const copy = resTypeIsArray ? [] : {};
                const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
                for(const m in resForObjHndl){
                    if (Object.prototype.hasOwnProperty.call(resForObjHndl, m)) {
                        const deepKey = `${newKeyToUse}${keySeparator}${m}`;
                        if (hasDefaultValue && !res) {
                            copy[m] = this.translate(deepKey, {
                                ...opt,
                                defaultValue: shouldHandleAsObject(defaultValue) ? defaultValue[m] : undefined,
                                ...{
                                    joinArrays: false,
                                    ns: namespaces
                                }
                            });
                        } else {
                            copy[m] = this.translate(deepKey, {
                                ...opt,
                                ...{
                                    joinArrays: false,
                                    ns: namespaces
                                }
                            });
                        }
                        if (copy[m] === deepKey) copy[m] = resForObjHndl[m];
                    }
                }
                res = copy;
            }
        } else if (handleAsObjectInI18nFormat && isString(joinArrays) && Array.isArray(res)) {
            res = res.join(joinArrays);
            if (res) res = this.extendTranslation(res, keys, opt, lastKey);
        } else {
            let usedDefault = false;
            let usedKey = false;
            if (!this.isValidLookup(res) && hasDefaultValue) {
                usedDefault = true;
                res = defaultValue;
            }
            if (!this.isValidLookup(res)) {
                usedKey = true;
                res = key;
            }
            const missingKeyNoValueFallbackToKey = opt.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
            const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? undefined : res;
            const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
            if (usedKey || usedDefault || updateMissing) {
                this.logger.log(updateMissing ? 'updateKey' : 'missingKey', lng, namespace, key, updateMissing ? defaultValue : res);
                if (keySeparator) {
                    const fk = this.resolve(key, {
                        ...opt,
                        keySeparator: false
                    });
                    if (fk && fk.res) this.logger.warn('Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.');
                }
                let lngs = [];
                const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, opt.lng || this.language);
                if (this.options.saveMissingTo === 'fallback' && fallbackLngs && fallbackLngs[0]) {
                    for(let i = 0; i < fallbackLngs.length; i++){
                        lngs.push(fallbackLngs[i]);
                    }
                } else if (this.options.saveMissingTo === 'all') {
                    lngs = this.languageUtils.toResolveHierarchy(opt.lng || this.language);
                } else {
                    lngs.push(opt.lng || this.language);
                }
                const send = (l, k, specificDefaultValue)=>{
                    const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
                    if (this.options.missingKeyHandler) {
                        this.options.missingKeyHandler(l, namespace, k, defaultForMissing, updateMissing, opt);
                    } else if (this.backendConnector?.saveMissing) {
                        this.backendConnector.saveMissing(l, namespace, k, defaultForMissing, updateMissing, opt);
                    }
                    this.emit('missingKey', l, namespace, k, res);
                };
                if (this.options.saveMissing) {
                    if (this.options.saveMissingPlurals && needsPluralHandling) {
                        lngs.forEach((language)=>{
                            const suffixes = this.pluralResolver.getSuffixes(language, opt);
                            if (needsZeroSuffixLookup && opt[`defaultValue${this.options.pluralSeparator}zero`] && suffixes.indexOf(`${this.options.pluralSeparator}zero`) < 0) {
                                suffixes.push(`${this.options.pluralSeparator}zero`);
                            }
                            suffixes.forEach((suffix)=>{
                                send([
                                    language
                                ], key + suffix, opt[`defaultValue${suffix}`] || defaultValue);
                            });
                        });
                    } else {
                        send(lngs, key, defaultValue);
                    }
                }
            }
            res = this.extendTranslation(res, keys, opt, resolved, lastKey);
            if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = `${namespace}:${key}`;
            if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
                res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}:${key}` : key, usedDefault ? res : undefined);
            }
        }
        if (returnDetails) {
            resolved.res = res;
            resolved.usedParams = this.getUsedParamsDetails(opt);
            return resolved;
        }
        return res;
    }
    extendTranslation(res, key, opt, resolved, lastKey) {
        var _this = this;
        if (this.i18nFormat?.parse) {
            res = this.i18nFormat.parse(res, {
                ...this.options.interpolation.defaultVariables,
                ...opt
            }, opt.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {
                resolved
            });
        } else if (!opt.skipInterpolation) {
            if (opt.interpolation) this.interpolator.init({
                ...opt,
                ...{
                    interpolation: {
                        ...this.options.interpolation,
                        ...opt.interpolation
                    }
                }
            });
            const skipOnVariables = isString(res) && (opt?.interpolation?.skipOnVariables !== undefined ? opt.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
            let nestBef;
            if (skipOnVariables) {
                const nb = res.match(this.interpolator.nestingRegexp);
                nestBef = nb && nb.length;
            }
            let data = opt.replace && !isString(opt.replace) ? opt.replace : opt;
            if (this.options.interpolation.defaultVariables) data = {
                ...this.options.interpolation.defaultVariables,
                ...data
            };
            res = this.interpolator.interpolate(res, data, opt.lng || this.language || resolved.usedLng, opt);
            if (skipOnVariables) {
                const na = res.match(this.interpolator.nestingRegexp);
                const nestAft = na && na.length;
                if (nestBef < nestAft) opt.nest = false;
            }
            if (!opt.lng && resolved && resolved.res) opt.lng = this.language || resolved.usedLng;
            if (opt.nest !== false) res = this.interpolator.nest(res, function() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                if (lastKey?.[0] === args[0] && !opt.context) {
                    _this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);
                    return null;
                }
                return _this.translate(...args, key);
            }, opt);
            if (opt.interpolation) this.interpolator.reset();
        }
        const postProcess = opt.postProcess || this.options.postProcess;
        const postProcessorNames = isString(postProcess) ? [
            postProcess
        ] : postProcess;
        if (res != null && postProcessorNames?.length && opt.applyPostProcessor !== false) {
            res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {
                i18nResolved: {
                    ...resolved,
                    usedParams: this.getUsedParamsDetails(opt)
                },
                ...opt
            } : opt, this);
        }
        return res;
    }
    resolve(keys) {
        let opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        let found;
        let usedKey;
        let exactUsedKey;
        let usedLng;
        let usedNS;
        if (isString(keys)) keys = [
            keys
        ];
        keys.forEach((k)=>{
            if (this.isValidLookup(found)) return;
            const extracted = this.extractFromKey(k, opt);
            const key = extracted.key;
            usedKey = key;
            let namespaces = extracted.namespaces;
            if (this.options.fallbackNS) namespaces = namespaces.concat(this.options.fallbackNS);
            const needsPluralHandling = opt.count !== undefined && !isString(opt.count);
            const needsZeroSuffixLookup = needsPluralHandling && !opt.ordinal && opt.count === 0;
            const needsContextHandling = opt.context !== undefined && (isString(opt.context) || typeof opt.context === 'number') && opt.context !== '';
            const codes = opt.lngs ? opt.lngs : this.languageUtils.toResolveHierarchy(opt.lng || this.language, opt.fallbackLng);
            namespaces.forEach((ns)=>{
                if (this.isValidLookup(found)) return;
                usedNS = ns;
                if (!checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils?.hasLoadedNamespace && !this.utils?.hasLoadedNamespace(usedNS)) {
                    checkedLoadedFor[`${codes[0]}-${ns}`] = true;
                    this.logger.warn(`key "${usedKey}" for languages "${codes.join(', ')}" won't get resolved as namespace "${usedNS}" was not yet loaded`, 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');
                }
                codes.forEach((code)=>{
                    if (this.isValidLookup(found)) return;
                    usedLng = code;
                    const finalKeys = [
                        key
                    ];
                    if (this.i18nFormat?.addLookupKeys) {
                        this.i18nFormat.addLookupKeys(finalKeys, key, code, ns, opt);
                    } else {
                        let pluralSuffix;
                        if (needsPluralHandling) pluralSuffix = this.pluralResolver.getSuffix(code, opt.count, opt);
                        const zeroSuffix = `${this.options.pluralSeparator}zero`;
                        const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
                        if (needsPluralHandling) {
                            finalKeys.push(key + pluralSuffix);
                            if (opt.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                                finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
                            }
                            if (needsZeroSuffixLookup) {
                                finalKeys.push(key + zeroSuffix);
                            }
                        }
                        if (needsContextHandling) {
                            const contextKey = `${key}${this.options.contextSeparator}${opt.context}`;
                            finalKeys.push(contextKey);
                            if (needsPluralHandling) {
                                finalKeys.push(contextKey + pluralSuffix);
                                if (opt.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                                    finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
                                }
                                if (needsZeroSuffixLookup) {
                                    finalKeys.push(contextKey + zeroSuffix);
                                }
                            }
                        }
                    }
                    let possibleKey;
                    while(possibleKey = finalKeys.pop()){
                        if (!this.isValidLookup(found)) {
                            exactUsedKey = possibleKey;
                            found = this.getResource(code, ns, possibleKey, opt);
                        }
                    }
                });
            });
        });
        return {
            res: found,
            usedKey,
            exactUsedKey,
            usedLng,
            usedNS
        };
    }
    isValidLookup(res) {
        return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === '');
    }
    getResource(code, ns, key) {
        let options1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        if (this.i18nFormat?.getResource) return this.i18nFormat.getResource(code, ns, key, options1);
        return this.resourceStore.getResource(code, ns, key, options1);
    }
    getUsedParamsDetails() {
        let options1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const optionsKeys = [
            'defaultValue',
            'ordinal',
            'context',
            'replace',
            'lng',
            'lngs',
            'fallbackLng',
            'ns',
            'keySeparator',
            'nsSeparator',
            'returnObjects',
            'returnDetails',
            'joinArrays',
            'postProcess',
            'interpolation'
        ];
        const useOptionsReplaceForData = options1.replace && !isString(options1.replace);
        let data = useOptionsReplaceForData ? options1.replace : options1;
        if (useOptionsReplaceForData && typeof options1.count !== 'undefined') {
            data.count = options1.count;
        }
        if (this.options.interpolation.defaultVariables) {
            data = {
                ...this.options.interpolation.defaultVariables,
                ...data
            };
        }
        if (!useOptionsReplaceForData) {
            data = {
                ...data
            };
            for (const key of optionsKeys){
                delete data[key];
            }
        }
        return data;
    }
    static hasDefaultValue(options1) {
        const prefix = 'defaultValue';
        for(const option in options1){
            if (Object.prototype.hasOwnProperty.call(options1, option) && prefix === option.substring(0, prefix.length) && undefined !== options1[option]) {
                return true;
            }
        }
        return false;
    }
}
class LanguageUtil {
    constructor(options1){
        this.options = options1;
        this.supportedLngs = this.options.supportedLngs || false;
        this.logger = baseLogger.create('languageUtils');
    }
    getScriptPartFromCode(code) {
        code = getCleanedCode(code);
        if (!code || code.indexOf('-') < 0) return null;
        const p = code.split('-');
        if (p.length === 2) return null;
        p.pop();
        if (p[p.length - 1].toLowerCase() === 'x') return null;
        return this.formatLanguageCode(p.join('-'));
    }
    getLanguagePartFromCode(code) {
        code = getCleanedCode(code);
        if (!code || code.indexOf('-') < 0) return code;
        const p = code.split('-');
        return this.formatLanguageCode(p[0]);
    }
    formatLanguageCode(code) {
        if (isString(code) && code.indexOf('-') > -1) {
            let formattedCode;
            try {
                formattedCode = Intl.getCanonicalLocales(code)[0];
            } catch (e) {}
            if (formattedCode && this.options.lowerCaseLng) {
                formattedCode = formattedCode.toLowerCase();
            }
            if (formattedCode) return formattedCode;
            if (this.options.lowerCaseLng) {
                return code.toLowerCase();
            }
            return code;
        }
        return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
    }
    isSupportedCode(code) {
        if (this.options.load === 'languageOnly' || this.options.nonExplicitSupportedLngs) {
            code = this.getLanguagePartFromCode(code);
        }
        return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
    }
    getBestMatchFromCodes(codes) {
        if (!codes) return null;
        let found;
        codes.forEach((code)=>{
            if (found) return;
            const cleanedLng = this.formatLanguageCode(code);
            if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng)) found = cleanedLng;
        });
        if (!found && this.options.supportedLngs) {
            codes.forEach((code)=>{
                if (found) return;
                const lngScOnly = this.getScriptPartFromCode(code);
                if (this.isSupportedCode(lngScOnly)) return found = lngScOnly;
                const lngOnly = this.getLanguagePartFromCode(code);
                if (this.isSupportedCode(lngOnly)) return found = lngOnly;
                found = this.options.supportedLngs.find((supportedLng)=>{
                    if (supportedLng === lngOnly) return supportedLng;
                    if (supportedLng.indexOf('-') < 0 && lngOnly.indexOf('-') < 0) return;
                    if (supportedLng.indexOf('-') > 0 && lngOnly.indexOf('-') < 0 && supportedLng.substring(0, supportedLng.indexOf('-')) === lngOnly) return supportedLng;
                    if (supportedLng.indexOf(lngOnly) === 0 && lngOnly.length > 1) return supportedLng;
                });
            });
        }
        if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];
        return found;
    }
    getFallbackCodes(fallbacks, code) {
        if (!fallbacks) return [];
        if (typeof fallbacks === 'function') fallbacks = fallbacks(code);
        if (isString(fallbacks)) fallbacks = [
            fallbacks
        ];
        if (Array.isArray(fallbacks)) return fallbacks;
        if (!code) return fallbacks.default || [];
        let found = fallbacks[code];
        if (!found) found = fallbacks[this.getScriptPartFromCode(code)];
        if (!found) found = fallbacks[this.formatLanguageCode(code)];
        if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];
        if (!found) found = fallbacks.default;
        return found || [];
    }
    toResolveHierarchy(code, fallbackCode) {
        const fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
        const codes = [];
        const addCode = (c)=>{
            if (!c) return;
            if (this.isSupportedCode(c)) {
                codes.push(c);
            } else {
                this.logger.warn(`rejecting language code not found in supportedLngs: ${c}`);
            }
        };
        if (isString(code) && (code.indexOf('-') > -1 || code.indexOf('_') > -1)) {
            if (this.options.load !== 'languageOnly') addCode(this.formatLanguageCode(code));
            if (this.options.load !== 'languageOnly' && this.options.load !== 'currentOnly') addCode(this.getScriptPartFromCode(code));
            if (this.options.load !== 'currentOnly') addCode(this.getLanguagePartFromCode(code));
        } else if (isString(code)) {
            addCode(this.formatLanguageCode(code));
        }
        fallbackCodes.forEach((fc)=>{
            if (codes.indexOf(fc) < 0) addCode(this.formatLanguageCode(fc));
        });
        return codes;
    }
}
const suffixesOrder = {
    zero: 0,
    one: 1,
    two: 2,
    few: 3,
    many: 4,
    other: 5
};
const dummyRule = {
    select: (count)=>count === 1 ? 'one' : 'other',
    resolvedOptions: ()=>({
            pluralCategories: [
                'one',
                'other'
            ]
        })
};
class PluralResolver {
    constructor(languageUtils){
        let options1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        this.languageUtils = languageUtils;
        this.options = options1;
        this.logger = baseLogger.create('pluralResolver');
        this.pluralRulesCache = {};
    }
    addRule(lng, obj) {
        this.rules[lng] = obj;
    }
    clearCache() {
        this.pluralRulesCache = {};
    }
    getRule(code) {
        let options1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        const cleanedCode = getCleanedCode(code === 'dev' ? 'en' : code);
        const type = options1.ordinal ? 'ordinal' : 'cardinal';
        const cacheKey = JSON.stringify({
            cleanedCode,
            type
        });
        if (cacheKey in this.pluralRulesCache) {
            return this.pluralRulesCache[cacheKey];
        }
        let rule;
        try {
            rule = new Intl.PluralRules(cleanedCode, {
                type
            });
        } catch (err) {
            if (!Intl) {
                this.logger.error('No Intl support, please use an Intl polyfill!');
                return dummyRule;
            }
            if (!code.match(/-|_/)) return dummyRule;
            const lngPart = this.languageUtils.getLanguagePartFromCode(code);
            rule = this.getRule(lngPart, options1);
        }
        this.pluralRulesCache[cacheKey] = rule;
        return rule;
    }
    needsPlural(code) {
        let options1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        let rule = this.getRule(code, options1);
        if (!rule) rule = this.getRule('dev', options1);
        return rule?.resolvedOptions().pluralCategories.length > 1;
    }
    getPluralFormsOfKey(code, key) {
        let options1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        return this.getSuffixes(code, options1).map((suffix)=>`${key}${suffix}`);
    }
    getSuffixes(code) {
        let options1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        let rule = this.getRule(code, options1);
        if (!rule) rule = this.getRule('dev', options1);
        if (!rule) return [];
        return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2)=>suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map((pluralCategory)=>`${this.options.prepend}${options1.ordinal ? `ordinal${this.options.prepend}` : ''}${pluralCategory}`);
    }
    getSuffix(code, count) {
        let options1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        const rule = this.getRule(code, options1);
        if (rule) {
            return `${this.options.prepend}${options1.ordinal ? `ordinal${this.options.prepend}` : ''}${rule.select(count)}`;
        }
        this.logger.warn(`no plural rule found for: ${code}`);
        return this.getSuffix('dev', count, options1);
    }
}
const deepFindWithDefaults = function(data, defaultData, key) {
    let keySeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '.';
    let ignoreJSONStructure = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
    let path = getPathWithDefaults(data, defaultData, key);
    if (!path && ignoreJSONStructure && isString(key)) {
        path = deepFind(data, key, keySeparator);
        if (path === undefined) path = deepFind(defaultData, key, keySeparator);
    }
    return path;
};
const regexSafe = (val)=>val.replace(/\$/g, '$$$$');
class Interpolator {
    constructor(){
        let options1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        this.logger = baseLogger.create('interpolator');
        this.options = options1;
        this.format = options1?.interpolation?.format || ((value)=>value);
        this.init(options1);
    }
    init() {
        let options1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if (!options1.interpolation) options1.interpolation = {
            escapeValue: true
        };
        const { escape: escape$1, escapeValue, useRawValueToEscape, prefix, prefixEscaped, suffix, suffixEscaped, formatSeparator, unescapeSuffix, unescapePrefix, nestingPrefix, nestingPrefixEscaped, nestingSuffix, nestingSuffixEscaped, nestingOptionsSeparator, maxReplaces, alwaysFormat } = options1.interpolation;
        this.escape = escape$1 !== undefined ? escape$1 : escape;
        this.escapeValue = escapeValue !== undefined ? escapeValue : true;
        this.useRawValueToEscape = useRawValueToEscape !== undefined ? useRawValueToEscape : false;
        this.prefix = prefix ? regexEscape(prefix) : prefixEscaped || '{{';
        this.suffix = suffix ? regexEscape(suffix) : suffixEscaped || '}}';
        this.formatSeparator = formatSeparator || ',';
        this.unescapePrefix = unescapeSuffix ? '' : unescapePrefix || '-';
        this.unescapeSuffix = this.unescapePrefix ? '' : unescapeSuffix || '';
        this.nestingPrefix = nestingPrefix ? regexEscape(nestingPrefix) : nestingPrefixEscaped || regexEscape('$t(');
        this.nestingSuffix = nestingSuffix ? regexEscape(nestingSuffix) : nestingSuffixEscaped || regexEscape(')');
        this.nestingOptionsSeparator = nestingOptionsSeparator || ',';
        this.maxReplaces = maxReplaces || 1000;
        this.alwaysFormat = alwaysFormat !== undefined ? alwaysFormat : false;
        this.resetRegExp();
    }
    reset() {
        if (this.options) this.init(this.options);
    }
    resetRegExp() {
        const getOrResetRegExp = (existingRegExp, pattern)=>{
            if (existingRegExp?.source === pattern) {
                existingRegExp.lastIndex = 0;
                return existingRegExp;
            }
            return new RegExp(pattern, 'g');
        };
        this.regexp = getOrResetRegExp(this.regexp, `${this.prefix}(.+?)${this.suffix}`);
        this.regexpUnescape = getOrResetRegExp(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`);
        this.nestingRegexp = getOrResetRegExp(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`);
    }
    interpolate(str, data, lng, options1) {
        let match;
        let value;
        let replaces;
        const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
        const handleFormat = (key)=>{
            if (key.indexOf(this.formatSeparator) < 0) {
                const path = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);
                return this.alwaysFormat ? this.format(path, undefined, lng, {
                    ...options1,
                    ...data,
                    interpolationkey: key
                }) : path;
            }
            const p = key.split(this.formatSeparator);
            const k = p.shift().trim();
            const f = p.join(this.formatSeparator).trim();
            return this.format(deepFindWithDefaults(data, defaultData, k, this.options.keySeparator, this.options.ignoreJSONStructure), f, lng, {
                ...options1,
                ...data,
                interpolationkey: k
            });
        };
        this.resetRegExp();
        const missingInterpolationHandler = options1?.missingInterpolationHandler || this.options.missingInterpolationHandler;
        const skipOnVariables = options1?.interpolation?.skipOnVariables !== undefined ? options1.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
        const todos = [
            {
                regex: this.regexpUnescape,
                safeValue: (val)=>regexSafe(val)
            },
            {
                regex: this.regexp,
                safeValue: (val)=>this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)
            }
        ];
        todos.forEach((todo)=>{
            replaces = 0;
            while(match = todo.regex.exec(str)){
                const matchedVar = match[1].trim();
                value = handleFormat(matchedVar);
                if (value === undefined) {
                    if (typeof missingInterpolationHandler === 'function') {
                        const temp = missingInterpolationHandler(str, match, options1);
                        value = isString(temp) ? temp : '';
                    } else if (options1 && Object.prototype.hasOwnProperty.call(options1, matchedVar)) {
                        value = '';
                    } else if (skipOnVariables) {
                        value = match[0];
                        continue;
                    } else {
                        this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`);
                        value = '';
                    }
                } else if (!isString(value) && !this.useRawValueToEscape) {
                    value = makeString(value);
                }
                const safeValue = todo.safeValue(value);
                str = str.replace(match[0], safeValue);
                if (skipOnVariables) {
                    todo.regex.lastIndex += value.length;
                    todo.regex.lastIndex -= match[0].length;
                } else {
                    todo.regex.lastIndex = 0;
                }
                replaces++;
                if (replaces >= this.maxReplaces) {
                    break;
                }
            }
        });
        return str;
    }
    nest(str, fc) {
        let options1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        let match;
        let value;
        let clonedOptions;
        const handleHasOptions = (key, inheritedOptions)=>{
            const sep = this.nestingOptionsSeparator;
            if (key.indexOf(sep) < 0) return key;
            const c = key.split(new RegExp(`${sep}[ ]*{`));
            let optionsString = `{${c[1]}`;
            key = c[0];
            optionsString = this.interpolate(optionsString, clonedOptions);
            const matchedSingleQuotes = optionsString.match(/'/g);
            const matchedDoubleQuotes = optionsString.match(/"/g);
            if ((matchedSingleQuotes?.length ?? 0) % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
                optionsString = optionsString.replace(/'/g, '"');
            }
            try {
                clonedOptions = JSON.parse(optionsString);
                if (inheritedOptions) clonedOptions = {
                    ...inheritedOptions,
                    ...clonedOptions
                };
            } catch (e) {
                this.logger.warn(`failed parsing options string in nesting for key ${key}`, e);
                return `${key}${sep}${optionsString}`;
            }
            if (clonedOptions.defaultValue && clonedOptions.defaultValue.indexOf(this.prefix) > -1) delete clonedOptions.defaultValue;
            return key;
        };
        while(match = this.nestingRegexp.exec(str)){
            let formatters = [];
            clonedOptions = {
                ...options1
            };
            clonedOptions = clonedOptions.replace && !isString(clonedOptions.replace) ? clonedOptions.replace : clonedOptions;
            clonedOptions.applyPostProcessor = false;
            delete clonedOptions.defaultValue;
            let doReduce = false;
            if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {
                const r = match[1].split(this.formatSeparator).map((elem)=>elem.trim());
                match[1] = r.shift();
                formatters = r;
                doReduce = true;
            }
            value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
            if (value && match[0] === str && !isString(value)) return value;
            if (!isString(value)) value = makeString(value);
            if (!value) {
                this.logger.warn(`missed to resolve ${match[1]} for nesting ${str}`);
                value = '';
            }
            if (doReduce) {
                value = formatters.reduce((v, f)=>this.format(v, f, options1.lng, {
                        ...options1,
                        interpolationkey: match[1].trim()
                    }), value.trim());
            }
            str = str.replace(match[0], value);
            this.regexp.lastIndex = 0;
        }
        return str;
    }
}
const parseFormatStr = (formatStr)=>{
    let formatName = formatStr.toLowerCase().trim();
    const formatOptions = {};
    if (formatStr.indexOf('(') > -1) {
        const p = formatStr.split('(');
        formatName = p[0].toLowerCase().trim();
        const optStr = p[1].substring(0, p[1].length - 1);
        if (formatName === 'currency' && optStr.indexOf(':') < 0) {
            if (!formatOptions.currency) formatOptions.currency = optStr.trim();
        } else if (formatName === 'relativetime' && optStr.indexOf(':') < 0) {
            if (!formatOptions.range) formatOptions.range = optStr.trim();
        } else {
            const opts = optStr.split(';');
            opts.forEach((opt)=>{
                if (opt) {
                    const [key, ...rest] = opt.split(':');
                    const val = rest.join(':').trim().replace(/^'+|'+$/g, '');
                    const trimmedKey = key.trim();
                    if (!formatOptions[trimmedKey]) formatOptions[trimmedKey] = val;
                    if (val === 'false') formatOptions[trimmedKey] = false;
                    if (val === 'true') formatOptions[trimmedKey] = true;
                    if (!isNaN(val)) formatOptions[trimmedKey] = parseInt(val, 10);
                }
            });
        }
    }
    return {
        formatName,
        formatOptions
    };
};
const createCachedFormatter = (fn)=>{
    const cache = {};
    return (val, lng, options1)=>{
        let optForCache = options1;
        if (options1 && options1.interpolationkey && options1.formatParams && options1.formatParams[options1.interpolationkey] && options1[options1.interpolationkey]) {
            optForCache = {
                ...optForCache,
                [options1.interpolationkey]: undefined
            };
        }
        const key = lng + JSON.stringify(optForCache);
        let formatter = cache[key];
        if (!formatter) {
            formatter = fn(getCleanedCode(lng), options1);
            cache[key] = formatter;
        }
        return formatter(val);
    };
};
class Formatter {
    constructor(){
        let options1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        this.logger = baseLogger.create('formatter');
        this.options = options1;
        this.formats = {
            number: createCachedFormatter((lng, opt)=>{
                const formatter = new Intl.NumberFormat(lng, {
                    ...opt
                });
                return (val)=>formatter.format(val);
            }),
            currency: createCachedFormatter((lng, opt)=>{
                const formatter = new Intl.NumberFormat(lng, {
                    ...opt,
                    style: 'currency'
                });
                return (val)=>formatter.format(val);
            }),
            datetime: createCachedFormatter((lng, opt)=>{
                const formatter = new Intl.DateTimeFormat(lng, {
                    ...opt
                });
                return (val)=>formatter.format(val);
            }),
            relativetime: createCachedFormatter((lng, opt)=>{
                const formatter = new Intl.RelativeTimeFormat(lng, {
                    ...opt
                });
                return (val)=>formatter.format(val, opt.range || 'day');
            }),
            list: createCachedFormatter((lng, opt)=>{
                const formatter = new Intl.ListFormat(lng, {
                    ...opt
                });
                return (val)=>formatter.format(val);
            })
        };
        this.init(options1);
    }
    init(services) {
        let options1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
            interpolation: {}
        };
        this.formatSeparator = options1.interpolation.formatSeparator || ',';
    }
    add(name, fc) {
        this.formats[name.toLowerCase().trim()] = fc;
    }
    addCached(name, fc) {
        this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);
    }
    format(value, format, lng) {
        let options1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        const formats = format.split(this.formatSeparator);
        if (formats.length > 1 && formats[0].indexOf('(') > 1 && formats[0].indexOf(')') < 0 && formats.find((f)=>f.indexOf(')') > -1)) {
            const lastIndex = formats.findIndex((f)=>f.indexOf(')') > -1);
            formats[0] = [
                formats[0],
                ...formats.splice(1, lastIndex)
            ].join(this.formatSeparator);
        }
        const result = formats.reduce((mem, f)=>{
            const { formatName, formatOptions } = parseFormatStr(f);
            if (this.formats[formatName]) {
                let formatted = mem;
                try {
                    const valOptions = options1?.formatParams?.[options1.interpolationkey] || {};
                    const l = valOptions.locale || valOptions.lng || options1.locale || options1.lng || lng;
                    formatted = this.formats[formatName](mem, l, {
                        ...formatOptions,
                        ...options1,
                        ...valOptions
                    });
                } catch (error) {
                    this.logger.warn(error);
                }
                return formatted;
            } else {
                this.logger.warn(`there was no format function for ${formatName}`);
            }
            return mem;
        }, value);
        return result;
    }
}
const removePending = (q, name)=>{
    if (q.pending[name] !== undefined) {
        delete q.pending[name];
        q.pendingCount--;
    }
};
class Connector extends EventEmitter {
    constructor(backend, store, services){
        let options1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        super();
        this.backend = backend;
        this.store = store;
        this.services = services;
        this.languageUtils = services.languageUtils;
        this.options = options1;
        this.logger = baseLogger.create('backendConnector');
        this.waitingReads = [];
        this.maxParallelReads = options1.maxParallelReads || 10;
        this.readingCalls = 0;
        this.maxRetries = options1.maxRetries >= 0 ? options1.maxRetries : 5;
        this.retryTimeout = options1.retryTimeout >= 1 ? options1.retryTimeout : 350;
        this.state = {};
        this.queue = [];
        this.backend?.init?.(services, options1.backend, options1);
    }
    queueLoad(languages, namespaces, options1, callback) {
        const toLoad = {};
        const pending = {};
        const toLoadLanguages = {};
        const toLoadNamespaces = {};
        languages.forEach((lng)=>{
            let hasAllNamespaces = true;
            namespaces.forEach((ns)=>{
                const name = `${lng}|${ns}`;
                if (!options1.reload && this.store.hasResourceBundle(lng, ns)) {
                    this.state[name] = 2;
                } else if (this.state[name] < 0) ;
                else if (this.state[name] === 1) {
                    if (pending[name] === undefined) pending[name] = true;
                } else {
                    this.state[name] = 1;
                    hasAllNamespaces = false;
                    if (pending[name] === undefined) pending[name] = true;
                    if (toLoad[name] === undefined) toLoad[name] = true;
                    if (toLoadNamespaces[ns] === undefined) toLoadNamespaces[ns] = true;
                }
            });
            if (!hasAllNamespaces) toLoadLanguages[lng] = true;
        });
        if (Object.keys(toLoad).length || Object.keys(pending).length) {
            this.queue.push({
                pending,
                pendingCount: Object.keys(pending).length,
                loaded: {},
                errors: [],
                callback
            });
        }
        return {
            toLoad: Object.keys(toLoad),
            pending: Object.keys(pending),
            toLoadLanguages: Object.keys(toLoadLanguages),
            toLoadNamespaces: Object.keys(toLoadNamespaces)
        };
    }
    loaded(name, err, data) {
        const s = name.split('|');
        const lng = s[0];
        const ns = s[1];
        if (err) this.emit('failedLoading', lng, ns, err);
        if (!err && data) {
            this.store.addResourceBundle(lng, ns, data, undefined, undefined, {
                skipCopy: true
            });
        }
        this.state[name] = err ? -1 : 2;
        if (err && data) this.state[name] = 0;
        const loaded = {};
        this.queue.forEach((q)=>{
            pushPath(q.loaded, [
                lng
            ], ns);
            removePending(q, name);
            if (err) q.errors.push(err);
            if (q.pendingCount === 0 && !q.done) {
                Object.keys(q.loaded).forEach((l)=>{
                    if (!loaded[l]) loaded[l] = {};
                    const loadedKeys = q.loaded[l];
                    if (loadedKeys.length) {
                        loadedKeys.forEach((n)=>{
                            if (loaded[l][n] === undefined) loaded[l][n] = true;
                        });
                    }
                });
                q.done = true;
                if (q.errors.length) {
                    q.callback(q.errors);
                } else {
                    q.callback();
                }
            }
        });
        this.emit('loaded', loaded);
        this.queue = this.queue.filter((q)=>!q.done);
    }
    read(lng, ns, fcName) {
        let tried = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        let wait = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.retryTimeout;
        let callback = arguments.length > 5 ? arguments[5] : undefined;
        if (!lng.length) return callback(null, {});
        if (this.readingCalls >= this.maxParallelReads) {
            this.waitingReads.push({
                lng,
                ns,
                fcName,
                tried,
                wait,
                callback
            });
            return;
        }
        this.readingCalls++;
        const resolver = (err, data)=>{
            this.readingCalls--;
            if (this.waitingReads.length > 0) {
                const next = this.waitingReads.shift();
                this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
            }
            if (err && data && tried < this.maxRetries) {
                setTimeout(()=>{
                    this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);
                }, wait);
                return;
            }
            callback(err, data);
        };
        const fc = this.backend[fcName].bind(this.backend);
        if (fc.length === 2) {
            try {
                const r = fc(lng, ns);
                if (r && typeof r.then === 'function') {
                    r.then((data)=>resolver(null, data)).catch(resolver);
                } else {
                    resolver(null, r);
                }
            } catch (err) {
                resolver(err);
            }
            return;
        }
        return fc(lng, ns, resolver);
    }
    prepareLoading(languages, namespaces) {
        let options1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        let callback = arguments.length > 3 ? arguments[3] : undefined;
        if (!this.backend) {
            this.logger.warn('No backend was added via i18next.use. Will not load resources.');
            return callback && callback();
        }
        if (isString(languages)) languages = this.languageUtils.toResolveHierarchy(languages);
        if (isString(namespaces)) namespaces = [
            namespaces
        ];
        const toLoad = this.queueLoad(languages, namespaces, options1, callback);
        if (!toLoad.toLoad.length) {
            if (!toLoad.pending.length) callback();
            return null;
        }
        toLoad.toLoad.forEach((name)=>{
            this.loadOne(name);
        });
    }
    load(languages, namespaces, callback) {
        this.prepareLoading(languages, namespaces, {}, callback);
    }
    reload(languages, namespaces, callback) {
        this.prepareLoading(languages, namespaces, {
            reload: true
        }, callback);
    }
    loadOne(name) {
        let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
        const s = name.split('|');
        const lng = s[0];
        const ns = s[1];
        this.read(lng, ns, 'read', undefined, undefined, (err, data)=>{
            if (err) this.logger.warn(`${prefix}loading namespace ${ns} for language ${lng} failed`, err);
            if (!err && data) this.logger.log(`${prefix}loaded namespace ${ns} for language ${lng}`, data);
            this.loaded(name, err, data);
        });
    }
    saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
        let options1 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};
        let clb = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : ()=>{};
        if (this.services?.utils?.hasLoadedNamespace && !this.services?.utils?.hasLoadedNamespace(namespace)) {
            this.logger.warn(`did not save key "${key}" as the namespace "${namespace}" was not yet loaded`, 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');
            return;
        }
        if (key === undefined || key === null || key === '') return;
        if (this.backend?.create) {
            const opts = {
                ...options1,
                isUpdate
            };
            const fc = this.backend.create.bind(this.backend);
            if (fc.length < 6) {
                try {
                    let r;
                    if (fc.length === 5) {
                        r = fc(languages, namespace, key, fallbackValue, opts);
                    } else {
                        r = fc(languages, namespace, key, fallbackValue);
                    }
                    if (r && typeof r.then === 'function') {
                        r.then((data)=>clb(null, data)).catch(clb);
                    } else {
                        clb(null, r);
                    }
                } catch (err) {
                    clb(err);
                }
            } else {
                fc(languages, namespace, key, fallbackValue, clb, opts);
            }
        }
        if (!languages || !languages[0]) return;
        this.store.addResource(languages[0], namespace, key, fallbackValue);
    }
}
const get = ()=>({
        debug: false,
        initAsync: true,
        ns: [
            'translation'
        ],
        defaultNS: [
            'translation'
        ],
        fallbackLng: [
            'dev'
        ],
        fallbackNS: false,
        supportedLngs: false,
        nonExplicitSupportedLngs: false,
        load: 'all',
        preload: false,
        simplifyPluralSuffix: true,
        keySeparator: '.',
        nsSeparator: ':',
        pluralSeparator: '_',
        contextSeparator: '_',
        partialBundledLanguages: false,
        saveMissing: false,
        updateMissing: false,
        saveMissingTo: 'fallback',
        saveMissingPlurals: true,
        missingKeyHandler: false,
        missingInterpolationHandler: false,
        postProcess: false,
        postProcessPassResolved: false,
        returnNull: false,
        returnEmptyString: true,
        returnObjects: false,
        joinArrays: false,
        returnedObjectHandler: false,
        parseMissingKeyHandler: false,
        appendNamespaceToMissingKey: false,
        appendNamespaceToCIMode: false,
        overloadTranslationOptionHandler: (args)=>{
            let ret = {};
            if (typeof args[1] === 'object') ret = args[1];
            if (isString(args[1])) ret.defaultValue = args[1];
            if (isString(args[2])) ret.tDescription = args[2];
            if (typeof args[2] === 'object' || typeof args[3] === 'object') {
                const options1 = args[3] || args[2];
                Object.keys(options1).forEach((key)=>{
                    ret[key] = options1[key];
                });
            }
            return ret;
        },
        interpolation: {
            escapeValue: true,
            format: (value)=>value,
            prefix: '{{',
            suffix: '}}',
            formatSeparator: ',',
            unescapePrefix: '-',
            nestingPrefix: '$t(',
            nestingSuffix: ')',
            nestingOptionsSeparator: ',',
            maxReplaces: 1000,
            skipOnVariables: true
        }
    });
const transformOptions = (options1)=>{
    if (isString(options1.ns)) options1.ns = [
        options1.ns
    ];
    if (isString(options1.fallbackLng)) options1.fallbackLng = [
        options1.fallbackLng
    ];
    if (isString(options1.fallbackNS)) options1.fallbackNS = [
        options1.fallbackNS
    ];
    if (options1.supportedLngs?.indexOf?.('cimode') < 0) {
        options1.supportedLngs = options1.supportedLngs.concat([
            'cimode'
        ]);
    }
    if (typeof options1.initImmediate === 'boolean') options1.initAsync = options1.initImmediate;
    return options1;
};
const noop = ()=>{};
const bindMemberFunctions = (inst)=>{
    const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
    mems.forEach((mem)=>{
        if (typeof inst[mem] === 'function') {
            inst[mem] = inst[mem].bind(inst);
        }
    });
};
class I18n extends EventEmitter {
    constructor(){
        let options1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        let callback = arguments.length > 1 ? arguments[1] : undefined;
        super();
        this.options = transformOptions(options1);
        this.services = {};
        this.logger = baseLogger;
        this.modules = {
            external: []
        };
        bindMemberFunctions(this);
        if (callback && !this.isInitialized && !options1.isClone) {
            if (!this.options.initAsync) {
                this.init(options1, callback);
                return this;
            }
            setTimeout(()=>{
                this.init(options1, callback);
            }, 0);
        }
    }
    init() {
        var _this = this;
        let options1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        let callback = arguments.length > 1 ? arguments[1] : undefined;
        this.isInitializing = true;
        if (typeof options1 === 'function') {
            callback = options1;
            options1 = {};
        }
        if (options1.defaultNS == null && options1.ns) {
            if (isString(options1.ns)) {
                options1.defaultNS = options1.ns;
            } else if (options1.ns.indexOf('translation') < 0) {
                options1.defaultNS = options1.ns[0];
            }
        }
        const defOpts = get();
        this.options = {
            ...defOpts,
            ...this.options,
            ...transformOptions(options1)
        };
        this.options.interpolation = {
            ...defOpts.interpolation,
            ...this.options.interpolation
        };
        if (options1.keySeparator !== undefined) {
            this.options.userDefinedKeySeparator = options1.keySeparator;
        }
        if (options1.nsSeparator !== undefined) {
            this.options.userDefinedNsSeparator = options1.nsSeparator;
        }
        const createClassOnDemand = (ClassOrObject)=>{
            if (!ClassOrObject) return null;
            if (typeof ClassOrObject === 'function') return new ClassOrObject();
            return ClassOrObject;
        };
        if (!this.options.isClone) {
            if (this.modules.logger) {
                baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
            } else {
                baseLogger.init(null, this.options);
            }
            let formatter;
            if (this.modules.formatter) {
                formatter = this.modules.formatter;
            } else {
                formatter = Formatter;
            }
            const lu = new LanguageUtil(this.options);
            this.store = new ResourceStore(this.options.resources, this.options);
            const s = this.services;
            s.logger = baseLogger;
            s.resourceStore = this.store;
            s.languageUtils = lu;
            s.pluralResolver = new PluralResolver(lu, {
                prepend: this.options.pluralSeparator,
                simplifyPluralSuffix: this.options.simplifyPluralSuffix
            });
            if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
                s.formatter = createClassOnDemand(formatter);
                s.formatter.init(s, this.options);
                this.options.interpolation.format = s.formatter.format.bind(s.formatter);
            }
            s.interpolator = new Interpolator(this.options);
            s.utils = {
                hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
            };
            s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
            s.backendConnector.on('*', function(event) {
                for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                    args[_key - 1] = arguments[_key];
                }
                _this.emit(event, ...args);
            });
            if (this.modules.languageDetector) {
                s.languageDetector = createClassOnDemand(this.modules.languageDetector);
                if (s.languageDetector.init) s.languageDetector.init(s, this.options.detection, this.options);
            }
            if (this.modules.i18nFormat) {
                s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
                if (s.i18nFormat.init) s.i18nFormat.init(this);
            }
            this.translator = new Translator(this.services, this.options);
            this.translator.on('*', function(event) {
                for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){
                    args[_key2 - 1] = arguments[_key2];
                }
                _this.emit(event, ...args);
            });
            this.modules.external.forEach((m)=>{
                if (m.init) m.init(this);
            });
        }
        this.format = this.options.interpolation.format;
        if (!callback) callback = noop;
        if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
            const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
            if (codes.length > 0 && codes[0] !== 'dev') this.options.lng = codes[0];
        }
        if (!this.services.languageDetector && !this.options.lng) {
            this.logger.warn('init: no languageDetector is used and no lng is defined');
        }
        const storeApi = [
            'getResource',
            'hasResourceBundle',
            'getResourceBundle',
            'getDataByLanguage'
        ];
        storeApi.forEach((fcName)=>{
            this[fcName] = function() {
                return _this.store[fcName](...arguments);
            };
        });
        const storeApiChained = [
            'addResource',
            'addResources',
            'addResourceBundle',
            'removeResourceBundle'
        ];
        storeApiChained.forEach((fcName)=>{
            this[fcName] = function() {
                _this.store[fcName](...arguments);
                return _this;
            };
        });
        const deferred = defer();
        const load = ()=>{
            const finish = (err, t)=>{
                this.isInitializing = false;
                if (this.isInitialized && !this.initializedStoreOnce) this.logger.warn('init: i18next is already initialized. You should call init just once!');
                this.isInitialized = true;
                if (!this.options.isClone) this.logger.log('initialized', this.options);
                this.emit('initialized', this.options);
                deferred.resolve(t);
                callback(err, t);
            };
            if (this.languages && !this.isInitialized) return finish(null, this.t.bind(this));
            this.changeLanguage(this.options.lng, finish);
        };
        if (this.options.resources || !this.options.initAsync) {
            load();
        } else {
            setTimeout(load, 0);
        }
        return deferred;
    }
    loadResources(language) {
        let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
        let usedCallback = callback;
        const usedLng = isString(language) ? language : this.language;
        if (typeof language === 'function') usedCallback = language;
        if (!this.options.resources || this.options.partialBundledLanguages) {
            if (usedLng?.toLowerCase() === 'cimode' && (!this.options.preload || this.options.preload.length === 0)) return usedCallback();
            const toLoad = [];
            const append = (lng)=>{
                if (!lng) return;
                if (lng === 'cimode') return;
                const lngs = this.services.languageUtils.toResolveHierarchy(lng);
                lngs.forEach((l)=>{
                    if (l === 'cimode') return;
                    if (toLoad.indexOf(l) < 0) toLoad.push(l);
                });
            };
            if (!usedLng) {
                const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
                fallbacks.forEach((l)=>append(l));
            } else {
                append(usedLng);
            }
            this.options.preload?.forEach?.((l)=>append(l));
            this.services.backendConnector.load(toLoad, this.options.ns, (e)=>{
                if (!e && !this.resolvedLanguage && this.language) this.setResolvedLanguage(this.language);
                usedCallback(e);
            });
        } else {
            usedCallback(null);
        }
    }
    reloadResources(lngs, ns, callback) {
        const deferred = defer();
        if (typeof lngs === 'function') {
            callback = lngs;
            lngs = undefined;
        }
        if (typeof ns === 'function') {
            callback = ns;
            ns = undefined;
        }
        if (!lngs) lngs = this.languages;
        if (!ns) ns = this.options.ns;
        if (!callback) callback = noop;
        this.services.backendConnector.reload(lngs, ns, (err)=>{
            deferred.resolve();
            callback(err);
        });
        return deferred;
    }
    use(module) {
        if (!module) throw new Error('You are passing an undefined module! Please check the object you are passing to i18next.use()');
        if (!module.type) throw new Error('You are passing a wrong module! Please check the object you are passing to i18next.use()');
        if (module.type === 'backend') {
            this.modules.backend = module;
        }
        if (module.type === 'logger' || module.log && module.warn && module.error) {
            this.modules.logger = module;
        }
        if (module.type === 'languageDetector') {
            this.modules.languageDetector = module;
        }
        if (module.type === 'i18nFormat') {
            this.modules.i18nFormat = module;
        }
        if (module.type === 'postProcessor') {
            postProcessor.addPostProcessor(module);
        }
        if (module.type === 'formatter') {
            this.modules.formatter = module;
        }
        if (module.type === '3rdParty') {
            this.modules.external.push(module);
        }
        return this;
    }
    setResolvedLanguage(l) {
        if (!l || !this.languages) return;
        if ([
            'cimode',
            'dev'
        ].indexOf(l) > -1) return;
        for(let li = 0; li < this.languages.length; li++){
            const lngInLngs = this.languages[li];
            if ([
                'cimode',
                'dev'
            ].indexOf(lngInLngs) > -1) continue;
            if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
                this.resolvedLanguage = lngInLngs;
                break;
            }
        }
    }
    changeLanguage(lng, callback) {
        var _this2 = this;
        this.isLanguageChangingTo = lng;
        const deferred = defer();
        this.emit('languageChanging', lng);
        const setLngProps = (l)=>{
            this.language = l;
            this.languages = this.services.languageUtils.toResolveHierarchy(l);
            this.resolvedLanguage = undefined;
            this.setResolvedLanguage(l);
        };
        const done = (err, l)=>{
            if (l) {
                if (this.isLanguageChangingTo === lng) {
                    setLngProps(l);
                    this.translator.changeLanguage(l);
                    this.isLanguageChangingTo = undefined;
                    this.emit('languageChanged', l);
                    this.logger.log('languageChanged', l);
                }
            } else {
                this.isLanguageChangingTo = undefined;
            }
            deferred.resolve(function() {
                return _this2.t(...arguments);
            });
            if (callback) callback(err, function() {
                return _this2.t(...arguments);
            });
        };
        const setLng = (lngs)=>{
            if (!lng && !lngs && this.services.languageDetector) lngs = [];
            const l = this.services.languageUtils.getBestMatchFromCodes(isString(lngs) ? [
                lngs
            ] : lngs);
            if (l) {
                if (!this.language) {
                    setLngProps(l);
                }
                if (!this.translator.language) this.translator.changeLanguage(l);
                this.services.languageDetector?.cacheUserLanguage?.(l);
            }
            this.loadResources(l, (err)=>{
                done(err, l);
            });
        };
        if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
            setLng(this.services.languageDetector.detect());
        } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
            if (this.services.languageDetector.detect.length === 0) {
                this.services.languageDetector.detect().then(setLng);
            } else {
                this.services.languageDetector.detect(setLng);
            }
        } else {
            setLng(lng);
        }
        return deferred;
    }
    getFixedT(lng, ns, keyPrefix) {
        var _this3 = this;
        const fixedT = function(key, opts) {
            let o;
            if (typeof opts !== 'object') {
                for(var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++){
                    rest[_key3 - 2] = arguments[_key3];
                }
                o = _this3.options.overloadTranslationOptionHandler([
                    key,
                    opts
                ].concat(rest));
            } else {
                o = {
                    ...opts
                };
            }
            o.lng = o.lng || fixedT.lng;
            o.lngs = o.lngs || fixedT.lngs;
            o.ns = o.ns || fixedT.ns;
            if (o.keyPrefix !== '') o.keyPrefix = o.keyPrefix || keyPrefix || fixedT.keyPrefix;
            const keySeparator = _this3.options.keySeparator || '.';
            let resultKey;
            if (o.keyPrefix && Array.isArray(key)) {
                resultKey = key.map((k)=>`${o.keyPrefix}${keySeparator}${k}`);
            } else {
                resultKey = o.keyPrefix ? `${o.keyPrefix}${keySeparator}${key}` : key;
            }
            return _this3.t(resultKey, o);
        };
        if (isString(lng)) {
            fixedT.lng = lng;
        } else {
            fixedT.lngs = lng;
        }
        fixedT.ns = ns;
        fixedT.keyPrefix = keyPrefix;
        return fixedT;
    }
    t() {
        for(var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++){
            args[_key4] = arguments[_key4];
        }
        return this.translator?.translate(...args);
    }
    exists() {
        for(var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++){
            args[_key5] = arguments[_key5];
        }
        return this.translator?.exists(...args);
    }
    setDefaultNamespace(ns) {
        this.options.defaultNS = ns;
    }
    hasLoadedNamespace(ns) {
        let options1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        if (!this.isInitialized) {
            this.logger.warn('hasLoadedNamespace: i18next was not initialized', this.languages);
            return false;
        }
        if (!this.languages || !this.languages.length) {
            this.logger.warn('hasLoadedNamespace: i18n.languages were undefined or empty', this.languages);
            return false;
        }
        const lng = options1.lng || this.resolvedLanguage || this.languages[0];
        const fallbackLng = this.options ? this.options.fallbackLng : false;
        const lastLng = this.languages[this.languages.length - 1];
        if (lng.toLowerCase() === 'cimode') return true;
        const loadNotPending = (l, n)=>{
            const loadState = this.services.backendConnector.state[`${l}|${n}`];
            return loadState === -1 || loadState === 0 || loadState === 2;
        };
        if (options1.precheck) {
            const preResult = options1.precheck(this, loadNotPending);
            if (preResult !== undefined) return preResult;
        }
        if (this.hasResourceBundle(lng, ns)) return true;
        if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;
        if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
        return false;
    }
    loadNamespaces(ns, callback) {
        const deferred = defer();
        if (!this.options.ns) {
            if (callback) callback();
            return Promise.resolve();
        }
        if (isString(ns)) ns = [
            ns
        ];
        ns.forEach((n)=>{
            if (this.options.ns.indexOf(n) < 0) this.options.ns.push(n);
        });
        this.loadResources((err)=>{
            deferred.resolve();
            if (callback) callback(err);
        });
        return deferred;
    }
    loadLanguages(lngs, callback) {
        const deferred = defer();
        if (isString(lngs)) lngs = [
            lngs
        ];
        const preloaded = this.options.preload || [];
        const newLngs = lngs.filter((lng)=>preloaded.indexOf(lng) < 0 && this.services.languageUtils.isSupportedCode(lng));
        if (!newLngs.length) {
            if (callback) callback();
            return Promise.resolve();
        }
        this.options.preload = preloaded.concat(newLngs);
        this.loadResources((err)=>{
            deferred.resolve();
            if (callback) callback(err);
        });
        return deferred;
    }
    dir(lng) {
        if (!lng) lng = this.resolvedLanguage || (this.languages?.length > 0 ? this.languages[0] : this.language);
        if (!lng) return 'rtl';
        const rtlLngs = [
            'ar',
            'shu',
            'sqr',
            'ssh',
            'xaa',
            'yhd',
            'yud',
            'aao',
            'abh',
            'abv',
            'acm',
            'acq',
            'acw',
            'acx',
            'acy',
            'adf',
            'ads',
            'aeb',
            'aec',
            'afb',
            'ajp',
            'apc',
            'apd',
            'arb',
            'arq',
            'ars',
            'ary',
            'arz',
            'auz',
            'avl',
            'ayh',
            'ayl',
            'ayn',
            'ayp',
            'bbz',
            'pga',
            'he',
            'iw',
            'ps',
            'pbt',
            'pbu',
            'pst',
            'prp',
            'prd',
            'ug',
            'ur',
            'ydd',
            'yds',
            'yih',
            'ji',
            'yi',
            'hbo',
            'men',
            'xmn',
            'fa',
            'jpr',
            'peo',
            'pes',
            'prs',
            'dv',
            'sam',
            'ckb'
        ];
        const languageUtils = this.services?.languageUtils || new LanguageUtil(get());
        return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf('-arab') > 1 ? 'rtl' : 'ltr';
    }
    static createInstance() {
        let options1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        let callback = arguments.length > 1 ? arguments[1] : undefined;
        return new I18n(options1, callback);
    }
    cloneInstance() {
        let options1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
        const forkResourceStore = options1.forkResourceStore;
        if (forkResourceStore) delete options1.forkResourceStore;
        const mergedOptions = {
            ...this.options,
            ...options1,
            ...{
                isClone: true
            }
        };
        const clone = new I18n(mergedOptions);
        if (options1.debug !== undefined || options1.prefix !== undefined) {
            clone.logger = clone.logger.clone(options1);
        }
        const membersToCopy = [
            'store',
            'services',
            'language'
        ];
        membersToCopy.forEach((m)=>{
            clone[m] = this[m];
        });
        clone.services = {
            ...this.services
        };
        clone.services.utils = {
            hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
        };
        if (forkResourceStore) {
            const clonedData = Object.keys(this.store.data).reduce((prev, l)=>{
                prev[l] = {
                    ...this.store.data[l]
                };
                return Object.keys(prev[l]).reduce((acc, n)=>{
                    acc[n] = {
                        ...prev[l][n]
                    };
                    return acc;
                }, {});
            }, {});
            clone.store = new ResourceStore(clonedData, mergedOptions);
            clone.services.resourceStore = clone.store;
        }
        clone.translator = new Translator(clone.services, mergedOptions);
        clone.translator.on('*', function(event) {
            for(var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++){
                args[_key6 - 1] = arguments[_key6];
            }
            clone.emit(event, ...args);
        });
        clone.init(mergedOptions, callback);
        clone.translator.options = mergedOptions;
        clone.translator.backendConnector.services.utils = {
            hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
        };
        return clone;
    }
    toJSON() {
        return {
            options: this.options,
            store: this.store,
            language: this.language,
            languages: this.languages,
            resolvedLanguage: this.resolvedLanguage
        };
    }
}
const instance = I18n.createInstance();
instance.createInstance = I18n.createInstance;
const createInstance = instance.createInstance;
const dir = instance.dir;
const init = instance.init;
const loadResources = instance.loadResources;
const reloadResources = instance.reloadResources;
const use = instance.use;
const changeLanguage = instance.changeLanguage;
const getFixedT = instance.getFixedT;
const t = instance.t;
const exists = instance.exists;
const setDefaultNamespace = instance.setDefaultNamespace;
const hasLoadedNamespace = instance.hasLoadedNamespace;
const loadNamespaces = instance.loadNamespaces;
const loadLanguages = instance.loadLanguages;
;
}}),
"[project]/node_modules/@chatui/core/dist/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
!function(e, t) {
    ("TURBOPACK compile-time truthy", 1) ? t(exports, __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"), __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react-dom/index.js [app-client] (ecmascript)")) : ("TURBOPACK unreachable", undefined);
}(this, function(e, t, n) {
    "use strict";
    function r(e) {
        return e && "object" == typeof e && "default" in e ? e : {
            default: e
        };
    }
    e.version = "3.0.0";
    var o = r(t), a = r(n);
    function i(e) {
        var t, n, r = "";
        if ("string" == typeof e || "number" == typeof e) r += e;
        else if ("object" == typeof e) if (Array.isArray(e)) for(t = 0; t < e.length; t++)e[t] && (n = i(e[t])) && (r && (r += " "), r += n);
        else for(t in e)e[t] && (r && (r += " "), r += t);
        return r;
    }
    function c() {
        for(var e, t, n = 0, r = ""; n < arguments.length;)(e = arguments[n++]) && (t = i(e)) && (r && (r += " "), r += t);
        return r;
    }
    function u(e) {
        return u = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e;
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        }, u(e);
    }
    function l(e, t) {
        return l = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e;
        }, l(e, t);
    }
    function s(e, t, n) {
        return s = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), !0;
            } catch (e) {
                return !1;
            }
        }() ? Reflect.construct : function(e, t, n) {
            var r = [
                null
            ];
            r.push.apply(r, t);
            var o = new (Function.bind.apply(e, r));
            return n && l(o, n.prototype), o;
        }, s.apply(null, arguments);
    }
    function f(e) {
        return function(e) {
            if (Array.isArray(e)) return d(e);
        }(e) || function(e) {
            if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e);
        }(e) || function(e, t) {
            if (!e) return;
            if ("string" == typeof e) return d(e, t);
            var n = Object.prototype.toString.call(e).slice(8, -1);
            "Object" === n && e.constructor && (n = e.constructor.name);
            if ("Map" === n || "Set" === n) return Array.from(e);
            if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return d(e, t);
        }(e) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
    }
    function d(e, t) {
        (null == t || t > e.length) && (t = e.length);
        for(var n = 0, r = new Array(t); n < t; n++)r[n] = e[n];
        return r;
    }
    !function() {
        if ("object" == typeof window) if ("IntersectionObserver" in window && "IntersectionObserverEntry" in window && "intersectionRatio" in window.IntersectionObserverEntry.prototype) "isIntersecting" in window.IntersectionObserverEntry.prototype || Object.defineProperty(window.IntersectionObserverEntry.prototype, "isIntersecting", {
            get: function() {
                return this.intersectionRatio > 0;
            }
        });
        else {
            var e = function() {
                for(var e = window.document, t = o(e); t;)t = o(e = t.ownerDocument);
                return e;
            }(), t = [], n = null, r = null;
            i.prototype.THROTTLE_TIMEOUT = 100, i.prototype.POLL_INTERVAL = null, i.prototype.USE_MUTATION_OBSERVER = !0, i._setupCrossOriginUpdater = function() {
                return n || (n = function(e, n) {
                    r = e && n ? f(e, n) : {
                        top: 0,
                        bottom: 0,
                        left: 0,
                        right: 0,
                        width: 0,
                        height: 0
                    }, t.forEach(function(e) {
                        e._checkForIntersections();
                    });
                }), n;
            }, i._resetCrossOriginUpdater = function() {
                n = null, r = null;
            }, i.prototype.observe = function(e) {
                if (!this._observationTargets.some(function(t) {
                    return t.element == e;
                })) {
                    if (!e || 1 != e.nodeType) throw new Error("target must be an Element");
                    this._registerInstance(), this._observationTargets.push({
                        element: e,
                        entry: null
                    }), this._monitorIntersections(e.ownerDocument), this._checkForIntersections();
                }
            }, i.prototype.unobserve = function(e) {
                this._observationTargets = this._observationTargets.filter(function(t) {
                    return t.element != e;
                }), this._unmonitorIntersections(e.ownerDocument), 0 == this._observationTargets.length && this._unregisterInstance();
            }, i.prototype.disconnect = function() {
                this._observationTargets = [], this._unmonitorAllIntersections(), this._unregisterInstance();
            }, i.prototype.takeRecords = function() {
                var e = this._queuedEntries.slice();
                return this._queuedEntries = [], e;
            }, i.prototype._initThresholds = function(e) {
                var t = e || [
                    0
                ];
                return Array.isArray(t) || (t = [
                    t
                ]), t.sort().filter(function(e, t, n) {
                    if ("number" != typeof e || isNaN(e) || e < 0 || e > 1) throw new Error("threshold must be a number between 0 and 1 inclusively");
                    return e !== n[t - 1];
                });
            }, i.prototype._parseRootMargin = function(e) {
                var t = (e || "0px").split(/\s+/).map(function(e) {
                    var t = /^(-?\d*\.?\d+)(px|%)$/.exec(e);
                    if (!t) throw new Error("rootMargin must be specified in pixels or percent");
                    return {
                        value: parseFloat(t[1]),
                        unit: t[2]
                    };
                });
                return t[1] = t[1] || t[0], t[2] = t[2] || t[0], t[3] = t[3] || t[1], t;
            }, i.prototype._monitorIntersections = function(t) {
                var n = t.defaultView;
                if (n && -1 == this._monitoringDocuments.indexOf(t)) {
                    var r = this._checkForIntersections, a = null, i = null;
                    this.POLL_INTERVAL ? a = n.setInterval(r, this.POLL_INTERVAL) : (c(n, "resize", r, !0), c(t, "scroll", r, !0), this.USE_MUTATION_OBSERVER && "MutationObserver" in n && (i = new n.MutationObserver(r)).observe(t, {
                        attributes: !0,
                        childList: !0,
                        characterData: !0,
                        subtree: !0
                    })), this._monitoringDocuments.push(t), this._monitoringUnsubscribes.push(function() {
                        var e = t.defaultView;
                        e && (a && e.clearInterval(a), u(e, "resize", r, !0)), u(t, "scroll", r, !0), i && i.disconnect();
                    });
                    var l = this.root && (this.root.ownerDocument || this.root) || e;
                    if (t != l) {
                        var s = o(t);
                        s && this._monitorIntersections(s.ownerDocument);
                    }
                }
            }, i.prototype._unmonitorIntersections = function(t) {
                var n = this._monitoringDocuments.indexOf(t);
                if (-1 != n) {
                    var r = this.root && (this.root.ownerDocument || this.root) || e, a = this._observationTargets.some(function(e) {
                        var n = e.element.ownerDocument;
                        if (n == t) return !0;
                        for(; n && n != r;){
                            var a = o(n);
                            if ((n = a && a.ownerDocument) == t) return !0;
                        }
                        return !1;
                    });
                    if (!a) {
                        var i = this._monitoringUnsubscribes[n];
                        if (this._monitoringDocuments.splice(n, 1), this._monitoringUnsubscribes.splice(n, 1), i(), t != r) {
                            var c = o(t);
                            c && this._unmonitorIntersections(c.ownerDocument);
                        }
                    }
                }
            }, i.prototype._unmonitorAllIntersections = function() {
                var e = this._monitoringUnsubscribes.slice(0);
                this._monitoringDocuments.length = 0, this._monitoringUnsubscribes.length = 0;
                for(var t = 0; t < e.length; t++)e[t]();
            }, i.prototype._checkForIntersections = function() {
                if (this.root || !n || r) {
                    var e = this._rootIsInDom(), t = e ? this._getRootRect() : {
                        top: 0,
                        bottom: 0,
                        left: 0,
                        right: 0,
                        width: 0,
                        height: 0
                    };
                    this._observationTargets.forEach(function(r) {
                        var o = r.element, i = l(o), c = this._rootContainsTarget(o), u = r.entry, s = e && c && this._computeTargetAndRootIntersection(o, i, t), f = null;
                        this._rootContainsTarget(o) ? n && !this.root || (f = t) : f = {
                            top: 0,
                            bottom: 0,
                            left: 0,
                            right: 0,
                            width: 0,
                            height: 0
                        };
                        var d = r.entry = new a({
                            time: window.performance && performance.now && performance.now(),
                            target: o,
                            boundingClientRect: i,
                            rootBounds: f,
                            intersectionRect: s
                        });
                        u ? e && c ? this._hasCrossedThreshold(u, d) && this._queuedEntries.push(d) : u && u.isIntersecting && this._queuedEntries.push(d) : this._queuedEntries.push(d);
                    }, this), this._queuedEntries.length && this._callback(this.takeRecords(), this);
                }
            }, i.prototype._computeTargetAndRootIntersection = function(t, o, a) {
                if ("none" != window.getComputedStyle(t).display) {
                    for(var i, c, u, s, d, p, v, h, g = o, y = m(t), b = !1; !b && y;){
                        var E = null, w = 1 == y.nodeType ? window.getComputedStyle(y) : {};
                        if ("none" == w.display) return null;
                        if (y == this.root || 9 == y.nodeType) if (b = !0, y == this.root || y == e) n && !this.root ? !r || 0 == r.width && 0 == r.height ? (y = null, E = null, g = null) : E = r : E = a;
                        else {
                            var N = m(y), S = N && l(N), T = N && this._computeTargetAndRootIntersection(N, S, a);
                            S && T ? (y = N, E = f(S, T)) : (y = null, g = null);
                        }
                        else {
                            var C = y.ownerDocument;
                            y != C.body && y != C.documentElement && "visible" != w.overflow && (E = l(y));
                        }
                        if (E && (i = E, c = g, u = void 0, s = void 0, d = void 0, p = void 0, v = void 0, h = void 0, u = Math.max(i.top, c.top), s = Math.min(i.bottom, c.bottom), d = Math.max(i.left, c.left), p = Math.min(i.right, c.right), h = s - u, g = (v = p - d) >= 0 && h >= 0 && {
                            top: u,
                            bottom: s,
                            left: d,
                            right: p,
                            width: v,
                            height: h
                        } || null), !g) break;
                        y = y && m(y);
                    }
                    return g;
                }
            }, i.prototype._getRootRect = function() {
                var t;
                if (this.root && !p(this.root)) t = l(this.root);
                else {
                    var n = p(this.root) ? this.root : e, r = n.documentElement, o = n.body;
                    t = {
                        top: 0,
                        left: 0,
                        right: r.clientWidth || o.clientWidth,
                        width: r.clientWidth || o.clientWidth,
                        bottom: r.clientHeight || o.clientHeight,
                        height: r.clientHeight || o.clientHeight
                    };
                }
                return this._expandRectByRootMargin(t);
            }, i.prototype._expandRectByRootMargin = function(e) {
                var t = this._rootMarginValues.map(function(t, n) {
                    return "px" == t.unit ? t.value : t.value * (n % 2 ? e.width : e.height) / 100;
                }), n = {
                    top: e.top - t[0],
                    right: e.right + t[1],
                    bottom: e.bottom + t[2],
                    left: e.left - t[3]
                };
                return n.width = n.right - n.left, n.height = n.bottom - n.top, n;
            }, i.prototype._hasCrossedThreshold = function(e, t) {
                var n = e && e.isIntersecting ? e.intersectionRatio || 0 : -1, r = t.isIntersecting ? t.intersectionRatio || 0 : -1;
                if (n !== r) for(var o = 0; o < this.thresholds.length; o++){
                    var a = this.thresholds[o];
                    if (a == n || a == r || a < n != a < r) return !0;
                }
            }, i.prototype._rootIsInDom = function() {
                return !this.root || d(e, this.root);
            }, i.prototype._rootContainsTarget = function(t) {
                var n = this.root && (this.root.ownerDocument || this.root) || e;
                return d(n, t) && (!this.root || n == t.ownerDocument);
            }, i.prototype._registerInstance = function() {
                t.indexOf(this) < 0 && t.push(this);
            }, i.prototype._unregisterInstance = function() {
                var e = t.indexOf(this);
                -1 != e && t.splice(e, 1);
            }, window.IntersectionObserver = i, window.IntersectionObserverEntry = a;
        }
        function o(e) {
            try {
                return e.defaultView && e.defaultView.frameElement || null;
            } catch (e) {
                return null;
            }
        }
        function a(e) {
            this.time = e.time, this.target = e.target, this.rootBounds = s(e.rootBounds), this.boundingClientRect = s(e.boundingClientRect), this.intersectionRect = s(e.intersectionRect || {
                top: 0,
                bottom: 0,
                left: 0,
                right: 0,
                width: 0,
                height: 0
            }), this.isIntersecting = !!e.intersectionRect;
            var t = this.boundingClientRect, n = t.width * t.height, r = this.intersectionRect, o = r.width * r.height;
            this.intersectionRatio = n ? Number((o / n).toFixed(4)) : this.isIntersecting ? 1 : 0;
        }
        function i(e, t) {
            var n, r, o, a = t || {};
            if ("function" != typeof e) throw new Error("callback must be a function");
            if (a.root && 1 != a.root.nodeType && 9 != a.root.nodeType) throw new Error("root must be a Document or Element");
            this._checkForIntersections = (n = this._checkForIntersections.bind(this), r = this.THROTTLE_TIMEOUT, o = null, function() {
                o || (o = setTimeout(function() {
                    n(), o = null;
                }, r));
            }), this._callback = e, this._observationTargets = [], this._queuedEntries = [], this._rootMarginValues = this._parseRootMargin(a.rootMargin), this.thresholds = this._initThresholds(a.threshold), this.root = a.root || null, this.rootMargin = this._rootMarginValues.map(function(e) {
                return e.value + e.unit;
            }).join(" "), this._monitoringDocuments = [], this._monitoringUnsubscribes = [];
        }
        function c(e, t, n, r) {
            "function" == typeof e.addEventListener ? e.addEventListener(t, n, r || !1) : "function" == typeof e.attachEvent && e.attachEvent("on" + t, n);
        }
        function u(e, t, n, r) {
            "function" == typeof e.removeEventListener ? e.removeEventListener(t, n, r || !1) : "function" == typeof e.detachEvent && e.detachEvent("on" + t, n);
        }
        function l(e) {
            var t;
            try {
                t = e.getBoundingClientRect();
            } catch (e) {}
            return t ? (t.width && t.height || (t = {
                top: t.top,
                right: t.right,
                bottom: t.bottom,
                left: t.left,
                width: t.right - t.left,
                height: t.bottom - t.top
            }), t) : {
                top: 0,
                bottom: 0,
                left: 0,
                right: 0,
                width: 0,
                height: 0
            };
        }
        function s(e) {
            return !e || "x" in e ? e : {
                top: e.top,
                y: e.top,
                bottom: e.bottom,
                left: e.left,
                x: e.left,
                right: e.right,
                width: e.width,
                height: e.height
            };
        }
        function f(e, t) {
            var n = t.top - e.top, r = t.left - e.left;
            return {
                top: n,
                left: r,
                height: t.height,
                width: t.width,
                bottom: n + t.height,
                right: r + t.width
            };
        }
        function d(e, t) {
            for(var n = t; n;){
                if (n == e) return !0;
                n = m(n);
            }
            return !1;
        }
        function m(t) {
            var n = t.parentNode;
            return 9 == t.nodeType && t != e ? o(t) : (n && n.assignedSlot && (n = n.assignedSlot.parentNode), n && 11 == n.nodeType && n.host ? n.host : n);
        }
        function p(e) {
            return e && 9 === e.nodeType;
        }
    }();
    var m = Object.hasOwnProperty, p = Object.setPrototypeOf, v = Object.isFrozen, h = Object.getPrototypeOf, g = Object.getOwnPropertyDescriptor, y = Object.freeze, b = Object.seal, E = Object.create, w = "undefined" != typeof Reflect && Reflect, N = w.apply, S = w.construct;
    N || (N = function(e, t, n) {
        return e.apply(t, n);
    }), y || (y = function(e) {
        return e;
    }), b || (b = function(e) {
        return e;
    }), S || (S = function(e, t) {
        return s(e, f(t));
    });
    var T, C = P(Array.prototype.forEach), O = P(Array.prototype.pop), R = P(Array.prototype.push), x = P(String.prototype.toLowerCase), k = P(String.prototype.toString), A = P(String.prototype.match), I = P(String.prototype.replace), M = P(String.prototype.indexOf), _ = P(String.prototype.trim), L = P(RegExp.prototype.test), j = (T = TypeError, function() {
        for(var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n];
        return S(T, t);
    });
    function P(e) {
        return function(t) {
            for(var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++)r[o - 1] = arguments[o];
            return N(e, t, r);
        };
    }
    function D(e, t, n) {
        var r;
        n = null !== (r = n) && void 0 !== r ? r : x, p && p(e, null);
        for(var o = t.length; o--;){
            var a = t[o];
            if ("string" == typeof a) {
                var i = n(a);
                i !== a && (v(t) || (t[o] = i), a = i);
            }
            e[a] = !0;
        }
        return e;
    }
    function F(e) {
        var t, n = E(null);
        for(t in e)!0 === N(m, e, [
            t
        ]) && (n[t] = e[t]);
        return n;
    }
    function B(e, t) {
        for(; null !== e;){
            var n = g(e, t);
            if (n) {
                if (n.get) return P(n.get);
                if ("function" == typeof n.value) return P(n.value);
            }
            e = h(e);
        }
        return function(e) {
            return null;
        };
    }
    var H = y([
        "a",
        "abbr",
        "acronym",
        "address",
        "area",
        "article",
        "aside",
        "audio",
        "b",
        "bdi",
        "bdo",
        "big",
        "blink",
        "blockquote",
        "body",
        "br",
        "button",
        "canvas",
        "caption",
        "center",
        "cite",
        "code",
        "col",
        "colgroup",
        "content",
        "data",
        "datalist",
        "dd",
        "decorator",
        "del",
        "details",
        "dfn",
        "dialog",
        "dir",
        "div",
        "dl",
        "dt",
        "element",
        "em",
        "fieldset",
        "figcaption",
        "figure",
        "font",
        "footer",
        "form",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "head",
        "header",
        "hgroup",
        "hr",
        "html",
        "i",
        "img",
        "input",
        "ins",
        "kbd",
        "label",
        "legend",
        "li",
        "main",
        "map",
        "mark",
        "marquee",
        "menu",
        "menuitem",
        "meter",
        "nav",
        "nobr",
        "ol",
        "optgroup",
        "option",
        "output",
        "p",
        "picture",
        "pre",
        "progress",
        "q",
        "rp",
        "rt",
        "ruby",
        "s",
        "samp",
        "section",
        "select",
        "shadow",
        "small",
        "source",
        "spacer",
        "span",
        "strike",
        "strong",
        "style",
        "sub",
        "summary",
        "sup",
        "table",
        "tbody",
        "td",
        "template",
        "textarea",
        "tfoot",
        "th",
        "thead",
        "time",
        "tr",
        "track",
        "tt",
        "u",
        "ul",
        "var",
        "video",
        "wbr"
    ]), U = y([
        "svg",
        "a",
        "altglyph",
        "altglyphdef",
        "altglyphitem",
        "animatecolor",
        "animatemotion",
        "animatetransform",
        "circle",
        "clippath",
        "defs",
        "desc",
        "ellipse",
        "filter",
        "font",
        "g",
        "glyph",
        "glyphref",
        "hkern",
        "image",
        "line",
        "lineargradient",
        "marker",
        "mask",
        "metadata",
        "mpath",
        "path",
        "pattern",
        "polygon",
        "polyline",
        "radialgradient",
        "rect",
        "stop",
        "style",
        "switch",
        "symbol",
        "text",
        "textpath",
        "title",
        "tref",
        "tspan",
        "view",
        "vkern"
    ]), z = y([
        "feBlend",
        "feColorMatrix",
        "feComponentTransfer",
        "feComposite",
        "feConvolveMatrix",
        "feDiffuseLighting",
        "feDisplacementMap",
        "feDistantLight",
        "feFlood",
        "feFuncA",
        "feFuncB",
        "feFuncG",
        "feFuncR",
        "feGaussianBlur",
        "feImage",
        "feMerge",
        "feMergeNode",
        "feMorphology",
        "feOffset",
        "fePointLight",
        "feSpecularLighting",
        "feSpotLight",
        "feTile",
        "feTurbulence"
    ]), G = y([
        "animate",
        "color-profile",
        "cursor",
        "discard",
        "fedropshadow",
        "font-face",
        "font-face-format",
        "font-face-name",
        "font-face-src",
        "font-face-uri",
        "foreignobject",
        "hatch",
        "hatchpath",
        "mesh",
        "meshgradient",
        "meshpatch",
        "meshrow",
        "missing-glyph",
        "script",
        "set",
        "solidcolor",
        "unknown",
        "use"
    ]), W = y([
        "math",
        "menclose",
        "merror",
        "mfenced",
        "mfrac",
        "mglyph",
        "mi",
        "mlabeledtr",
        "mmultiscripts",
        "mn",
        "mo",
        "mover",
        "mpadded",
        "mphantom",
        "mroot",
        "mrow",
        "ms",
        "mspace",
        "msqrt",
        "mstyle",
        "msub",
        "msup",
        "msubsup",
        "mtable",
        "mtd",
        "mtext",
        "mtr",
        "munder",
        "munderover"
    ]), V = y([
        "maction",
        "maligngroup",
        "malignmark",
        "mlongdiv",
        "mscarries",
        "mscarry",
        "msgroup",
        "mstack",
        "msline",
        "msrow",
        "semantics",
        "annotation",
        "annotation-xml",
        "mprescripts",
        "none"
    ]), Y = y([
        "#text"
    ]), q = y([
        "accept",
        "action",
        "align",
        "alt",
        "autocapitalize",
        "autocomplete",
        "autopictureinpicture",
        "autoplay",
        "background",
        "bgcolor",
        "border",
        "capture",
        "cellpadding",
        "cellspacing",
        "checked",
        "cite",
        "class",
        "clear",
        "color",
        "cols",
        "colspan",
        "controls",
        "controlslist",
        "coords",
        "crossorigin",
        "datetime",
        "decoding",
        "default",
        "dir",
        "disabled",
        "disablepictureinpicture",
        "disableremoteplayback",
        "download",
        "draggable",
        "enctype",
        "enterkeyhint",
        "face",
        "for",
        "headers",
        "height",
        "hidden",
        "high",
        "href",
        "hreflang",
        "id",
        "inputmode",
        "integrity",
        "ismap",
        "kind",
        "label",
        "lang",
        "list",
        "loading",
        "loop",
        "low",
        "max",
        "maxlength",
        "media",
        "method",
        "min",
        "minlength",
        "multiple",
        "muted",
        "name",
        "nonce",
        "noshade",
        "novalidate",
        "nowrap",
        "open",
        "optimum",
        "pattern",
        "placeholder",
        "playsinline",
        "poster",
        "preload",
        "pubdate",
        "radiogroup",
        "readonly",
        "rel",
        "required",
        "rev",
        "reversed",
        "role",
        "rows",
        "rowspan",
        "spellcheck",
        "scope",
        "selected",
        "shape",
        "size",
        "sizes",
        "span",
        "srclang",
        "start",
        "src",
        "srcset",
        "step",
        "style",
        "summary",
        "tabindex",
        "title",
        "translate",
        "type",
        "usemap",
        "valign",
        "value",
        "width",
        "xmlns",
        "slot"
    ]), X = y([
        "accent-height",
        "accumulate",
        "additive",
        "alignment-baseline",
        "ascent",
        "attributename",
        "attributetype",
        "azimuth",
        "basefrequency",
        "baseline-shift",
        "begin",
        "bias",
        "by",
        "class",
        "clip",
        "clippathunits",
        "clip-path",
        "clip-rule",
        "color",
        "color-interpolation",
        "color-interpolation-filters",
        "color-profile",
        "color-rendering",
        "cx",
        "cy",
        "d",
        "dx",
        "dy",
        "diffuseconstant",
        "direction",
        "display",
        "divisor",
        "dur",
        "edgemode",
        "elevation",
        "end",
        "fill",
        "fill-opacity",
        "fill-rule",
        "filter",
        "filterunits",
        "flood-color",
        "flood-opacity",
        "font-family",
        "font-size",
        "font-size-adjust",
        "font-stretch",
        "font-style",
        "font-variant",
        "font-weight",
        "fx",
        "fy",
        "g1",
        "g2",
        "glyph-name",
        "glyphref",
        "gradientunits",
        "gradienttransform",
        "height",
        "href",
        "id",
        "image-rendering",
        "in",
        "in2",
        "k",
        "k1",
        "k2",
        "k3",
        "k4",
        "kerning",
        "keypoints",
        "keysplines",
        "keytimes",
        "lang",
        "lengthadjust",
        "letter-spacing",
        "kernelmatrix",
        "kernelunitlength",
        "lighting-color",
        "local",
        "marker-end",
        "marker-mid",
        "marker-start",
        "markerheight",
        "markerunits",
        "markerwidth",
        "maskcontentunits",
        "maskunits",
        "max",
        "mask",
        "media",
        "method",
        "mode",
        "min",
        "name",
        "numoctaves",
        "offset",
        "operator",
        "opacity",
        "order",
        "orient",
        "orientation",
        "origin",
        "overflow",
        "paint-order",
        "path",
        "pathlength",
        "patterncontentunits",
        "patterntransform",
        "patternunits",
        "points",
        "preservealpha",
        "preserveaspectratio",
        "primitiveunits",
        "r",
        "rx",
        "ry",
        "radius",
        "refx",
        "refy",
        "repeatcount",
        "repeatdur",
        "restart",
        "result",
        "rotate",
        "scale",
        "seed",
        "shape-rendering",
        "specularconstant",
        "specularexponent",
        "spreadmethod",
        "startoffset",
        "stddeviation",
        "stitchtiles",
        "stop-color",
        "stop-opacity",
        "stroke-dasharray",
        "stroke-dashoffset",
        "stroke-linecap",
        "stroke-linejoin",
        "stroke-miterlimit",
        "stroke-opacity",
        "stroke",
        "stroke-width",
        "style",
        "surfacescale",
        "systemlanguage",
        "tabindex",
        "targetx",
        "targety",
        "transform",
        "transform-origin",
        "text-anchor",
        "text-decoration",
        "text-rendering",
        "textlength",
        "type",
        "u1",
        "u2",
        "unicode",
        "values",
        "viewbox",
        "visibility",
        "version",
        "vert-adv-y",
        "vert-origin-x",
        "vert-origin-y",
        "width",
        "word-spacing",
        "wrap",
        "writing-mode",
        "xchannelselector",
        "ychannelselector",
        "x",
        "x1",
        "x2",
        "xmlns",
        "y",
        "y1",
        "y2",
        "z",
        "zoomandpan"
    ]), $ = y([
        "accent",
        "accentunder",
        "align",
        "bevelled",
        "close",
        "columnsalign",
        "columnlines",
        "columnspan",
        "denomalign",
        "depth",
        "dir",
        "display",
        "displaystyle",
        "encoding",
        "fence",
        "frame",
        "height",
        "href",
        "id",
        "largeop",
        "length",
        "linethickness",
        "lspace",
        "lquote",
        "mathbackground",
        "mathcolor",
        "mathsize",
        "mathvariant",
        "maxsize",
        "minsize",
        "movablelimits",
        "notation",
        "numalign",
        "open",
        "rowalign",
        "rowlines",
        "rowspacing",
        "rowspan",
        "rspace",
        "rquote",
        "scriptlevel",
        "scriptminsize",
        "scriptsizemultiplier",
        "selection",
        "separator",
        "separators",
        "stretchy",
        "subscriptshift",
        "supscriptshift",
        "symmetric",
        "voffset",
        "width",
        "xmlns"
    ]), K = y([
        "xlink:href",
        "xml:id",
        "xlink:title",
        "xml:space",
        "xmlns:xlink"
    ]), Q = b(/\{\{[\w\W]*|[\w\W]*\}\}/gm), J = b(/<%[\w\W]*|[\w\W]*%>/gm), Z = b(/\${[\w\W]*}/gm), ee = b(/^data-[\-\w.\u00B7-\uFFFF]+$/), te = b(/^aria-[\-\w]+$/), ne = b(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i), re = b(/^(?:\w+script|data):/i), oe = b(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g), ae = b(/^html$/i), ie = b(/^[a-z][.\w]*(-[.\w]+)+$/i), ce = function() {
        return "undefined" == typeof window ? null : window;
    };
    var ue = function e() {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ce(), n = function(t) {
            return e(t);
        };
        if (n.version = "2.5.8", n.removed = [], !t || !t.document || 9 !== t.document.nodeType) return n.isSupported = !1, n;
        var r = t.document, o = t.document, a = t.DocumentFragment, i = t.HTMLTemplateElement, c = t.Node, l = t.Element, s = t.NodeFilter, d = t.NamedNodeMap, m = void 0 === d ? t.NamedNodeMap || t.MozNamedAttrMap : d, p = t.HTMLFormElement, v = t.DOMParser, h = t.trustedTypes, g = l.prototype, b = B(g, "cloneNode"), E = B(g, "nextSibling"), w = B(g, "childNodes"), N = B(g, "parentNode");
        if ("function" == typeof i) {
            var S = o.createElement("template");
            S.content && S.content.ownerDocument && (o = S.content.ownerDocument);
        }
        var T = function(e, t) {
            if ("object" !== u(e) || "function" != typeof e.createPolicy) return null;
            var n = null, r = "data-tt-policy-suffix";
            t.currentScript && t.currentScript.hasAttribute(r) && (n = t.currentScript.getAttribute(r));
            var o = "dompurify" + (n ? "#" + n : "");
            try {
                return e.createPolicy(o, {
                    createHTML: function(e) {
                        return e;
                    },
                    createScriptURL: function(e) {
                        return e;
                    }
                });
            } catch (e) {
                return null;
            }
        }(h, r), P = T ? T.createHTML("") : "", ue = o, le = ue.implementation, se = ue.createNodeIterator, fe = ue.createDocumentFragment, de = ue.getElementsByTagName, me = r.importNode, pe = {};
        try {
            pe = F(o).documentMode ? o.documentMode : {};
        } catch (e) {}
        var ve = {};
        n.isSupported = "function" == typeof N && le && void 0 !== le.createHTMLDocument && 9 !== pe;
        var he, ge, ye = Q, be = J, Ee = Z, we = ee, Ne = te, Se = re, Te = oe, Ce = ie, Oe = ne, Re = null, xe = D({}, [].concat(f(H), f(U), f(z), f(W), f(Y))), ke = null, Ae = D({}, [].concat(f(q), f(X), f($), f(K))), Ie = Object.seal(Object.create(null, {
            tagNameCheck: {
                writable: !0,
                configurable: !1,
                enumerable: !0,
                value: null
            },
            attributeNameCheck: {
                writable: !0,
                configurable: !1,
                enumerable: !0,
                value: null
            },
            allowCustomizedBuiltInElements: {
                writable: !0,
                configurable: !1,
                enumerable: !0,
                value: !1
            }
        })), Me = null, _e = null, Le = !0, je = !0, Pe = !1, De = !0, Fe = !1, Be = !0, He = !1, Ue = !1, ze = !1, Ge = !1, We = !1, Ve = !1, Ye = !0, qe = !1, Xe = !0, $e = !1, Ke = {}, Qe = null, Je = D({}, [
            "annotation-xml",
            "audio",
            "colgroup",
            "desc",
            "foreignobject",
            "head",
            "iframe",
            "math",
            "mi",
            "mn",
            "mo",
            "ms",
            "mtext",
            "noembed",
            "noframes",
            "noscript",
            "plaintext",
            "script",
            "style",
            "svg",
            "template",
            "thead",
            "title",
            "video",
            "xmp"
        ]), Ze = null, et = D({}, [
            "audio",
            "video",
            "img",
            "source",
            "image",
            "track"
        ]), tt = null, nt = D({}, [
            "alt",
            "class",
            "for",
            "id",
            "label",
            "name",
            "pattern",
            "placeholder",
            "role",
            "summary",
            "title",
            "value",
            "style",
            "xmlns"
        ]), rt = "http://www.w3.org/1998/Math/MathML", ot = "http://www.w3.org/2000/svg", at = "http://www.w3.org/1999/xhtml", it = at, ct = !1, ut = null, lt = D({}, [
            rt,
            ot,
            at
        ], k), st = [
            "application/xhtml+xml",
            "text/html"
        ], ft = null, dt = o.createElement("form"), mt = function(e) {
            return e instanceof RegExp || e instanceof Function;
        }, pt = function(e) {
            ft && ft === e || (e && "object" === u(e) || (e = {}), e = F(e), he = he = -1 === st.indexOf(e.PARSER_MEDIA_TYPE) ? "text/html" : e.PARSER_MEDIA_TYPE, ge = "application/xhtml+xml" === he ? k : x, Re = "ALLOWED_TAGS" in e ? D({}, e.ALLOWED_TAGS, ge) : xe, ke = "ALLOWED_ATTR" in e ? D({}, e.ALLOWED_ATTR, ge) : Ae, ut = "ALLOWED_NAMESPACES" in e ? D({}, e.ALLOWED_NAMESPACES, k) : lt, tt = "ADD_URI_SAFE_ATTR" in e ? D(F(nt), e.ADD_URI_SAFE_ATTR, ge) : nt, Ze = "ADD_DATA_URI_TAGS" in e ? D(F(et), e.ADD_DATA_URI_TAGS, ge) : et, Qe = "FORBID_CONTENTS" in e ? D({}, e.FORBID_CONTENTS, ge) : Je, Me = "FORBID_TAGS" in e ? D({}, e.FORBID_TAGS, ge) : {}, _e = "FORBID_ATTR" in e ? D({}, e.FORBID_ATTR, ge) : {}, Ke = "USE_PROFILES" in e && e.USE_PROFILES, Le = !1 !== e.ALLOW_ARIA_ATTR, je = !1 !== e.ALLOW_DATA_ATTR, Pe = e.ALLOW_UNKNOWN_PROTOCOLS || !1, De = !1 !== e.ALLOW_SELF_CLOSE_IN_ATTR, Fe = e.SAFE_FOR_TEMPLATES || !1, Be = !1 !== e.SAFE_FOR_XML, He = e.WHOLE_DOCUMENT || !1, Ge = e.RETURN_DOM || !1, We = e.RETURN_DOM_FRAGMENT || !1, Ve = e.RETURN_TRUSTED_TYPE || !1, ze = e.FORCE_BODY || !1, Ye = !1 !== e.SANITIZE_DOM, qe = e.SANITIZE_NAMED_PROPS || !1, Xe = !1 !== e.KEEP_CONTENT, $e = e.IN_PLACE || !1, Oe = e.ALLOWED_URI_REGEXP || Oe, it = e.NAMESPACE || at, Ie = e.CUSTOM_ELEMENT_HANDLING || {}, e.CUSTOM_ELEMENT_HANDLING && mt(e.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (Ie.tagNameCheck = e.CUSTOM_ELEMENT_HANDLING.tagNameCheck), e.CUSTOM_ELEMENT_HANDLING && mt(e.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (Ie.attributeNameCheck = e.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), e.CUSTOM_ELEMENT_HANDLING && "boolean" == typeof e.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (Ie.allowCustomizedBuiltInElements = e.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), Fe && (je = !1), We && (Ge = !0), Ke && (Re = D({}, f(Y)), ke = [], !0 === Ke.html && (D(Re, H), D(ke, q)), !0 === Ke.svg && (D(Re, U), D(ke, X), D(ke, K)), !0 === Ke.svgFilters && (D(Re, z), D(ke, X), D(ke, K)), !0 === Ke.mathMl && (D(Re, W), D(ke, $), D(ke, K))), e.ADD_TAGS && (Re === xe && (Re = F(Re)), D(Re, e.ADD_TAGS, ge)), e.ADD_ATTR && (ke === Ae && (ke = F(ke)), D(ke, e.ADD_ATTR, ge)), e.ADD_URI_SAFE_ATTR && D(tt, e.ADD_URI_SAFE_ATTR, ge), e.FORBID_CONTENTS && (Qe === Je && (Qe = F(Qe)), D(Qe, e.FORBID_CONTENTS, ge)), Xe && (Re["#text"] = !0), He && D(Re, [
                "html",
                "head",
                "body"
            ]), Re.table && (D(Re, [
                "tbody"
            ]), delete Me.tbody), y && y(e), ft = e);
        }, vt = D({}, [
            "mi",
            "mo",
            "mn",
            "ms",
            "mtext"
        ]), ht = D({}, [
            "annotation-xml"
        ]), gt = D({}, [
            "title",
            "style",
            "font",
            "a",
            "script"
        ]), yt = D({}, U);
        D(yt, z), D(yt, G);
        var bt = D({}, W);
        D(bt, V);
        var Et = function(e) {
            R(n.removed, {
                element: e
            });
            try {
                e.parentNode.removeChild(e);
            } catch (t) {
                try {
                    e.outerHTML = P;
                } catch (t) {
                    e.remove();
                }
            }
        }, wt = function(e, t) {
            try {
                R(n.removed, {
                    attribute: t.getAttributeNode(e),
                    from: t
                });
            } catch (e) {
                R(n.removed, {
                    attribute: null,
                    from: t
                });
            }
            if (t.removeAttribute(e), "is" === e && !ke[e]) if (Ge || We) try {
                Et(t);
            } catch (e) {}
            else try {
                t.setAttribute(e, "");
            } catch (e) {}
        }, Nt = function(e) {
            var t, n;
            if (ze) e = "<remove></remove>" + e;
            else {
                var r = A(e, /^[\r\n\t ]+/);
                n = r && r[0];
            }
            "application/xhtml+xml" === he && it === at && (e = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + e + "</body></html>");
            var a = T ? T.createHTML(e) : e;
            if (it === at) try {
                t = (new v).parseFromString(a, he);
            } catch (e) {}
            if (!t || !t.documentElement) {
                t = le.createDocument(it, "template", null);
                try {
                    t.documentElement.innerHTML = ct ? P : a;
                } catch (e) {}
            }
            var i = t.body || t.documentElement;
            return e && n && i.insertBefore(o.createTextNode(n), i.childNodes[0] || null), it === at ? de.call(t, He ? "html" : "body")[0] : He ? t.documentElement : i;
        }, St = function(e) {
            return se.call(e.ownerDocument || e, e, s.SHOW_ELEMENT | s.SHOW_COMMENT | s.SHOW_TEXT | s.SHOW_PROCESSING_INSTRUCTION | s.SHOW_CDATA_SECTION, null, !1);
        }, Tt = function(e) {
            return e instanceof p && ("string" != typeof e.nodeName || "string" != typeof e.textContent || "function" != typeof e.removeChild || !(e.attributes instanceof m) || "function" != typeof e.removeAttribute || "function" != typeof e.setAttribute || "string" != typeof e.namespaceURI || "function" != typeof e.insertBefore || "function" != typeof e.hasChildNodes);
        }, Ct = function(e) {
            return "object" === u(c) ? e instanceof c : e && "object" === u(e) && "number" == typeof e.nodeType && "string" == typeof e.nodeName;
        }, Ot = function(e, t, r) {
            ve[e] && C(ve[e], function(e) {
                e.call(n, t, r, ft);
            });
        }, Rt = function(e) {
            var t;
            if (Ot("beforeSanitizeElements", e, null), Tt(e)) return Et(e), !0;
            if (L(/[\u0080-\uFFFF]/, e.nodeName)) return Et(e), !0;
            var r = ge(e.nodeName);
            if (Ot("uponSanitizeElement", e, {
                tagName: r,
                allowedTags: Re
            }), e.hasChildNodes() && !Ct(e.firstElementChild) && (!Ct(e.content) || !Ct(e.content.firstElementChild)) && L(/<[/\w]/g, e.innerHTML) && L(/<[/\w]/g, e.textContent)) return Et(e), !0;
            if ("select" === r && L(/<template/i, e.innerHTML)) return Et(e), !0;
            if (7 === e.nodeType) return Et(e), !0;
            if (Be && 8 === e.nodeType && L(/<[/\w]/g, e.data)) return Et(e), !0;
            if (!Re[r] || Me[r]) {
                if (!Me[r] && kt(r)) {
                    if (Ie.tagNameCheck instanceof RegExp && L(Ie.tagNameCheck, r)) return !1;
                    if (Ie.tagNameCheck instanceof Function && Ie.tagNameCheck(r)) return !1;
                }
                if (Xe && !Qe[r]) {
                    var o = N(e) || e.parentNode, a = w(e) || e.childNodes;
                    if (a && o) for(var i = a.length - 1; i >= 0; --i){
                        var c = b(a[i], !0);
                        c.__removalCount = (e.__removalCount || 0) + 1, o.insertBefore(c, E(e));
                    }
                }
                return Et(e), !0;
            }
            return e instanceof l && !function(e) {
                var t = N(e);
                t && t.tagName || (t = {
                    namespaceURI: it,
                    tagName: "template"
                });
                var n = x(e.tagName), r = x(t.tagName);
                return !!ut[e.namespaceURI] && (e.namespaceURI === ot ? t.namespaceURI === at ? "svg" === n : t.namespaceURI === rt ? "svg" === n && ("annotation-xml" === r || vt[r]) : Boolean(yt[n]) : e.namespaceURI === rt ? t.namespaceURI === at ? "math" === n : t.namespaceURI === ot ? "math" === n && ht[r] : Boolean(bt[n]) : e.namespaceURI === at ? !(t.namespaceURI === ot && !ht[r]) && !(t.namespaceURI === rt && !vt[r]) && !bt[n] && (gt[n] || !yt[n]) : !("application/xhtml+xml" !== he || !ut[e.namespaceURI]));
            }(e) ? (Et(e), !0) : "noscript" !== r && "noembed" !== r && "noframes" !== r || !L(/<\/no(script|embed|frames)/i, e.innerHTML) ? (Fe && 3 === e.nodeType && (t = e.textContent, t = I(t, ye, " "), t = I(t, be, " "), t = I(t, Ee, " "), e.textContent !== t && (R(n.removed, {
                element: e.cloneNode()
            }), e.textContent = t)), Ot("afterSanitizeElements", e, null), !1) : (Et(e), !0);
        }, xt = function(e, t, n) {
            if (Ye && ("id" === t || "name" === t) && (n in o || n in dt)) return !1;
            if (je && !_e[t] && L(we, t)) ;
            else if (Le && L(Ne, t)) ;
            else if (!ke[t] || _e[t]) {
                if (!(kt(e) && (Ie.tagNameCheck instanceof RegExp && L(Ie.tagNameCheck, e) || Ie.tagNameCheck instanceof Function && Ie.tagNameCheck(e)) && (Ie.attributeNameCheck instanceof RegExp && L(Ie.attributeNameCheck, t) || Ie.attributeNameCheck instanceof Function && Ie.attributeNameCheck(t)) || "is" === t && Ie.allowCustomizedBuiltInElements && (Ie.tagNameCheck instanceof RegExp && L(Ie.tagNameCheck, n) || Ie.tagNameCheck instanceof Function && Ie.tagNameCheck(n)))) return !1;
            } else if (tt[t]) ;
            else if (L(Oe, I(n, Te, ""))) ;
            else if ("src" !== t && "xlink:href" !== t && "href" !== t || "script" === e || 0 !== M(n, "data:") || !Ze[e]) {
                if (Pe && !L(Se, I(n, Te, ""))) ;
                else if (n) return !1;
            } else ;
            return !0;
        }, kt = function(e) {
            return "annotation-xml" !== e && A(e, Ce);
        }, At = function(e) {
            var t, r, o, a;
            Ot("beforeSanitizeAttributes", e, null);
            var i = e.attributes;
            if (i && !Tt(e)) {
                var c = {
                    attrName: "",
                    attrValue: "",
                    keepAttr: !0,
                    allowedAttributes: ke
                };
                for(a = i.length; a--;){
                    var l = t = i[a], s = l.name, f = l.namespaceURI;
                    if (r = "value" === s ? t.value : _(t.value), o = ge(s), c.attrName = o, c.attrValue = r, c.keepAttr = !0, c.forceKeepAttr = void 0, Ot("uponSanitizeAttribute", e, c), r = c.attrValue, !c.forceKeepAttr && (wt(s, e), c.keepAttr)) if (De || !L(/\/>/i, r)) {
                        Fe && (r = I(r, ye, " "), r = I(r, be, " "), r = I(r, Ee, " "));
                        var d = ge(e.nodeName);
                        if (xt(d, o, r)) if (!qe || "id" !== o && "name" !== o || (wt(s, e), r = "user-content-" + r), Be && L(/((--!?|])>)|<\/(style|title)/i, r)) wt(s, e);
                        else {
                            if (T && "object" === u(h) && "function" == typeof h.getAttributeType) if (f) ;
                            else switch(h.getAttributeType(d, o)){
                                case "TrustedHTML":
                                    r = T.createHTML(r);
                                    break;
                                case "TrustedScriptURL":
                                    r = T.createScriptURL(r);
                            }
                            try {
                                f ? e.setAttributeNS(f, s, r) : e.setAttribute(s, r), Tt(e) ? Et(e) : O(n.removed);
                            } catch (e) {}
                        }
                    } else wt(s, e);
                }
                Ot("afterSanitizeAttributes", e, null);
            }
        }, It = function e(t) {
            var n, r = St(t);
            for(Ot("beforeSanitizeShadowDOM", t, null); n = r.nextNode();)Ot("uponSanitizeShadowNode", n, null), Rt(n), At(n), n.content instanceof a && e(n.content);
            Ot("afterSanitizeShadowDOM", t, null);
        };
        return n.sanitize = function(e) {
            var o, i, l, s, f, d = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            if ((ct = !e) && (e = "\x3c!--\x3e"), "string" != typeof e && !Ct(e)) {
                if ("function" != typeof e.toString) throw j("toString is not a function");
                if ("string" != typeof (e = e.toString())) throw j("dirty is not a string, aborting");
            }
            if (!n.isSupported) {
                if ("object" === u(t.toStaticHTML) || "function" == typeof t.toStaticHTML) {
                    if ("string" == typeof e) return t.toStaticHTML(e);
                    if (Ct(e)) return t.toStaticHTML(e.outerHTML);
                }
                return e;
            }
            if (Ue || pt(d), n.removed = [], "string" == typeof e && ($e = !1), $e) {
                if (e.nodeName) {
                    var m = ge(e.nodeName);
                    if (!Re[m] || Me[m]) throw j("root node is forbidden and cannot be sanitized in-place");
                }
            } else if (e instanceof c) 1 === (i = (o = Nt("\x3c!----\x3e")).ownerDocument.importNode(e, !0)).nodeType && "BODY" === i.nodeName || "HTML" === i.nodeName ? o = i : o.appendChild(i);
            else {
                if (!Ge && !Fe && !He && -1 === e.indexOf("<")) return T && Ve ? T.createHTML(e) : e;
                if (!(o = Nt(e))) return Ge ? null : Ve ? P : "";
            }
            o && ze && Et(o.firstChild);
            for(var p = St($e ? e : o); l = p.nextNode();)3 === l.nodeType && l === s || (Rt(l), At(l), l.content instanceof a && It(l.content), s = l);
            if (s = null, $e) return e;
            if (Ge) {
                if (We) for(f = fe.call(o.ownerDocument); o.firstChild;)f.appendChild(o.firstChild);
                else f = o;
                return (ke.shadowroot || ke.shadowrootmod) && (f = me.call(r, f, !0)), f;
            }
            var v = He ? o.outerHTML : o.innerHTML;
            return He && Re["!doctype"] && o.ownerDocument && o.ownerDocument.doctype && o.ownerDocument.doctype.name && L(ae, o.ownerDocument.doctype.name) && (v = "<!DOCTYPE " + o.ownerDocument.doctype.name + ">\n" + v), Fe && (v = I(v, ye, " "), v = I(v, be, " "), v = I(v, Ee, " ")), T && Ve ? T.createHTML(v) : v;
        }, n.setConfig = function(e) {
            pt(e), Ue = !0;
        }, n.clearConfig = function() {
            ft = null, Ue = !1;
        }, n.isValidAttribute = function(e, t, n) {
            ft || pt({});
            var r = ge(e), o = ge(t);
            return xt(r, o, n);
        }, n.addHook = function(e, t) {
            "function" == typeof t && (ve[e] = ve[e] || [], R(ve[e], t));
        }, n.removeHook = function(e) {
            if (ve[e]) return O(ve[e]);
        }, n.removeHooks = function(e) {
            ve[e] && (ve[e] = []);
        }, n.removeAllHooks = function() {
            ve = {};
        }, n;
    }(), le = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
    function se(e) {
        return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
    }
    var fe = {
        exports: {}
    }, de = function(e) {
        return e && e.Math === Math && e;
    }, me = de("object" == typeof globalThis && globalThis) || de("object" == typeof window && window) || de("object" == typeof self && self) || de("object" == typeof le && le) || de("object" == typeof le && le) || function() {
        return this;
    }() || Function("return this")(), pe = function(e) {
        try {
            return !!e();
        } catch (e) {
            return !0;
        }
    }, ve = !pe(function() {
        var e = (function() {}).bind();
        return "function" != typeof e || e.hasOwnProperty("prototype");
    }), he = ve, ge = Function.prototype, ye = ge.apply, be = ge.call, Ee = "object" == typeof Reflect && Reflect.apply || (he ? be.bind(ye) : function() {
        return be.apply(ye, arguments);
    }), we = ve, Ne = Function.prototype, Se = Ne.call, Te = we && Ne.bind.bind(Se, Se), Ce = we ? Te : function(e) {
        return function() {
            return Se.apply(e, arguments);
        };
    }, Oe = Ce, Re = Oe({}.toString), xe = Oe("".slice), ke = function(e) {
        return xe(Re(e), 8, -1);
    }, Ae = ke, Ie = Ce, Me = function(e) {
        if ("Function" === Ae(e)) return Ie(e);
    }, _e = "object" == typeof document && document.all, Le = void 0 === _e && void 0 !== _e ? function(e) {
        return "function" == typeof e || e === _e;
    } : function(e) {
        return "function" == typeof e;
    }, je = {}, Pe = !pe(function() {
        return 7 !== Object.defineProperty({}, 1, {
            get: function() {
                return 7;
            }
        })[1];
    }), De = ve, Fe = Function.prototype.call, Be = De ? Fe.bind(Fe) : function() {
        return Fe.apply(Fe, arguments);
    }, He = {}, Ue = {}.propertyIsEnumerable, ze = Object.getOwnPropertyDescriptor, Ge = ze && !Ue.call({
        1: 2
    }, 1);
    He.f = Ge ? function(e) {
        var t = ze(this, e);
        return !!t && t.enumerable;
    } : Ue;
    var We, Ve, Ye = function(e, t) {
        return {
            enumerable: !(1 & e),
            configurable: !(2 & e),
            writable: !(4 & e),
            value: t
        };
    }, qe = pe, Xe = ke, $e = Object, Ke = Ce("".split), Qe = qe(function() {
        return !$e("z").propertyIsEnumerable(0);
    }) ? function(e) {
        return "String" === Xe(e) ? Ke(e, "") : $e(e);
    } : $e, Je = function(e) {
        return null == e;
    }, Ze = Je, et = TypeError, tt = function(e) {
        if (Ze(e)) throw new et("Can't call method on " + e);
        return e;
    }, nt = Qe, rt = tt, ot = function(e) {
        return nt(rt(e));
    }, at = Le, it = function(e) {
        return "object" == typeof e ? null !== e : at(e);
    }, ct = {}, ut = ct, lt = me, st = Le, ft = function(e) {
        return st(e) ? e : void 0;
    }, dt = function(e, t) {
        return arguments.length < 2 ? ft(ut[e]) || ft(lt[e]) : ut[e] && ut[e][t] || lt[e] && lt[e][t];
    }, mt = Ce({}.isPrototypeOf), pt = me.navigator, vt = pt && pt.userAgent, ht = vt ? String(vt) : "", gt = me, yt = ht, bt = gt.process, Et = gt.Deno, wt = bt && bt.versions || Et && Et.version, Nt = wt && wt.v8;
    Nt && (Ve = (We = Nt.split("."))[0] > 0 && We[0] < 4 ? 1 : +(We[0] + We[1])), !Ve && yt && (!(We = yt.match(/Edge\/(\d+)/)) || We[1] >= 74) && (We = yt.match(/Chrome\/(\d+)/)) && (Ve = +We[1]);
    var St = Ve, Tt = St, Ct = pe, Ot = me.String, Rt = !!Object.getOwnPropertySymbols && !Ct(function() {
        var e = Symbol("symbol detection");
        return !Ot(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && Tt && Tt < 41;
    }), xt = Rt && !Symbol.sham && "symbol" == typeof Symbol.iterator, kt = dt, At = Le, It = mt, Mt = Object, _t = xt ? function(e) {
        return "symbol" == typeof e;
    } : function(e) {
        var t = kt("Symbol");
        return At(t) && It(t.prototype, Mt(e));
    }, Lt = String, jt = function(e) {
        try {
            return Lt(e);
        } catch (e) {
            return "Object";
        }
    }, Pt = Le, Dt = jt, Ft = TypeError, Bt = function(e) {
        if (Pt(e)) return e;
        throw new Ft(Dt(e) + " is not a function");
    }, Ht = Bt, Ut = Je, zt = function(e, t) {
        var n = e[t];
        return Ut(n) ? void 0 : Ht(n);
    }, Gt = Be, Wt = Le, Vt = it, Yt = TypeError, qt = {
        exports: {}
    }, Xt = me, $t = Object.defineProperty, Kt = me, Qt = function(e, t) {
        try {
            $t(Xt, e, {
                value: t,
                configurable: !0,
                writable: !0
            });
        } catch (n) {
            Xt[e] = t;
        }
        return t;
    }, Jt = "__core-js_shared__", Zt = qt.exports = Kt[Jt] || Qt(Jt, {});
    (Zt.versions || (Zt.versions = [])).push({
        version: "3.41.0",
        mode: "pure",
        copyright: "© 2014-2025 Denis Pushkarev (zloirock.ru)",
        license: "https://github.com/zloirock/core-js/blob/v3.41.0/LICENSE",
        source: "https://github.com/zloirock/core-js"
    });
    var en = qt.exports, tn = en, nn = function(e, t) {
        return tn[e] || (tn[e] = t || {});
    }, rn = tt, on = Object, an = function(e) {
        return on(rn(e));
    }, cn = an, un = Ce({}.hasOwnProperty), ln = Object.hasOwn || function(e, t) {
        return un(cn(e), t);
    }, sn = Ce, fn = 0, dn = Math.random(), mn = sn(1..toString), pn = function(e) {
        return "Symbol(" + (void 0 === e ? "" : e) + ")_" + mn(++fn + dn, 36);
    }, vn = nn, hn = ln, gn = pn, yn = Rt, bn = xt, En = me.Symbol, wn = vn("wks"), Nn = bn ? En.for || En : En && En.withoutSetter || gn, Sn = function(e) {
        return hn(wn, e) || (wn[e] = yn && hn(En, e) ? En[e] : Nn("Symbol." + e)), wn[e];
    }, Tn = Be, Cn = it, On = _t, Rn = zt, xn = function(e, t) {
        var n, r;
        if ("string" === t && Wt(n = e.toString) && !Vt(r = Gt(n, e))) return r;
        if (Wt(n = e.valueOf) && !Vt(r = Gt(n, e))) return r;
        if ("string" !== t && Wt(n = e.toString) && !Vt(r = Gt(n, e))) return r;
        throw new Yt("Can't convert object to primitive value");
    }, kn = TypeError, An = Sn("toPrimitive"), In = function(e, t) {
        if (!Cn(e) || On(e)) return e;
        var n, r = Rn(e, An);
        if (r) {
            if (void 0 === t && (t = "default"), n = Tn(r, e, t), !Cn(n) || On(n)) return n;
            throw new kn("Can't convert object to primitive value");
        }
        return void 0 === t && (t = "number"), xn(e, t);
    }, Mn = _t, _n = function(e) {
        var t = In(e, "string");
        return Mn(t) ? t : t + "";
    }, Ln = it, jn = me.document, Pn = Ln(jn) && Ln(jn.createElement), Dn = function(e) {
        return Pn ? jn.createElement(e) : {};
    }, Fn = Dn, Bn = !Pe && !pe(function() {
        return 7 !== Object.defineProperty(Fn("div"), "a", {
            get: function() {
                return 7;
            }
        }).a;
    }), Hn = Pe, Un = Be, zn = He, Gn = Ye, Wn = ot, Vn = _n, Yn = ln, qn = Bn, Xn = Object.getOwnPropertyDescriptor;
    je.f = Hn ? Xn : function(e, t) {
        if (e = Wn(e), t = Vn(t), qn) try {
            return Xn(e, t);
        } catch (e) {}
        if (Yn(e, t)) return Gn(!Un(zn.f, e, t), e[t]);
    };
    var $n = pe, Kn = Le, Qn = /#|\.prototype\./, Jn = function(e, t) {
        var n = er[Zn(e)];
        return n === nr || n !== tr && (Kn(t) ? $n(t) : !!t);
    }, Zn = Jn.normalize = function(e) {
        return String(e).replace(Qn, ".").toLowerCase();
    }, er = Jn.data = {}, tr = Jn.NATIVE = "N", nr = Jn.POLYFILL = "P", rr = Jn, or = Bt, ar = ve, ir = Me(Me.bind), cr = function(e, t) {
        return or(e), void 0 === t ? e : ar ? ir(e, t) : function() {
            return e.apply(t, arguments);
        };
    }, ur = {}, lr = Pe && pe(function() {
        return 42 !== Object.defineProperty(function() {}, "prototype", {
            value: 42,
            writable: !1
        }).prototype;
    }), sr = it, fr = String, dr = TypeError, mr = function(e) {
        if (sr(e)) return e;
        throw new dr(fr(e) + " is not an object");
    }, pr = Pe, vr = Bn, hr = lr, gr = mr, yr = _n, br = TypeError, Er = Object.defineProperty, wr = Object.getOwnPropertyDescriptor, Nr = "enumerable", Sr = "configurable", Tr = "writable";
    ur.f = pr ? hr ? function(e, t, n) {
        if (gr(e), t = yr(t), gr(n), "function" == typeof e && "prototype" === t && "value" in n && Tr in n && !n[Tr]) {
            var r = wr(e, t);
            r && r[Tr] && (e[t] = n.value, n = {
                configurable: Sr in n ? n[Sr] : r[Sr],
                enumerable: Nr in n ? n[Nr] : r[Nr],
                writable: !1
            });
        }
        return Er(e, t, n);
    } : Er : function(e, t, n) {
        if (gr(e), t = yr(t), gr(n), vr) try {
            return Er(e, t, n);
        } catch (e) {}
        if ("get" in n || "set" in n) throw new br("Accessors not supported");
        return "value" in n && (e[t] = n.value), e;
    };
    var Cr = ur, Or = Ye, Rr = Pe ? function(e, t, n) {
        return Cr.f(e, t, Or(1, n));
    } : function(e, t, n) {
        return e[t] = n, e;
    }, xr = me, kr = Ee, Ar = Me, Ir = Le, Mr = je.f, _r = rr, Lr = ct, jr = cr, Pr = Rr, Dr = ln, Fr = function(e) {
        var t = function(n, r, o) {
            if (this instanceof t) {
                switch(arguments.length){
                    case 0:
                        return new e;
                    case 1:
                        return new e(n);
                    case 2:
                        return new e(n, r);
                }
                return new e(n, r, o);
            }
            return kr(e, this, arguments);
        };
        return t.prototype = e.prototype, t;
    }, Br = function(e, t) {
        var n, r, o, a, i, c, u, l, s, f = e.target, d = e.global, m = e.stat, p = e.proto, v = d ? xr : m ? xr[f] : xr[f] && xr[f].prototype, h = d ? Lr : Lr[f] || Pr(Lr, f, {})[f], g = h.prototype;
        for(a in t)r = !(n = _r(d ? a : f + (m ? "." : "#") + a, e.forced)) && v && Dr(v, a), c = h[a], r && (u = e.dontCallGetSet ? (s = Mr(v, a)) && s.value : v[a]), i = r && u ? u : t[a], (n || p || typeof c != typeof i) && (l = e.bind && r ? jr(i, xr) : e.wrap && r ? Fr(i) : p && Ir(i) ? Ar(i) : i, (e.sham || i && i.sham || c && c.sham) && Pr(l, "sham", !0), Pr(h, a, l), p && (Dr(Lr, o = f + "Prototype") || Pr(Lr, o, {}), Pr(Lr[o], a, i), e.real && g && (n || !g[a]) && Pr(g, a, i)));
    }, Hr = Br, Ur = Pe, zr = ur.f;
    Hr({
        target: "Object",
        stat: !0,
        forced: Object.defineProperty !== zr,
        sham: !Ur
    }, {
        defineProperty: zr
    });
    var Gr = ct.Object, Wr = fe.exports = function(e, t, n) {
        return Gr.defineProperty(e, t, n);
    };
    Gr.defineProperty.sham && (Wr.sham = !0);
    var Vr = fe.exports, Yr = se(Vr), qr = {
        passiveListener: function() {
            var e = !1;
            try {
                var t = Yr({}, "passive", {
                    get: function() {
                        e = !0;
                    }
                });
                window.addEventListener("test", null, t);
            } catch (e) {}
            return e;
        },
        smoothScroll: function() {
            return "scrollBehavior" in document.documentElement.style;
        },
        touch: function() {
            return "ontouchstart" in window;
        }
    };
    function Xr(e) {
        return qr[e]();
    }
    var $r = pn, Kr = nn("keys"), Qr = function(e) {
        return Kr[e] || (Kr[e] = $r(e));
    }, Jr = !pe(function() {
        function e() {}
        return e.prototype.constructor = null, Object.getPrototypeOf(new e) !== e.prototype;
    }), Zr = ln, eo = Le, to = an, no = Jr, ro = Qr("IE_PROTO"), oo = Object, ao = oo.prototype, io = no ? oo.getPrototypeOf : function(e) {
        var t = to(e);
        if (Zr(t, ro)) return t[ro];
        var n = t.constructor;
        return eo(n) && t instanceof n ? n.prototype : t instanceof oo ? ao : null;
    }, co = Ce, uo = Bt, lo = it, so = function(e) {
        return lo(e) || null === e;
    }, fo = String, mo = TypeError, po = function(e, t, n) {
        try {
            return co(uo(Object.getOwnPropertyDescriptor(e, t)[n]));
        } catch (e) {}
    }, vo = it, ho = tt, go = function(e) {
        if (so(e)) return e;
        throw new mo("Can't set " + fo(e) + " as a prototype");
    }, yo = Object.setPrototypeOf || ("__proto__" in {} ? function() {
        var e, t = !1, n = {};
        try {
            (e = po(Object.prototype, "__proto__", "set"))(n, []), t = n instanceof Array;
        } catch (e) {}
        return function(n, r) {
            return ho(n), go(r), vo(n) ? (t ? e(n, r) : n.__proto__ = r, n) : n;
        };
    }() : void 0), bo = {}, Eo = Math.ceil, wo = Math.floor, No = Math.trunc || function(e) {
        var t = +e;
        return (t > 0 ? wo : Eo)(t);
    }, So = function(e) {
        var t = +e;
        return t != t || 0 === t ? 0 : No(t);
    }, To = So, Co = Math.max, Oo = Math.min, Ro = function(e, t) {
        var n = To(e);
        return n < 0 ? Co(n + t, 0) : Oo(n, t);
    }, xo = So, ko = Math.min, Ao = function(e) {
        var t = xo(e);
        return t > 0 ? ko(t, 9007199254740991) : 0;
    }, Io = function(e) {
        return Ao(e.length);
    }, Mo = ot, _o = Ro, Lo = Io, jo = function(e) {
        return function(t, n, r) {
            var o = Mo(t), a = Lo(o);
            if (0 === a) return !e && -1;
            var i, c = _o(r, a);
            if (e && n != n) {
                for(; a > c;)if ((i = o[c++]) != i) return !0;
            } else for(; a > c; c++)if ((e || c in o) && o[c] === n) return e || c || 0;
            return !e && -1;
        };
    }, Po = {
        includes: jo(!0),
        indexOf: jo(!1)
    }, Do = {}, Fo = ln, Bo = ot, Ho = Po.indexOf, Uo = Do, zo = Ce([].push), Go = function(e, t) {
        var n, r = Bo(e), o = 0, a = [];
        for(n in r)!Fo(Uo, n) && Fo(r, n) && zo(a, n);
        for(; t.length > o;)Fo(r, n = t[o++]) && (~Ho(a, n) || zo(a, n));
        return a;
    }, Wo = [
        "constructor",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "toLocaleString",
        "toString",
        "valueOf"
    ], Vo = Go, Yo = Wo.concat("length", "prototype");
    bo.f = Object.getOwnPropertyNames || function(e) {
        return Vo(e, Yo);
    };
    var qo = {};
    qo.f = Object.getOwnPropertySymbols;
    var Xo = dt, $o = bo, Ko = qo, Qo = mr, Jo = Ce([].concat), Zo = Xo("Reflect", "ownKeys") || function(e) {
        var t = $o.f(Qo(e)), n = Ko.f;
        return n ? Jo(t, n(e)) : t;
    }, ea = ln, ta = Zo, na = je, ra = ur, oa = {}, aa = Go, ia = Wo, ca = Object.keys || function(e) {
        return aa(e, ia);
    }, ua = Pe, la = lr, sa = ur, fa = mr, da = ot, ma = ca;
    oa.f = ua && !la ? Object.defineProperties : function(e, t) {
        fa(e);
        for(var n, r = da(t), o = ma(t), a = o.length, i = 0; a > i;)sa.f(e, n = o[i++], r[n]);
        return e;
    };
    var pa, va = dt("document", "documentElement"), ha = mr, ga = oa, ya = Wo, ba = Do, Ea = va, wa = Dn, Na = "prototype", Sa = "script", Ta = Qr("IE_PROTO"), Ca = function() {}, Oa = function(e) {
        return "<" + Sa + ">" + e + "</" + Sa + ">";
    }, Ra = function(e) {
        e.write(Oa("")), e.close();
        var t = e.parentWindow.Object;
        return e = null, t;
    }, xa = function() {
        try {
            pa = new ActiveXObject("htmlfile");
        } catch (e) {}
        var e, t, n;
        xa = "undefined" != typeof document ? document.domain && pa ? Ra(pa) : (t = wa("iframe"), n = "java" + Sa + ":", t.style.display = "none", Ea.appendChild(t), t.src = String(n), (e = t.contentWindow.document).open(), e.write(Oa("document.F=Object")), e.close(), e.F) : Ra(pa);
        for(var r = ya.length; r--;)delete xa[Na][ya[r]];
        return xa();
    };
    ba[Ta] = !0;
    var ka = Object.create || function(e, t) {
        var n;
        return null !== e ? (Ca[Na] = ha(e), n = new Ca, Ca[Na] = null, n[Ta] = e) : n = xa(), void 0 === t ? n : ga.f(n, t);
    }, Aa = it, Ia = Rr, Ma = Error, _a = Ce("".replace), La = String(new Ma("zxcasd").stack), ja = /\n\s*at [^:]*:[^\n]*/, Pa = ja.test(La), Da = Ye, Fa = !pe(function() {
        var e = new Error("a");
        return !("stack" in e) || (Object.defineProperty(e, "stack", Da(1, 7)), 7 !== e.stack);
    }), Ba = Rr, Ha = function(e, t) {
        if (Pa && "string" == typeof e && !Ma.prepareStackTrace) for(; t--;)e = _a(e, ja, "");
        return e;
    }, Ua = Fa, za = Error.captureStackTrace, Ga = {}, Wa = Ga, Va = Sn("iterator"), Ya = Array.prototype, qa = function(e) {
        return void 0 !== e && (Wa.Array === e || Ya[Va] === e);
    }, Xa = {};
    Xa[Sn("toStringTag")] = "z";
    var $a = "[object z]" === String(Xa), Ka = $a, Qa = Le, Ja = ke, Za = Sn("toStringTag"), ei = Object, ti = "Arguments" === Ja(function() {
        return arguments;
    }()), ni = Ka ? Ja : function(e) {
        var t, n, r;
        return void 0 === e ? "Undefined" : null === e ? "Null" : "string" == typeof (n = function(e, t) {
            try {
                return e[t];
            } catch (e) {}
        }(t = ei(e), Za)) ? n : ti ? Ja(t) : "Object" === (r = Ja(t)) && Qa(t.callee) ? "Arguments" : r;
    }, ri = ni, oi = zt, ai = Je, ii = Ga, ci = Sn("iterator"), ui = function(e) {
        if (!ai(e)) return oi(e, ci) || oi(e, "@@iterator") || ii[ri(e)];
    }, li = Be, si = Bt, fi = mr, di = jt, mi = ui, pi = TypeError, vi = function(e, t) {
        var n = arguments.length < 2 ? mi(e) : t;
        if (si(n)) return fi(li(n, e));
        throw new pi(di(e) + " is not iterable");
    }, hi = Be, gi = mr, yi = zt, bi = function(e, t, n) {
        var r, o;
        gi(e);
        try {
            if (!(r = yi(e, "return"))) {
                if ("throw" === t) throw n;
                return n;
            }
            r = hi(r, e);
        } catch (e) {
            o = !0, r = e;
        }
        if ("throw" === t) throw n;
        if (o) throw r;
        return gi(r), n;
    }, Ei = cr, wi = Be, Ni = mr, Si = jt, Ti = qa, Ci = Io, Oi = mt, Ri = vi, xi = ui, ki = bi, Ai = TypeError, Ii = function(e, t) {
        this.stopped = e, this.result = t;
    }, Mi = Ii.prototype, _i = function(e, t, n) {
        var r, o, a, i, c, u, l, s = n && n.that, f = !(!n || !n.AS_ENTRIES), d = !(!n || !n.IS_RECORD), m = !(!n || !n.IS_ITERATOR), p = !(!n || !n.INTERRUPTED), v = Ei(t, s), h = function(e) {
            return r && ki(r, "normal", e), new Ii(!0, e);
        }, g = function(e) {
            return f ? (Ni(e), p ? v(e[0], e[1], h) : v(e[0], e[1])) : p ? v(e, h) : v(e);
        };
        if (d) r = e.iterator;
        else if (m) r = e;
        else {
            if (!(o = xi(e))) throw new Ai(Si(e) + " is not iterable");
            if (Ti(o)) {
                for(a = 0, i = Ci(e); i > a; a++)if ((c = g(e[a])) && Oi(Mi, c)) return c;
                return new Ii(!1);
            }
            r = Ri(e, o);
        }
        for(u = d ? e.next : r.next; !(l = wi(u, r)).done;){
            try {
                c = g(l.value);
            } catch (e) {
                ki(r, "throw", e);
            }
            if ("object" == typeof c && c && Oi(Mi, c)) return c;
        }
        return new Ii(!1);
    }, Li = ni, ji = String, Pi = function(e) {
        if ("Symbol" === Li(e)) throw new TypeError("Cannot convert a Symbol value to a string");
        return ji(e);
    }, Di = Pi, Fi = Br, Bi = mt, Hi = io, Ui = yo, zi = function(e, t, n) {
        for(var r = ta(t), o = ra.f, a = na.f, i = 0; i < r.length; i++){
            var c = r[i];
            ea(e, c) || n && ea(n, c) || o(e, c, a(t, c));
        }
    }, Gi = ka, Wi = Rr, Vi = Ye, Yi = function(e, t) {
        Aa(t) && "cause" in t && Ia(e, "cause", t.cause);
    }, qi = function(e, t, n, r) {
        Ua && (za ? za(e, t) : Ba(e, "stack", Ha(n, r)));
    }, Xi = _i, $i = function(e, t) {
        return void 0 === e ? arguments.length < 2 ? "" : t : Di(e);
    }, Ki = Sn("toStringTag"), Qi = Error, Ji = [].push, Zi = function(e, t) {
        var n, r = Bi(ec, this);
        Ui ? n = Ui(new Qi, r ? Hi(this) : ec) : (n = r ? this : Gi(ec), Wi(n, Ki, "Error")), void 0 !== t && Wi(n, "message", $i(t)), qi(n, Zi, n.stack, 1), arguments.length > 2 && Yi(n, arguments[2]);
        var o = [];
        return Xi(e, Ji, {
            that: o
        }), Wi(n, "errors", o), n;
    };
    Ui ? Ui(Zi, Qi) : zi(Zi, Qi, {
        name: !0
    });
    var ec = Zi.prototype = Gi(Qi.prototype, {
        constructor: Vi(1, Zi),
        message: Vi(1, ""),
        name: Vi(1, "AggregateError")
    });
    Fi({
        global: !0,
        constructor: !0,
        arity: 2
    }, {
        AggregateError: Zi
    });
    var tc, nc, rc, oc = Le, ac = me.WeakMap, ic = oc(ac) && /native code/.test(String(ac)), cc = me, uc = it, lc = Rr, sc = ln, fc = en, dc = Qr, mc = Do, pc = "Object already initialized", vc = cc.TypeError, hc = cc.WeakMap;
    if (ic || fc.state) {
        var gc = fc.state || (fc.state = new hc);
        gc.get = gc.get, gc.has = gc.has, gc.set = gc.set, tc = function(e, t) {
            if (gc.has(e)) throw new vc(pc);
            return t.facade = e, gc.set(e, t), t;
        }, nc = function(e) {
            return gc.get(e) || {};
        }, rc = function(e) {
            return gc.has(e);
        };
    } else {
        var yc = dc("state");
        mc[yc] = !0, tc = function(e, t) {
            if (sc(e, yc)) throw new vc(pc);
            return t.facade = e, lc(e, yc, t), t;
        }, nc = function(e) {
            return sc(e, yc) ? e[yc] : {};
        }, rc = function(e) {
            return sc(e, yc);
        };
    }
    var bc, Ec, wc, Nc = {
        set: tc,
        get: nc,
        has: rc,
        enforce: function(e) {
            return rc(e) ? nc(e) : tc(e, {});
        },
        getterFor: function(e) {
            return function(t) {
                var n;
                if (!uc(t) || (n = nc(t)).type !== e) throw new vc("Incompatible receiver, " + e + " required");
                return n;
            };
        }
    }, Sc = Pe, Tc = ln, Cc = Function.prototype, Oc = Sc && Object.getOwnPropertyDescriptor, Rc = Tc(Cc, "name"), xc = {
        EXISTS: Rc,
        PROPER: Rc && "something" === (function() {}).name,
        CONFIGURABLE: Rc && (!Sc || Sc && Oc(Cc, "name").configurable)
    }, kc = Rr, Ac = function(e, t, n, r) {
        return r && r.enumerable ? e[t] = n : kc(e, t, n), e;
    }, Ic = pe, Mc = Le, _c = it, Lc = ka, jc = io, Pc = Ac, Dc = Sn("iterator"), Fc = !1;
    [].keys && ("next" in (wc = [].keys()) ? (Ec = jc(jc(wc))) !== Object.prototype && (bc = Ec) : Fc = !0);
    var Bc = !_c(bc) || Ic(function() {
        var e = {};
        return bc[Dc].call(e) !== e;
    });
    Mc((bc = Bc ? {} : Lc(bc))[Dc]) || Pc(bc, Dc, function() {
        return this;
    });
    var Hc = {
        IteratorPrototype: bc,
        BUGGY_SAFARI_ITERATORS: Fc
    }, Uc = ni, zc = $a ? ({}).toString : function() {
        return "[object " + Uc(this) + "]";
    }, Gc = $a, Wc = ur.f, Vc = Rr, Yc = ln, qc = zc, Xc = Sn("toStringTag"), $c = function(e, t, n, r) {
        var o = n ? e : e && e.prototype;
        o && (Yc(o, Xc) || Wc(o, Xc, {
            configurable: !0,
            value: t
        }), r && !Gc && Vc(o, "toString", qc));
    }, Kc = Hc.IteratorPrototype, Qc = ka, Jc = Ye, Zc = $c, eu = Ga, tu = function() {
        return this;
    }, nu = Br, ru = Be, ou = xc, au = function(e, t, n, r) {
        var o = t + " Iterator";
        return e.prototype = Qc(Kc, {
            next: Jc(+!r, n)
        }), Zc(e, o, !1, !0), eu[o] = tu, e;
    }, iu = io, cu = $c, uu = Ac, lu = Ga, su = Hc, fu = ou.PROPER, du = su.BUGGY_SAFARI_ITERATORS, mu = Sn("iterator"), pu = "keys", vu = "values", hu = "entries", gu = function() {
        return this;
    }, yu = function(e, t, n, r, o, a, i) {
        au(n, t, r);
        var c, u, l, s = function(e) {
            if (e === o && v) return v;
            if (!du && e && e in m) return m[e];
            switch(e){
                case pu:
                case vu:
                case hu:
                    return function() {
                        return new n(this, e);
                    };
            }
            return function() {
                return new n(this);
            };
        }, f = t + " Iterator", d = !1, m = e.prototype, p = m[mu] || m["@@iterator"] || o && m[o], v = !du && p || s(o), h = "Array" === t && m.entries || p;
        if (h && (c = iu(h.call(new e))) !== Object.prototype && c.next && (cu(c, f, !0, !0), lu[f] = gu), fu && o === vu && p && p.name !== vu && (d = !0, v = function() {
            return ru(p, this);
        }), o) if (u = {
            values: s(vu),
            keys: a ? v : s(pu),
            entries: s(hu)
        }, i) for(l in u)(du || d || !(l in m)) && uu(m, l, u[l]);
        else nu({
            target: t,
            proto: !0,
            forced: du || d
        }, u);
        return i && m[mu] !== v && uu(m, mu, v, {
            name: o
        }), lu[t] = v, u;
    }, bu = function(e, t) {
        return {
            value: e,
            done: t
        };
    }, Eu = ot, wu = function() {}, Nu = Ga, Su = Nc, Tu = (ur.f, yu), Cu = bu, Ou = "Array Iterator", Ru = Su.set, xu = Su.getterFor(Ou);
    Tu(Array, "Array", function(e, t) {
        Ru(this, {
            type: Ou,
            target: Eu(e),
            index: 0,
            kind: t
        });
    }, function() {
        var e = xu(this), t = e.target, n = e.index++;
        if (!t || n >= t.length) return e.target = null, Cu(void 0, !0);
        switch(e.kind){
            case "keys":
                return Cu(n, !1);
            case "values":
                return Cu(t[n], !1);
        }
        return Cu([
            n,
            t[n]
        ], !1);
    }, "values");
    Nu.Arguments = Nu.Array;
    wu(), wu(), wu();
    var ku = me, Au = ht, Iu = ke, Mu = function(e) {
        return Au.slice(0, e.length) === e;
    }, _u = Mu("Bun/") ? "BUN" : Mu("Cloudflare-Workers") ? "CLOUDFLARE" : Mu("Deno/") ? "DENO" : Mu("Node.js/") ? "NODE" : ku.Bun && "string" == typeof Bun.version ? "BUN" : ku.Deno && "object" == typeof Deno.version ? "DENO" : "process" === Iu(ku.process) ? "NODE" : ku.window && ku.document ? "BROWSER" : "REST", Lu = "NODE" === _u, ju = ur, Pu = function(e, t, n) {
        return ju.f(e, t, n);
    }, Du = dt, Fu = Pu, Bu = Pe, Hu = Sn("species"), Uu = mt, zu = TypeError, Gu = Le, Wu = en, Vu = Ce(Function.toString);
    Gu(Wu.inspectSource) || (Wu.inspectSource = function(e) {
        return Vu(e);
    });
    var Yu = Wu.inspectSource, qu = Ce, Xu = pe, $u = Le, Ku = ni, Qu = Yu, Ju = function() {}, Zu = dt("Reflect", "construct"), el = /^\s*(?:class|function)\b/, tl = qu(el.exec), nl = !el.test(Ju), rl = function(e) {
        if (!$u(e)) return !1;
        try {
            return Zu(Ju, [], e), !0;
        } catch (e) {
            return !1;
        }
    }, ol = function(e) {
        if (!$u(e)) return !1;
        switch(Ku(e)){
            case "AsyncFunction":
            case "GeneratorFunction":
            case "AsyncGeneratorFunction":
                return !1;
        }
        try {
            return nl || !!tl(el, Qu(e));
        } catch (e) {
            return !0;
        }
    };
    ol.sham = !0;
    var al, il, cl, ul, ll = !Zu || Xu(function() {
        var e;
        return rl(rl.call) || !rl(Object) || !rl(function() {
            e = !0;
        }) || e;
    }) ? ol : rl, sl = ll, fl = jt, dl = TypeError, ml = function(e) {
        if (sl(e)) return e;
        throw new dl(fl(e) + " is not a constructor");
    }, pl = mr, vl = ml, hl = Je, gl = Sn("species"), yl = function(e, t) {
        var n, r = pl(e).constructor;
        return void 0 === r || hl(n = pl(r)[gl]) ? t : vl(n);
    }, bl = Ce([].slice), El = TypeError, wl = /(?:ipad|iphone|ipod).*applewebkit/i.test(ht), Nl = me, Sl = Ee, Tl = cr, Cl = Le, Ol = ln, Rl = pe, xl = va, kl = bl, Al = Dn, Il = function(e, t) {
        if (e < t) throw new El("Not enough arguments");
        return e;
    }, Ml = wl, _l = Lu, Ll = Nl.setImmediate, jl = Nl.clearImmediate, Pl = Nl.process, Dl = Nl.Dispatch, Fl = Nl.Function, Bl = Nl.MessageChannel, Hl = Nl.String, Ul = 0, zl = {}, Gl = "onreadystatechange";
    Rl(function() {
        al = Nl.location;
    });
    var Wl = function(e) {
        if (Ol(zl, e)) {
            var t = zl[e];
            delete zl[e], t();
        }
    }, Vl = function(e) {
        return function() {
            Wl(e);
        };
    }, Yl = function(e) {
        Wl(e.data);
    }, ql = function(e) {
        Nl.postMessage(Hl(e), al.protocol + "//" + al.host);
    };
    Ll && jl || (Ll = function(e) {
        Il(arguments.length, 1);
        var t = Cl(e) ? e : Fl(e), n = kl(arguments, 1);
        return zl[++Ul] = function() {
            Sl(t, void 0, n);
        }, il(Ul), Ul;
    }, jl = function(e) {
        delete zl[e];
    }, _l ? il = function(e) {
        Pl.nextTick(Vl(e));
    } : Dl && Dl.now ? il = function(e) {
        Dl.now(Vl(e));
    } : Bl && !Ml ? (ul = (cl = new Bl).port2, cl.port1.onmessage = Yl, il = Tl(ul.postMessage, ul)) : Nl.addEventListener && Cl(Nl.postMessage) && !Nl.importScripts && al && "file:" !== al.protocol && !Rl(ql) ? (il = ql, Nl.addEventListener("message", Yl, !1)) : il = Gl in Al("script") ? function(e) {
        xl.appendChild(Al("script"))[Gl] = function() {
            xl.removeChild(this), Wl(e);
        };
    } : function(e) {
        setTimeout(Vl(e), 0);
    });
    var Xl = {
        set: Ll,
        clear: jl
    }, $l = me, Kl = Pe, Ql = Object.getOwnPropertyDescriptor, Jl = function() {
        this.head = null, this.tail = null;
    };
    Jl.prototype = {
        add: function(e) {
            var t = {
                item: e,
                next: null
            }, n = this.tail;
            n ? n.next = t : this.head = t, this.tail = t;
        },
        get: function() {
            var e = this.head;
            if (e) return null === (this.head = e.next) && (this.tail = null), e.item;
        }
    };
    var Zl, es, ts, ns, rs, os = Jl, as = /ipad|iphone|ipod/i.test(ht) && "undefined" != typeof Pebble, is = /web0s(?!.*chrome)/i.test(ht), cs = me, us = function(e) {
        if (!Kl) return $l[e];
        var t = Ql($l, e);
        return t && t.value;
    }, ls = cr, ss = Xl.set, fs = os, ds = wl, ms = as, ps = is, vs = Lu, hs = cs.MutationObserver || cs.WebKitMutationObserver, gs = cs.document, ys = cs.process, bs = cs.Promise, Es = us("queueMicrotask");
    if (!Es) {
        var ws = new fs, Ns = function() {
            var e, t;
            for(vs && (e = ys.domain) && e.exit(); t = ws.get();)try {
                t();
            } catch (e) {
                throw ws.head && Zl(), e;
            }
            e && e.enter();
        };
        ds || vs || ps || !hs || !gs ? !ms && bs && bs.resolve ? ((ns = bs.resolve(void 0)).constructor = bs, rs = ls(ns.then, ns), Zl = function() {
            rs(Ns);
        }) : vs ? Zl = function() {
            ys.nextTick(Ns);
        } : (ss = ls(ss, cs), Zl = function() {
            ss(Ns);
        }) : (es = !0, ts = gs.createTextNode(""), new hs(Ns).observe(ts, {
            characterData: !0
        }), Zl = function() {
            ts.data = es = !es;
        }), Es = function(e) {
            ws.head || Zl(), ws.add(e);
        };
    }
    var Ss = Es, Ts = function(e) {
        try {
            return {
                error: !1,
                value: e()
            };
        } catch (e) {
            return {
                error: !0,
                value: e
            };
        }
    }, Cs = me.Promise, Os = me, Rs = Cs, xs = Le, ks = rr, As = Yu, Is = Sn, Ms = _u, _s = St, Ls = Rs && Rs.prototype, js = Is("species"), Ps = !1, Ds = xs(Os.PromiseRejectionEvent), Fs = ks("Promise", function() {
        var e = As(Rs), t = e !== String(Rs);
        if (!t && 66 === _s) return !0;
        if (!Ls.catch || !Ls.finally) return !0;
        if (!_s || _s < 51 || !/native code/.test(e)) {
            var n = new Rs(function(e) {
                e(1);
            }), r = function(e) {
                e(function() {}, function() {});
            };
            if ((n.constructor = {})[js] = r, !(Ps = n.then(function() {}) instanceof r)) return !0;
        }
        return !(t || "BROWSER" !== Ms && "DENO" !== Ms || Ds);
    }), Bs = {
        CONSTRUCTOR: Fs,
        REJECTION_EVENT: Ds,
        SUBCLASSING: Ps
    }, Hs = {}, Us = Bt, zs = TypeError, Gs = function(e) {
        var t, n;
        this.promise = new e(function(e, r) {
            if (void 0 !== t || void 0 !== n) throw new zs("Bad Promise constructor");
            t = e, n = r;
        }), this.resolve = Us(t), this.reject = Us(n);
    };
    Hs.f = function(e) {
        return new Gs(e);
    };
    var Ws, Vs, Ys = Br, qs = Lu, Xs = me, $s = Be, Ks = Ac, Qs = $c, Js = function(e) {
        var t = Du(e);
        Bu && t && !t[Hu] && Fu(t, Hu, {
            configurable: !0,
            get: function() {
                return this;
            }
        });
    }, Zs = Bt, ef = Le, tf = it, nf = function(e, t) {
        if (Uu(t, e)) return e;
        throw new zu("Incorrect invocation");
    }, rf = yl, of = Xl.set, af = Ss, cf = function(e, t) {}, uf = Ts, lf = os, sf = Nc, ff = Cs, df = Bs, mf = Hs, pf = "Promise", vf = df.CONSTRUCTOR, hf = df.REJECTION_EVENT, gf = sf.getterFor(pf), yf = sf.set, bf = ff && ff.prototype, Ef = ff, wf = bf, Nf = Xs.TypeError, Sf = Xs.document, Tf = Xs.process, Cf = mf.f, Of = Cf, Rf = !!(Sf && Sf.createEvent && Xs.dispatchEvent), xf = "unhandledrejection", kf = function(e) {
        var t;
        return !(!tf(e) || !ef(t = e.then)) && t;
    }, Af = function(e, t) {
        var n, r, o, a = t.value, i = 1 === t.state, c = i ? e.ok : e.fail, u = e.resolve, l = e.reject, s = e.domain;
        try {
            c ? (i || (2 === t.rejection && jf(t), t.rejection = 1), !0 === c ? n = a : (s && s.enter(), n = c(a), s && (s.exit(), o = !0)), n === e.promise ? l(new Nf("Promise-chain cycle")) : (r = kf(n)) ? $s(r, n, u, l) : u(n)) : l(a);
        } catch (e) {
            s && !o && s.exit(), l(e);
        }
    }, If = function(e, t) {
        e.notified || (e.notified = !0, af(function() {
            for(var n, r = e.reactions; n = r.get();)Af(n, e);
            e.notified = !1, t && !e.rejection && _f(e);
        }));
    }, Mf = function(e, t, n) {
        var r, o;
        Rf ? ((r = Sf.createEvent("Event")).promise = t, r.reason = n, r.initEvent(e, !1, !0), Xs.dispatchEvent(r)) : r = {
            promise: t,
            reason: n
        }, !hf && (o = Xs["on" + e]) ? o(r) : e === xf && cf("Unhandled promise rejection", n);
    }, _f = function(e) {
        $s(of, Xs, function() {
            var t, n = e.facade, r = e.value;
            if (Lf(e) && (t = uf(function() {
                qs ? Tf.emit("unhandledRejection", r, n) : Mf(xf, n, r);
            }), e.rejection = qs || Lf(e) ? 2 : 1, t.error)) throw t.value;
        });
    }, Lf = function(e) {
        return 1 !== e.rejection && !e.parent;
    }, jf = function(e) {
        $s(of, Xs, function() {
            var t = e.facade;
            qs ? Tf.emit("rejectionHandled", t) : Mf("rejectionhandled", t, e.value);
        });
    }, Pf = function(e, t, n) {
        return function(r) {
            e(t, r, n);
        };
    }, Df = function(e, t, n) {
        e.done || (e.done = !0, n && (e = n), e.value = t, e.state = 2, If(e, !0));
    }, Ff = function(e, t, n) {
        if (!e.done) {
            e.done = !0, n && (e = n);
            try {
                if (e.facade === t) throw new Nf("Promise can't be resolved itself");
                var r = kf(t);
                r ? af(function() {
                    var n = {
                        done: !1
                    };
                    try {
                        $s(r, t, Pf(Ff, n, e), Pf(Df, n, e));
                    } catch (t) {
                        Df(n, t, e);
                    }
                }) : (e.value = t, e.state = 1, If(e, !1));
            } catch (t) {
                Df({
                    done: !1
                }, t, e);
            }
        }
    };
    vf && (wf = (Ef = function(e) {
        nf(this, wf), Zs(e), $s(Ws, this);
        var t = gf(this);
        try {
            e(Pf(Ff, t), Pf(Df, t));
        } catch (e) {
            Df(t, e);
        }
    }).prototype, (Ws = function(e) {
        yf(this, {
            type: pf,
            done: !1,
            notified: !1,
            parent: !1,
            reactions: new lf,
            rejection: !1,
            state: 0,
            value: null
        });
    }).prototype = Ks(wf, "then", function(e, t) {
        var n = gf(this), r = Cf(rf(this, Ef));
        return n.parent = !0, r.ok = !ef(e) || e, r.fail = ef(t) && t, r.domain = qs ? Tf.domain : void 0, 0 === n.state ? n.reactions.add(r) : af(function() {
            Af(r, n);
        }), r.promise;
    }), Vs = function() {
        var e = new Ws, t = gf(e);
        this.promise = e, this.resolve = Pf(Ff, t), this.reject = Pf(Df, t);
    }, mf.f = Cf = function(e) {
        return e === Ef || undefined === e ? new Vs(e) : Of(e);
    }), Ys({
        global: !0,
        constructor: !0,
        wrap: !0,
        forced: vf
    }, {
        Promise: Ef
    }), Qs(Ef, pf, !1, !0), Js(pf);
    var Bf = Sn("iterator"), Hf = !1;
    try {
        var Uf = 0, zf = {
            next: function() {
                return {
                    done: !!Uf++
                };
            },
            return: function() {
                Hf = !0;
            }
        };
        zf[Bf] = function() {
            return this;
        }, Array.from(zf, function() {
            throw 2;
        });
    } catch (e) {}
    var Gf = function(e, t) {
        try {
            if (!t && !Hf) return !1;
        } catch (e) {
            return !1;
        }
        var n = !1;
        try {
            var r = {};
            r[Bf] = function() {
                return {
                    next: function() {
                        return {
                            done: n = !0
                        };
                    }
                };
            }, e(r);
        } catch (e) {}
        return n;
    }, Wf = Cs, Vf = Bs.CONSTRUCTOR || !Gf(function(e) {
        Wf.all(e).then(void 0, function() {});
    }), Yf = Be, qf = Bt, Xf = Hs, $f = Ts, Kf = _i;
    Br({
        target: "Promise",
        stat: !0,
        forced: Vf
    }, {
        all: function(e) {
            var t = this, n = Xf.f(t), r = n.resolve, o = n.reject, a = $f(function() {
                var n = qf(t.resolve), a = [], i = 0, c = 1;
                Kf(e, function(e) {
                    var u = i++, l = !1;
                    c++, Yf(n, t, e).then(function(e) {
                        l || (l = !0, a[u] = e, --c || r(a));
                    }, o);
                }), --c || r(a);
            });
            return a.error && o(a.value), n.promise;
        }
    });
    var Qf = Br, Jf = Bs.CONSTRUCTOR;
    Cs && Cs.prototype, Qf({
        target: "Promise",
        proto: !0,
        forced: Jf,
        real: !0
    }, {
        catch: function(e) {
            return this.then(void 0, e);
        }
    });
    var Zf = Be, ed = Bt, td = Hs, nd = Ts, rd = _i;
    Br({
        target: "Promise",
        stat: !0,
        forced: Vf
    }, {
        race: function(e) {
            var t = this, n = td.f(t), r = n.reject, o = nd(function() {
                var o = ed(t.resolve);
                rd(e, function(e) {
                    Zf(o, t, e).then(n.resolve, r);
                });
            });
            return o.error && r(o.value), n.promise;
        }
    });
    var od = Hs;
    Br({
        target: "Promise",
        stat: !0,
        forced: Bs.CONSTRUCTOR
    }, {
        reject: function(e) {
            var t = od.f(this);
            return (0, t.reject)(e), t.promise;
        }
    });
    var ad = mr, id = it, cd = Hs, ud = function(e, t) {
        if (ad(e), id(t) && t.constructor === e) return t;
        var n = cd.f(e);
        return (0, n.resolve)(t), n.promise;
    }, ld = Br, sd = Cs, fd = Bs.CONSTRUCTOR, dd = ud, md = dt("Promise"), pd = !fd;
    ld({
        target: "Promise",
        stat: !0,
        forced: true
    }, {
        resolve: function(e) {
            return dd(pd && this === md ? sd : this, e);
        }
    });
    var vd = Be, hd = Bt, gd = Hs, yd = Ts, bd = _i;
    Br({
        target: "Promise",
        stat: !0,
        forced: Vf
    }, {
        allSettled: function(e) {
            var t = this, n = gd.f(t), r = n.resolve, o = n.reject, a = yd(function() {
                var n = hd(t.resolve), o = [], a = 0, i = 1;
                bd(e, function(e) {
                    var c = a++, u = !1;
                    i++, vd(n, t, e).then(function(e) {
                        u || (u = !0, o[c] = {
                            status: "fulfilled",
                            value: e
                        }, --i || r(o));
                    }, function(e) {
                        u || (u = !0, o[c] = {
                            status: "rejected",
                            reason: e
                        }, --i || r(o));
                    });
                }), --i || r(o);
            });
            return a.error && o(a.value), n.promise;
        }
    });
    var Ed = Be, wd = Bt, Nd = dt, Sd = Hs, Td = Ts, Cd = _i, Od = "No one promise resolved";
    Br({
        target: "Promise",
        stat: !0,
        forced: Vf
    }, {
        any: function(e) {
            var t = this, n = Nd("AggregateError"), r = Sd.f(t), o = r.resolve, a = r.reject, i = Td(function() {
                var r = wd(t.resolve), i = [], c = 0, u = 1, l = !1;
                Cd(e, function(e) {
                    var s = c++, f = !1;
                    u++, Ed(r, t, e).then(function(e) {
                        f || l || (l = !0, o(e));
                    }, function(e) {
                        f || l || (f = !0, i[s] = e, --u || a(new n(i, Od)));
                    });
                }), --u || a(new n(i, Od));
            });
            return i.error && a(i.value), r.promise;
        }
    });
    var Rd = Br, xd = Ee, kd = bl, Ad = Hs, Id = Bt, Md = Ts, _d = me.Promise, Ld = !1;
    Rd({
        target: "Promise",
        stat: !0,
        forced: !_d || !_d.try || Md(function() {
            _d.try(function(e) {
                Ld = 8 === e;
            }, 8);
        }).error || !Ld
    }, {
        try: function(e) {
            var t = arguments.length > 1 ? kd(arguments, 1) : [], n = Ad.f(this), r = Md(function() {
                return xd(Id(e), void 0, t);
            });
            return (r.error ? n.reject : n.resolve)(r.value), n.promise;
        }
    });
    var jd = Hs;
    Br({
        target: "Promise",
        stat: !0
    }, {
        withResolvers: function() {
            var e = jd.f(this);
            return {
                promise: e.promise,
                resolve: e.resolve,
                reject: e.reject
            };
        }
    });
    var Pd = Br, Dd = Cs, Fd = pe, Bd = dt, Hd = Le, Ud = yl, zd = ud, Gd = Dd && Dd.prototype;
    Pd({
        target: "Promise",
        proto: !0,
        real: !0,
        forced: !!Dd && Fd(function() {
            Gd.finally.call({
                then: function() {}
            }, function() {});
        })
    }, {
        finally: function(e) {
            var t = Ud(this, Bd("Promise")), n = Hd(e);
            return this.then(n ? function(n) {
                return zd(t, e()).then(function() {
                    return n;
                });
            } : e, n ? function(n) {
                return zd(t, e()).then(function() {
                    throw n;
                });
            } : e);
        }
    });
    var Wd = Ce, Vd = So, Yd = Pi, qd = tt, Xd = Wd("".charAt), $d = Wd("".charCodeAt), Kd = Wd("".slice), Qd = function(e) {
        return function(t, n) {
            var r, o, a = Yd(qd(t)), i = Vd(n), c = a.length;
            return i < 0 || i >= c ? e ? "" : void 0 : (r = $d(a, i)) < 55296 || r > 56319 || i + 1 === c || (o = $d(a, i + 1)) < 56320 || o > 57343 ? e ? Xd(a, i) : r : e ? Kd(a, i, i + 2) : o - 56320 + (r - 55296 << 10) + 65536;
        };
    }, Jd = {
        codeAt: Qd(!1),
        charAt: Qd(!0)
    }.charAt, Zd = Pi, em = Nc, tm = yu, nm = bu, rm = "String Iterator", om = em.set, am = em.getterFor(rm);
    tm(String, "String", function(e) {
        om(this, {
            type: rm,
            string: Zd(e),
            index: 0
        });
    }, function() {
        var e, t = am(this), n = t.string, r = t.index;
        return r >= n.length ? nm(void 0, !0) : (e = Jd(n, r), t.index += e.length, nm(e, !1));
    });
    var im = ct.Promise, cm = {
        CSSRuleList: 0,
        CSSStyleDeclaration: 0,
        CSSValueList: 0,
        ClientRectList: 0,
        DOMRectList: 0,
        DOMStringList: 0,
        DOMTokenList: 1,
        DataTransferItemList: 0,
        FileList: 0,
        HTMLAllCollection: 0,
        HTMLCollection: 0,
        HTMLFormElement: 0,
        HTMLSelectElement: 0,
        MediaList: 0,
        MimeTypeArray: 0,
        NamedNodeMap: 0,
        NodeList: 1,
        PaintRequestList: 0,
        Plugin: 0,
        PluginArray: 0,
        SVGLengthList: 0,
        SVGNumberList: 0,
        SVGPathSegList: 0,
        SVGPointList: 0,
        SVGStringList: 0,
        SVGTransformList: 0,
        SourceBufferList: 0,
        StyleSheetList: 0,
        TextTrackCueList: 0,
        TextTrackList: 0,
        TouchList: 0
    }, um = me, lm = $c, sm = Ga;
    for(var fm in cm)lm(um[fm], fm), sm[fm] = sm.Array;
    var dm = se(im);
    function mm(e, t) {
        return new dm(function(n, r) {
            var o = document.createElement("script");
            o.async = !0, o.crossOrigin = "anonymous";
            var a = function() {
                o.parentNode && o.parentNode.removeChild(o), t && window[t] && delete window[t];
            };
            o.onload = function() {
                n(window[t]), a();
            }, o.onerror = function() {
                r(new Error("Failed to import: ".concat(e))), a();
            }, o.src = e, document.head.appendChild(o);
        });
    }
    function pm(e, t, n, r) {
        var a = o.default.lazy(function() {
            return mm(e, t).then(function(e) {
                if (!e.default) throw new Error("Failed to import ".concat(t, " component: no default export"));
                return a.WrappedComponent = e.default || e, n && n(), e;
            }).catch(function(e) {
                return r && r(e), {
                    default: function() {
                        return o.default.createElement(o.default.Fragment, null);
                    }
                };
            });
        });
        return a;
    }
    function vm(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : document.body, n = document.createElement("div");
        t.appendChild(n);
        var r = o.default.cloneElement(e, {
            onUnmount: function() {
                n && (a.default.unmountComponentAtNode(n), n.parentNode && n.parentNode.removeChild(n));
            }
        });
        return a.default.render(r, n), n;
    }
    function hm(e) {
        var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "click", r = t.useRef();
        return t.useEffect({
            "hm.useEffect": function() {
                var t = {
                    "hm.useEffect.t": function(t) {
                        var n = r.current;
                        n && !n.contains(t.target) && e && e(t);
                    }
                }["hm.useEffect.t"];
                return document.addEventListener(n, t), ({
                    "hm.useEffect": function() {
                        document.removeEventListener(n, t);
                    }
                })["hm.useEffect"];
            }
        }["hm.useEffect"], [
            n,
            e
        ]), r;
    }
    function gm(e) {
        var n = t.useRef(null);
        return t.useEffect({
            "gm.useEffect": function() {
                e && ("function" == typeof e ? e(n.current) : e.current = n.current);
            }
        }["gm.useEffect"], [
            e
        ]), n;
    }
    function ym(e) {
        var n = t.useRef(e);
        return n.current = e, n;
    }
    var bm = function(e) {
        return e && e.Math === Math && e;
    }, Em = bm("object" == typeof globalThis && globalThis) || bm("object" == typeof window && window) || bm("object" == typeof self && self) || bm("object" == typeof le && le) || bm("object" == typeof le && le) || function() {
        return this;
    }() || Function("return this")(), wm = {
        exports: {}
    }, Nm = Em, Sm = Object.defineProperty, Tm = function(e, t) {
        try {
            Sm(Nm, e, {
                value: t,
                configurable: !0,
                writable: !0
            });
        } catch (n) {
            Nm[e] = t;
        }
        return t;
    }, Cm = Em, Om = Tm, Rm = "__core-js_shared__", xm = wm.exports = Cm[Rm] || Om(Rm, {});
    (xm.versions || (xm.versions = [])).push({
        version: "3.41.0",
        mode: "global",
        copyright: "© 2014-2025 Denis Pushkarev (zloirock.ru)",
        license: "https://github.com/zloirock/core-js/blob/v3.41.0/LICENSE",
        source: "https://github.com/zloirock/core-js"
    });
    var km, Am, Im = wm.exports, Mm = Im, _m = function(e, t) {
        return Mm[e] || (Mm[e] = t || {});
    }, Lm = function(e) {
        try {
            return !!e();
        } catch (e) {
            return !0;
        }
    }, jm = !Lm(function() {
        var e = (function() {}).bind();
        return "function" != typeof e || e.hasOwnProperty("prototype");
    }), Pm = jm, Dm = Function.prototype, Fm = Dm.call, Bm = Pm && Dm.bind.bind(Fm, Fm), Hm = Pm ? Bm : function(e) {
        return function() {
            return Fm.apply(e, arguments);
        };
    }, Um = function(e) {
        return null == e;
    }, zm = Um, Gm = TypeError, Wm = function(e) {
        if (zm(e)) throw new Gm("Can't call method on " + e);
        return e;
    }, Vm = Wm, Ym = Object, qm = function(e) {
        return Ym(Vm(e));
    }, Xm = qm, $m = Hm({}.hasOwnProperty), Km = Object.hasOwn || function(e, t) {
        return $m(Xm(e), t);
    }, Qm = Hm, Jm = 0, Zm = Math.random(), ep = Qm(1..toString), tp = function(e) {
        return "Symbol(" + (void 0 === e ? "" : e) + ")_" + ep(++Jm + Zm, 36);
    }, np = Em.navigator, rp = np && np.userAgent, op = rp ? String(rp) : "", ap = Em, ip = op, cp = ap.process, up = ap.Deno, lp = cp && cp.versions || up && up.version, sp = lp && lp.v8;
    sp && (Am = (km = sp.split("."))[0] > 0 && km[0] < 4 ? 1 : +(km[0] + km[1])), !Am && ip && (!(km = ip.match(/Edge\/(\d+)/)) || km[1] >= 74) && (km = ip.match(/Chrome\/(\d+)/)) && (Am = +km[1]);
    var fp = Am, dp = fp, mp = Lm, pp = Em.String, vp = !!Object.getOwnPropertySymbols && !mp(function() {
        var e = Symbol("symbol detection");
        return !pp(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && dp && dp < 41;
    }), hp = vp && !Symbol.sham && "symbol" == typeof Symbol.iterator, gp = _m, yp = Km, bp = tp, Ep = vp, wp = hp, Np = Em.Symbol, Sp = gp("wks"), Tp = wp ? Np.for || Np : Np && Np.withoutSetter || bp, Cp = function(e) {
        return yp(Sp, e) || (Sp[e] = Ep && yp(Np, e) ? Np[e] : Tp("Symbol." + e)), Sp[e];
    }, Op = {};
    Op[Cp("toStringTag")] = "z";
    var Rp = "[object z]" === String(Op), xp = "object" == typeof document && document.all, kp = void 0 === xp && void 0 !== xp ? function(e) {
        return "function" == typeof e || e === xp;
    } : function(e) {
        return "function" == typeof e;
    }, Ap = {}, Ip = !Lm(function() {
        return 7 !== Object.defineProperty({}, 1, {
            get: function() {
                return 7;
            }
        })[1];
    }), Mp = kp, _p = function(e) {
        return "object" == typeof e ? null !== e : Mp(e);
    }, Lp = _p, jp = Em.document, Pp = Lp(jp) && Lp(jp.createElement), Dp = function(e) {
        return Pp ? jp.createElement(e) : {};
    }, Fp = Dp, Bp = !Ip && !Lm(function() {
        return 7 !== Object.defineProperty(Fp("div"), "a", {
            get: function() {
                return 7;
            }
        }).a;
    }), Hp = Ip && Lm(function() {
        return 42 !== Object.defineProperty(function() {}, "prototype", {
            value: 42,
            writable: !1
        }).prototype;
    }), Up = _p, zp = String, Gp = TypeError, Wp = function(e) {
        if (Up(e)) return e;
        throw new Gp(zp(e) + " is not an object");
    }, Vp = jm, Yp = Function.prototype.call, qp = Vp ? Yp.bind(Yp) : function() {
        return Yp.apply(Yp, arguments);
    }, Xp = Em, $p = kp, Kp = function(e, t) {
        return arguments.length < 2 ? (n = Xp[e], $p(n) ? n : void 0) : Xp[e] && Xp[e][t];
        "TURBOPACK unreachable";
        var n;
    }, Qp = Hm({}.isPrototypeOf), Jp = Kp, Zp = kp, ev = Qp, tv = Object, nv = hp ? function(e) {
        return "symbol" == typeof e;
    } : function(e) {
        var t = Jp("Symbol");
        return Zp(t) && ev(t.prototype, tv(e));
    }, rv = String, ov = function(e) {
        try {
            return rv(e);
        } catch (e) {
            return "Object";
        }
    }, av = kp, iv = ov, cv = TypeError, uv = function(e) {
        if (av(e)) return e;
        throw new cv(iv(e) + " is not a function");
    }, lv = uv, sv = Um, fv = function(e, t) {
        var n = e[t];
        return sv(n) ? void 0 : lv(n);
    }, dv = qp, mv = kp, pv = _p, vv = TypeError, hv = qp, gv = _p, yv = nv, bv = fv, Ev = function(e, t) {
        var n, r;
        if ("string" === t && mv(n = e.toString) && !pv(r = dv(n, e))) return r;
        if (mv(n = e.valueOf) && !pv(r = dv(n, e))) return r;
        if ("string" !== t && mv(n = e.toString) && !pv(r = dv(n, e))) return r;
        throw new vv("Can't convert object to primitive value");
    }, wv = TypeError, Nv = Cp("toPrimitive"), Sv = function(e, t) {
        if (!gv(e) || yv(e)) return e;
        var n, r = bv(e, Nv);
        if (r) {
            if (void 0 === t && (t = "default"), n = hv(r, e, t), !gv(n) || yv(n)) return n;
            throw new wv("Can't convert object to primitive value");
        }
        return void 0 === t && (t = "number"), Ev(e, t);
    }, Tv = Sv, Cv = nv, Ov = function(e) {
        var t = Tv(e, "string");
        return Cv(t) ? t : t + "";
    }, Rv = Ip, xv = Bp, kv = Hp, Av = Wp, Iv = Ov, Mv = TypeError, _v = Object.defineProperty, Lv = Object.getOwnPropertyDescriptor, jv = "enumerable", Pv = "configurable", Dv = "writable";
    Ap.f = Rv ? kv ? function(e, t, n) {
        if (Av(e), t = Iv(t), Av(n), "function" == typeof e && "prototype" === t && "value" in n && Dv in n && !n[Dv]) {
            var r = Lv(e, t);
            r && r[Dv] && (e[t] = n.value, n = {
                configurable: Pv in n ? n[Pv] : r[Pv],
                enumerable: jv in n ? n[jv] : r[jv],
                writable: !1
            });
        }
        return _v(e, t, n);
    } : _v : function(e, t, n) {
        if (Av(e), t = Iv(t), Av(n), xv) try {
            return _v(e, t, n);
        } catch (e) {}
        if ("get" in n || "set" in n) throw new Mv("Accessors not supported");
        return "value" in n && (e[t] = n.value), e;
    };
    var Fv = {
        exports: {}
    }, Bv = Ip, Hv = Km, Uv = Function.prototype, zv = Bv && Object.getOwnPropertyDescriptor, Gv = Hv(Uv, "name"), Wv = {
        EXISTS: Gv,
        PROPER: Gv && "something" === (function() {}).name,
        CONFIGURABLE: Gv && (!Bv || Bv && zv(Uv, "name").configurable)
    }, Vv = kp, Yv = Im, qv = Hm(Function.toString);
    Vv(Yv.inspectSource) || (Yv.inspectSource = function(e) {
        return qv(e);
    });
    var Xv, $v, Kv, Qv = Yv.inspectSource, Jv = kp, Zv = Em.WeakMap, eh = Jv(Zv) && /native code/.test(String(Zv)), th = function(e, t) {
        return {
            enumerable: !(1 & e),
            configurable: !(2 & e),
            writable: !(4 & e),
            value: t
        };
    }, nh = Ap, rh = th, oh = Ip ? function(e, t, n) {
        return nh.f(e, t, rh(1, n));
    } : function(e, t, n) {
        return e[t] = n, e;
    }, ah = tp, ih = _m("keys"), ch = function(e) {
        return ih[e] || (ih[e] = ah(e));
    }, uh = {}, lh = eh, sh = Em, fh = _p, dh = oh, mh = Km, ph = Im, vh = ch, hh = uh, gh = "Object already initialized", yh = sh.TypeError, bh = sh.WeakMap;
    if (lh || ph.state) {
        var Eh = ph.state || (ph.state = new bh);
        Eh.get = Eh.get, Eh.has = Eh.has, Eh.set = Eh.set, Xv = function(e, t) {
            if (Eh.has(e)) throw new yh(gh);
            return t.facade = e, Eh.set(e, t), t;
        }, $v = function(e) {
            return Eh.get(e) || {};
        }, Kv = function(e) {
            return Eh.has(e);
        };
    } else {
        var wh = vh("state");
        hh[wh] = !0, Xv = function(e, t) {
            if (mh(e, wh)) throw new yh(gh);
            return t.facade = e, dh(e, wh, t), t;
        }, $v = function(e) {
            return mh(e, wh) ? e[wh] : {};
        }, Kv = function(e) {
            return mh(e, wh);
        };
    }
    var Nh = {
        set: Xv,
        get: $v,
        has: Kv,
        enforce: function(e) {
            return Kv(e) ? $v(e) : Xv(e, {});
        },
        getterFor: function(e) {
            return function(t) {
                var n;
                if (!fh(t) || (n = $v(t)).type !== e) throw new yh("Incompatible receiver, " + e + " required");
                return n;
            };
        }
    }, Sh = Hm, Th = Lm, Ch = kp, Oh = Km, Rh = Ip, xh = Wv.CONFIGURABLE, kh = Qv, Ah = Nh.enforce, Ih = Nh.get, Mh = String, _h = Object.defineProperty, Lh = Sh("".slice), jh = Sh("".replace), Ph = Sh([].join), Dh = Rh && !Th(function() {
        return 8 !== _h(function() {}, "length", {
            value: 8
        }).length;
    }), Fh = String(String).split("String"), Bh = Fv.exports = function(e, t, n) {
        "Symbol(" === Lh(Mh(t), 0, 7) && (t = "[" + jh(Mh(t), /^Symbol\(([^)]*)\).*$/, "$1") + "]"), n && n.getter && (t = "get " + t), n && n.setter && (t = "set " + t), (!Oh(e, "name") || xh && e.name !== t) && (Rh ? _h(e, "name", {
            value: t,
            configurable: !0
        }) : e.name = t), Dh && n && Oh(n, "arity") && e.length !== n.arity && _h(e, "length", {
            value: n.arity
        });
        try {
            n && Oh(n, "constructor") && n.constructor ? Rh && _h(e, "prototype", {
                writable: !1
            }) : e.prototype && (e.prototype = void 0);
        } catch (e) {}
        var r = Ah(e);
        return Oh(r, "source") || (r.source = Ph(Fh, "string" == typeof t ? t : "")), e;
    };
    Function.prototype.toString = Bh(function() {
        return Ch(this) && Ih(this).source || kh(this);
    }, "toString");
    var Hh = Fv.exports, Uh = kp, zh = Ap, Gh = Hh, Wh = Tm, Vh = function(e, t, n, r) {
        r || (r = {});
        var o = r.enumerable, a = void 0 !== r.name ? r.name : t;
        if (Uh(n) && Gh(n, a, r), r.global) o ? e[t] = n : Wh(t, n);
        else {
            try {
                r.unsafe ? e[t] && (o = !0) : delete e[t];
            } catch (e) {}
            o ? e[t] = n : zh.f(e, t, {
                value: n,
                enumerable: !1,
                configurable: !r.nonConfigurable,
                writable: !r.nonWritable
            });
        }
        return e;
    }, Yh = Hm, qh = Yh({}.toString), Xh = Yh("".slice), $h = function(e) {
        return Xh(qh(e), 8, -1);
    }, Kh = Rp, Qh = kp, Jh = $h, Zh = Cp("toStringTag"), eg = Object, tg = "Arguments" === Jh(function() {
        return arguments;
    }()), ng = Kh ? Jh : function(e) {
        var t, n, r;
        return void 0 === e ? "Undefined" : null === e ? "Null" : "string" == typeof (n = function(e, t) {
            try {
                return e[t];
            } catch (e) {}
        }(t = eg(e), Zh)) ? n : tg ? Jh(t) : "Object" === (r = Jh(t)) && Qh(t.callee) ? "Arguments" : r;
    }, rg = ng, og = Rp ? ({}).toString : function() {
        return "[object " + rg(this) + "]";
    };
    Rp || Vh(Object.prototype, "toString", og, {
        unsafe: !0
    });
    var ag = Dp("span").classList, ig = ag && ag.constructor && ag.constructor.prototype, cg = ig === Object.prototype ? void 0 : ig, ug = $h, lg = Hm, sg = function(e) {
        if ("Function" === ug(e)) return lg(e);
    }, fg = uv, dg = jm, mg = sg(sg.bind), pg = function(e, t) {
        return fg(e), void 0 === t ? e : dg ? mg(e, t) : function() {
            return e.apply(t, arguments);
        };
    }, vg = Lm, hg = $h, gg = Object, yg = Hm("".split), bg = vg(function() {
        return !gg("z").propertyIsEnumerable(0);
    }) ? function(e) {
        return "String" === hg(e) ? yg(e, "") : gg(e);
    } : gg, Eg = Math.ceil, wg = Math.floor, Ng = Math.trunc || function(e) {
        var t = +e;
        return (t > 0 ? wg : Eg)(t);
    }, Sg = function(e) {
        var t = +e;
        return t != t || 0 === t ? 0 : Ng(t);
    }, Tg = Sg, Cg = Math.min, Og = function(e) {
        var t = Tg(e);
        return t > 0 ? Cg(t, 9007199254740991) : 0;
    }, Rg = Og, xg = function(e) {
        return Rg(e.length);
    }, kg = $h, Ag = Array.isArray || function(e) {
        return "Array" === kg(e);
    }, Ig = Hm, Mg = Lm, _g = kp, Lg = ng, jg = Qv, Pg = function() {}, Dg = Kp("Reflect", "construct"), Fg = /^\s*(?:class|function)\b/, Bg = Ig(Fg.exec), Hg = !Fg.test(Pg), Ug = function(e) {
        if (!_g(e)) return !1;
        try {
            return Dg(Pg, [], e), !0;
        } catch (e) {
            return !1;
        }
    }, zg = function(e) {
        if (!_g(e)) return !1;
        switch(Lg(e)){
            case "AsyncFunction":
            case "GeneratorFunction":
            case "AsyncGeneratorFunction":
                return !1;
        }
        try {
            return Hg || !!Bg(Fg, jg(e));
        } catch (e) {
            return !0;
        }
    };
    zg.sham = !0;
    var Gg = !Dg || Mg(function() {
        var e;
        return Ug(Ug.call) || !Ug(Object) || !Ug(function() {
            e = !0;
        }) || e;
    }) ? zg : Ug, Wg = Ag, Vg = Gg, Yg = _p, qg = Cp("species"), Xg = Array, $g = function(e) {
        var t;
        return Wg(e) && (t = e.constructor, (Vg(t) && (t === Xg || Wg(t.prototype)) || Yg(t) && null === (t = t[qg])) && (t = void 0)), void 0 === t ? Xg : t;
    }, Kg = pg, Qg = bg, Jg = qm, Zg = xg, ey = function(e, t) {
        return new ($g(e))(0 === t ? 0 : t);
    }, ty = Hm([].push), ny = function(e) {
        var t = 1 === e, n = 2 === e, r = 3 === e, o = 4 === e, a = 6 === e, i = 7 === e, c = 5 === e || a;
        return function(u, l, s, f) {
            for(var d, m, p = Jg(u), v = Qg(p), h = Zg(v), g = Kg(l, s), y = 0, b = f || ey, E = t ? b(u, h) : n || i ? b(u, 0) : void 0; h > y; y++)if ((c || y in v) && (m = g(d = v[y], y, p), e)) if (t) E[y] = m;
            else if (m) switch(e){
                case 3:
                    return !0;
                case 5:
                    return d;
                case 6:
                    return y;
                case 2:
                    ty(E, d);
            }
            else switch(e){
                case 4:
                    return !1;
                case 7:
                    ty(E, d);
            }
            return a ? -1 : r || o ? o : E;
        };
    }, ry = {
        forEach: ny(0),
        map: ny(1),
        filter: ny(2),
        some: ny(3),
        every: ny(4),
        find: ny(5),
        findIndex: ny(6),
        filterReject: ny(7)
    }, oy = Lm, ay = ry.forEach, iy = function(e, t) {
        var n = [][e];
        return !!n && oy(function() {
            n.call(null, t || function() {
                return 1;
            }, 1);
        });
    }, cy = iy("forEach") ? [].forEach : function(e) {
        return ay(this, e, arguments.length > 1 ? arguments[1] : void 0);
    }, uy = Em, ly = {
        CSSRuleList: 0,
        CSSStyleDeclaration: 0,
        CSSValueList: 0,
        ClientRectList: 0,
        DOMRectList: 0,
        DOMStringList: 0,
        DOMTokenList: 1,
        DataTransferItemList: 0,
        FileList: 0,
        HTMLAllCollection: 0,
        HTMLCollection: 0,
        HTMLFormElement: 0,
        HTMLSelectElement: 0,
        MediaList: 0,
        MimeTypeArray: 0,
        NamedNodeMap: 0,
        NodeList: 1,
        PaintRequestList: 0,
        Plugin: 0,
        PluginArray: 0,
        SVGLengthList: 0,
        SVGNumberList: 0,
        SVGPathSegList: 0,
        SVGPointList: 0,
        SVGStringList: 0,
        SVGTransformList: 0,
        SourceBufferList: 0,
        StyleSheetList: 0,
        TextTrackCueList: 0,
        TextTrackList: 0,
        TouchList: 0
    }, sy = cg, fy = cy, dy = oh, my = function(e) {
        if (e && e.forEach !== fy) try {
            dy(e, "forEach", fy);
        } catch (t) {
            e.forEach = fy;
        }
    };
    for(var py in ly)ly[py] && my(uy[py] && uy[py].prototype);
    my(sy);
    var vy = an, hy = ca;
    Br({
        target: "Object",
        stat: !0,
        forced: pe(function() {
            hy(1);
        })
    }, {
        keys: function(e) {
            return hy(vy(e));
        }
    });
    var gy = se(ct.Object.keys), yy = {}, by = ke, Ey = ot, wy = bo.f, Ny = bl, Sy = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
    yy.f = function(e) {
        return Sy && "Window" === by(e) ? function(e) {
            try {
                return wy(e);
            } catch (e) {
                return Ny(Sy);
            }
        }(e) : wy(Ey(e));
    };
    var Ty = {}, Cy = Sn;
    Ty.f = Cy;
    var Oy = ct, Ry = ln, xy = Ty, ky = ur.f, Ay = function(e) {
        var t = Oy.Symbol || (Oy.Symbol = {});
        Ry(t, e) || ky(t, e, {
            value: xy.f(e)
        });
    }, Iy = Be, My = dt, _y = Sn, Ly = Ac, jy = function() {
        var e = My("Symbol"), t = e && e.prototype, n = t && t.valueOf, r = _y("toPrimitive");
        t && !t[r] && Ly(t, r, function(e) {
            return Iy(n, this);
        }, {
            arity: 1
        });
    }, Py = ke, Dy = Array.isArray || function(e) {
        return "Array" === Py(e);
    }, Fy = Dy, By = ll, Hy = it, Uy = Sn("species"), zy = Array, Gy = function(e) {
        var t;
        return Fy(e) && (t = e.constructor, (By(t) && (t === zy || Fy(t.prototype)) || Hy(t) && null === (t = t[Uy])) && (t = void 0)), void 0 === t ? zy : t;
    }, Wy = function(e, t) {
        return new (Gy(e))(0 === t ? 0 : t);
    }, Vy = cr, Yy = Qe, qy = an, Xy = Io, $y = Wy, Ky = Ce([].push), Qy = function(e) {
        var t = 1 === e, n = 2 === e, r = 3 === e, o = 4 === e, a = 6 === e, i = 7 === e, c = 5 === e || a;
        return function(u, l, s, f) {
            for(var d, m, p = qy(u), v = Yy(p), h = Xy(v), g = Vy(l, s), y = 0, b = f || $y, E = t ? b(u, h) : n || i ? b(u, 0) : void 0; h > y; y++)if ((c || y in v) && (m = g(d = v[y], y, p), e)) if (t) E[y] = m;
            else if (m) switch(e){
                case 3:
                    return !0;
                case 5:
                    return d;
                case 6:
                    return y;
                case 2:
                    Ky(E, d);
            }
            else switch(e){
                case 4:
                    return !1;
                case 7:
                    Ky(E, d);
            }
            return a ? -1 : r || o ? o : E;
        };
    }, Jy = {
        forEach: Qy(0),
        map: Qy(1),
        filter: Qy(2),
        some: Qy(3),
        every: Qy(4),
        find: Qy(5),
        findIndex: Qy(6),
        filterReject: Qy(7)
    }, Zy = Br, eb = me, tb = Be, nb = Ce, rb = Pe, ob = Rt, ab = pe, ib = ln, cb = mt, ub = mr, lb = ot, sb = _n, fb = Pi, db = Ye, mb = ka, pb = ca, vb = bo, hb = yy, gb = qo, yb = je, bb = ur, Eb = oa, wb = He, Nb = Ac, Sb = Pu, Tb = nn, Cb = Do, Ob = pn, Rb = Sn, xb = Ty, kb = Ay, Ab = jy, Ib = $c, Mb = Nc, _b = Jy.forEach, Lb = Qr("hidden"), jb = "Symbol", Pb = "prototype", Db = Mb.set, Fb = Mb.getterFor(jb), Bb = Object[Pb], Hb = eb.Symbol, Ub = Hb && Hb[Pb], zb = eb.RangeError, Gb = eb.TypeError, Wb = eb.QObject, Vb = yb.f, Yb = bb.f, qb = hb.f, Xb = wb.f, $b = nb([].push), Kb = Tb("symbols"), Qb = Tb("op-symbols"), Jb = Tb("wks"), Zb = !Wb || !Wb[Pb] || !Wb[Pb].findChild, eE = function(e, t, n) {
        var r = Vb(Bb, t);
        r && delete Bb[t], Yb(e, t, n), r && e !== Bb && Yb(Bb, t, r);
    }, tE = rb && ab(function() {
        return 7 !== mb(Yb({}, "a", {
            get: function() {
                return Yb(this, "a", {
                    value: 7
                }).a;
            }
        })).a;
    }) ? eE : Yb, nE = function(e, t) {
        var n = Kb[e] = mb(Ub);
        return Db(n, {
            type: jb,
            tag: e,
            description: t
        }), rb || (n.description = t), n;
    }, rE = function(e, t, n) {
        e === Bb && rE(Qb, t, n), ub(e);
        var r = sb(t);
        return ub(n), ib(Kb, r) ? (n.enumerable ? (ib(e, Lb) && e[Lb][r] && (e[Lb][r] = !1), n = mb(n, {
            enumerable: db(0, !1)
        })) : (ib(e, Lb) || Yb(e, Lb, db(1, mb(null))), e[Lb][r] = !0), tE(e, r, n)) : Yb(e, r, n);
    }, oE = function(e, t) {
        ub(e);
        var n = lb(t), r = pb(n).concat(uE(n));
        return _b(r, function(t) {
            rb && !tb(aE, n, t) || rE(e, t, n[t]);
        }), e;
    }, aE = function(e) {
        var t = sb(e), n = tb(Xb, this, t);
        return !(this === Bb && ib(Kb, t) && !ib(Qb, t)) && (!(n || !ib(this, t) || !ib(Kb, t) || ib(this, Lb) && this[Lb][t]) || n);
    }, iE = function(e, t) {
        var n = lb(e), r = sb(t);
        if (n !== Bb || !ib(Kb, r) || ib(Qb, r)) {
            var o = Vb(n, r);
            return !o || !ib(Kb, r) || ib(n, Lb) && n[Lb][r] || (o.enumerable = !0), o;
        }
    }, cE = function(e) {
        var t = qb(lb(e)), n = [];
        return _b(t, function(e) {
            ib(Kb, e) || ib(Cb, e) || $b(n, e);
        }), n;
    }, uE = function(e) {
        var t = e === Bb, n = qb(t ? Qb : lb(e)), r = [];
        return _b(n, function(e) {
            !ib(Kb, e) || t && !ib(Bb, e) || $b(r, Kb[e]);
        }), r;
    };
    ob || (Hb = function() {
        if (cb(Ub, this)) throw new Gb("Symbol is not a constructor");
        var e = arguments.length && void 0 !== arguments[0] ? fb(arguments[0]) : void 0, t = Ob(e), n = function(e) {
            var r = void 0 === this ? eb : this;
            r === Bb && tb(n, Qb, e), ib(r, Lb) && ib(r[Lb], t) && (r[Lb][t] = !1);
            var o = db(1, e);
            try {
                tE(r, t, o);
            } catch (e) {
                if (!(e instanceof zb)) throw e;
                eE(r, t, o);
            }
        };
        return rb && Zb && tE(Bb, t, {
            configurable: !0,
            set: n
        }), nE(t, e);
    }, Nb(Ub = Hb[Pb], "toString", function() {
        return Fb(this).tag;
    }), Nb(Hb, "withoutSetter", function(e) {
        return nE(Ob(e), e);
    }), wb.f = aE, bb.f = rE, Eb.f = oE, yb.f = iE, vb.f = hb.f = cE, gb.f = uE, xb.f = function(e) {
        return nE(Rb(e), e);
    }, rb && Sb(Ub, "description", {
        configurable: !0,
        get: function() {
            return Fb(this).description;
        }
    })), Zy({
        global: !0,
        constructor: !0,
        wrap: !0,
        forced: !ob,
        sham: !ob
    }, {
        Symbol: Hb
    }), _b(pb(Jb), function(e) {
        kb(e);
    }), Zy({
        target: jb,
        stat: !0,
        forced: !ob
    }, {
        useSetter: function() {
            Zb = !0;
        },
        useSimple: function() {
            Zb = !1;
        }
    }), Zy({
        target: "Object",
        stat: !0,
        forced: !ob,
        sham: !rb
    }, {
        create: function(e, t) {
            return void 0 === t ? mb(e) : oE(mb(e), t);
        },
        defineProperty: rE,
        defineProperties: oE,
        getOwnPropertyDescriptor: iE
    }), Zy({
        target: "Object",
        stat: !0,
        forced: !ob
    }, {
        getOwnPropertyNames: cE
    }), Ab(), Ib(Hb, jb), Cb[Lb] = !0;
    var lE = Rt && !!Symbol.for && !!Symbol.keyFor, sE = Br, fE = dt, dE = ln, mE = Pi, pE = nn, vE = lE, hE = pE("string-to-symbol-registry"), gE = pE("symbol-to-string-registry");
    sE({
        target: "Symbol",
        stat: !0,
        forced: !vE
    }, {
        for: function(e) {
            var t = mE(e);
            if (dE(hE, t)) return hE[t];
            var n = fE("Symbol")(t);
            return hE[t] = n, gE[n] = t, n;
        }
    });
    var yE = Br, bE = ln, EE = _t, wE = jt, NE = lE, SE = nn("symbol-to-string-registry");
    yE({
        target: "Symbol",
        stat: !0,
        forced: !NE
    }, {
        keyFor: function(e) {
            if (!EE(e)) throw new TypeError(wE(e) + " is not a symbol");
            if (bE(SE, e)) return SE[e];
        }
    });
    var TE = Dy, CE = Le, OE = ke, RE = Pi, xE = Ce([].push), kE = Br, AE = dt, IE = Ee, ME = Be, _E = Ce, LE = pe, jE = Le, PE = _t, DE = bl, FE = function(e) {
        if (CE(e)) return e;
        if (TE(e)) {
            for(var t = e.length, n = [], r = 0; r < t; r++){
                var o = e[r];
                "string" == typeof o ? xE(n, o) : "number" != typeof o && "Number" !== OE(o) && "String" !== OE(o) || xE(n, RE(o));
            }
            var a = n.length, i = !0;
            return function(e, t) {
                if (i) return i = !1, t;
                if (TE(this)) return t;
                for(var r = 0; r < a; r++)if (n[r] === e) return t;
            };
        }
    }, BE = Rt, HE = String, UE = AE("JSON", "stringify"), zE = _E(/./.exec), GE = _E("".charAt), WE = _E("".charCodeAt), VE = _E("".replace), YE = _E(1..toString), qE = /[\uD800-\uDFFF]/g, XE = /^[\uD800-\uDBFF]$/, $E = /^[\uDC00-\uDFFF]$/, KE = !BE || LE(function() {
        var e = AE("Symbol")("stringify detection");
        return "[null]" !== UE([
            e
        ]) || "{}" !== UE({
            a: e
        }) || "{}" !== UE(Object(e));
    }), QE = LE(function() {
        return '"\\udf06\\ud834"' !== UE("\udf06\ud834") || '"\\udead"' !== UE("\udead");
    }), JE = function(e, t) {
        var n = DE(arguments), r = FE(t);
        if (jE(r) || void 0 !== e && !PE(e)) return n[1] = function(e, t) {
            if (jE(r) && (t = ME(r, this, HE(e), t)), !PE(t)) return t;
        }, IE(UE, null, n);
    }, ZE = function(e, t, n) {
        var r = GE(n, t - 1), o = GE(n, t + 1);
        return zE(XE, e) && !zE($E, o) || zE($E, e) && !zE(XE, r) ? "\\u" + YE(WE(e, 0), 16) : e;
    };
    UE && kE({
        target: "JSON",
        stat: !0,
        arity: 3,
        forced: KE || QE
    }, {
        stringify: function(e, t, n) {
            var r = DE(arguments), o = IE(KE ? JE : UE, null, r);
            return QE && "string" == typeof o ? VE(o, qE, ZE) : o;
        }
    });
    var ew = qo, tw = an;
    Br({
        target: "Object",
        stat: !0,
        forced: !Rt || pe(function() {
            ew.f(1);
        })
    }, {
        getOwnPropertySymbols: function(e) {
            var t = ew.f;
            return t ? t(tw(e)) : [];
        }
    });
    var nw = ct.Object.getOwnPropertySymbols, rw = se(nw), ow = {
        exports: {}
    }, aw = Br, iw = pe, cw = ot, uw = je.f, lw = Pe;
    aw({
        target: "Object",
        stat: !0,
        forced: !lw || iw(function() {
            uw(1);
        }),
        sham: !lw
    }, {
        getOwnPropertyDescriptor: function(e, t) {
            return uw(cw(e), t);
        }
    });
    var sw = ct.Object, fw = ow.exports = function(e, t) {
        return sw.getOwnPropertyDescriptor(e, t);
    };
    sw.getOwnPropertyDescriptor.sham && (fw.sham = !0);
    var dw = se(ow.exports), mw = Pe, pw = ur, vw = Ye, hw = function(e, t, n) {
        mw ? pw.f(e, t, vw(0, n)) : e[t] = n;
    }, gw = Zo, yw = ot, bw = je, Ew = hw;
    Br({
        target: "Object",
        stat: !0,
        sham: !Pe
    }, {
        getOwnPropertyDescriptors: function(e) {
            for(var t, n, r = yw(e), o = bw.f, a = gw(r), i = {}, c = 0; a.length > c;)void 0 !== (n = o(r, t = a[c++])) && Ew(i, t, n);
            return i;
        }
    });
    var ww = se(ct.Object.getOwnPropertyDescriptors), Nw = {
        exports: {}
    }, Sw = Br, Tw = Pe, Cw = oa.f;
    Sw({
        target: "Object",
        stat: !0,
        forced: Object.defineProperties !== Cw,
        sham: !Tw
    }, {
        defineProperties: Cw
    });
    var Ow = ct.Object, Rw = Nw.exports = function(e, t) {
        return Ow.defineProperties(e, t);
    };
    Ow.defineProperties.sham && (Rw.sham = !0);
    var xw = se(Nw.exports);
    Br({
        target: "Array",
        stat: !0
    }, {
        isArray: Dy
    });
    var kw = se(ct.Array.isArray);
    function Aw(e, t) {
        (null == t || t > e.length) && (t = e.length);
        for(var n = 0, r = Array(t); n < t; n++)r[n] = e[n];
        return r;
    }
    var Iw = TypeError, Mw = function(e) {
        if (e > 9007199254740991) throw Iw("Maximum allowed index exceeded");
        return e;
    }, _w = pe, Lw = St, jw = Sn("species"), Pw = function(e) {
        return Lw >= 51 || !_w(function() {
            var t = [];
            return (t.constructor = {})[jw] = function() {
                return {
                    foo: 1
                };
            }, 1 !== t[e](Boolean).foo;
        });
    }, Dw = Br, Fw = pe, Bw = Dy, Hw = it, Uw = an, zw = Io, Gw = Mw, Ww = hw, Vw = Wy, Yw = Pw, qw = St, Xw = Sn("isConcatSpreadable"), $w = qw >= 51 || !Fw(function() {
        var e = [];
        return e[Xw] = !1, e.concat()[0] !== e;
    }), Kw = function(e) {
        if (!Hw(e)) return !1;
        var t = e[Xw];
        return void 0 !== t ? !!t : Bw(e);
    };
    Dw({
        target: "Array",
        proto: !0,
        arity: 1,
        forced: !$w || !Yw("concat")
    }, {
        concat: function(e) {
            var t, n, r, o, a, i = Uw(this), c = Vw(i, 0), u = 0;
            for(t = -1, r = arguments.length; t < r; t++)if (Kw(a = -1 === t ? i : arguments[t])) for(o = zw(a), Gw(u + o), n = 0; n < o; n++, u++)n in a && Ww(c, u, a[n]);
            else Gw(u + 1), Ww(c, u++, a);
            return c.length = u, c;
        }
    }), Ay("asyncIterator"), Ay("hasInstance"), Ay("isConcatSpreadable"), Ay("iterator"), Ay("match"), Ay("matchAll"), Ay("replace"), Ay("search"), Ay("species"), Ay("split");
    var Qw = jy;
    Ay("toPrimitive"), Qw();
    var Jw = dt, Zw = $c;
    Ay("toStringTag"), Zw(Jw("Symbol"), "Symbol"), Ay("unscopables"), $c(me.JSON, "JSON", !0);
    var eN = ct.Symbol, tN = Sn, nN = ur.f, rN = tN("metadata"), oN = Function.prototype;
    void 0 === oN[rN] && nN(oN, rN, {
        value: null
    }), Ay("asyncDispose"), Ay("dispose"), Ay("metadata");
    var aN = eN, iN = Ce, cN = dt("Symbol"), uN = cN.keyFor, lN = iN(cN.prototype.valueOf), sN = cN.isRegisteredSymbol || function(e) {
        try {
            return void 0 !== uN(lN(e));
        } catch (e) {
            return !1;
        }
    };
    Br({
        target: "Symbol",
        stat: !0
    }, {
        isRegisteredSymbol: sN
    });
    for(var fN = nn, dN = dt, mN = Ce, pN = _t, vN = Sn, hN = dN("Symbol"), gN = hN.isWellKnownSymbol, yN = dN("Object", "getOwnPropertyNames"), bN = mN(hN.prototype.valueOf), EN = fN("wks"), wN = 0, NN = yN(hN), SN = NN.length; wN < SN; wN++)try {
        var TN = NN[wN];
        pN(hN[TN]) && vN(TN);
    } catch (e) {}
    var CN = function(e) {
        if (gN && gN(e)) return !0;
        try {
            for(var t = bN(e), n = 0, r = yN(EN), o = r.length; n < o; n++)if (EN[r[n]] == t) return !0;
        } catch (e) {}
        return !1;
    };
    Br({
        target: "Symbol",
        stat: !0,
        forced: !0
    }, {
        isWellKnownSymbol: CN
    }), Ay("customMatcher"), Ay("observable"), Br({
        target: "Symbol",
        stat: !0,
        name: "isRegisteredSymbol"
    }, {
        isRegistered: sN
    }), Br({
        target: "Symbol",
        stat: !0,
        name: "isWellKnownSymbol",
        forced: !0
    }, {
        isWellKnown: CN
    }), Ay("matcher"), Ay("metadataKey"), Ay("patternMatch"), Ay("replaceAll");
    var ON = se(aN), RN = se(ui), xN = mr, kN = bi, AN = cr, IN = Be, MN = an, _N = function(e, t, n, r) {
        try {
            return r ? t(xN(n)[0], n[1]) : t(n);
        } catch (t) {
            kN(e, "throw", t);
        }
    }, LN = qa, jN = ll, PN = Io, DN = hw, FN = vi, BN = ui, HN = Array, UN = function(e) {
        var t = MN(e), n = jN(this), r = arguments.length, o = r > 1 ? arguments[1] : void 0, a = void 0 !== o;
        a && (o = AN(o, r > 2 ? arguments[2] : void 0));
        var i, c, u, l, s, f, d = BN(t), m = 0;
        if (!d || this === HN && LN(d)) for(i = PN(t), c = n ? new this(i) : HN(i); i > m; m++)f = a ? o(t[m], m) : t[m], DN(c, m, f);
        else for(c = n ? new this : [], s = (l = FN(t, d)).next; !(u = IN(s, l)).done; m++)f = a ? _N(l, o, [
            u.value,
            m
        ], !0) : u.value, DN(c, m, f);
        return c.length = m, c;
    };
    Br({
        target: "Array",
        stat: !0,
        forced: !Gf(function(e) {
            Array.from(e);
        })
    }, {
        from: UN
    });
    var zN = se(ct.Array.from);
    var GN = Br, WN = Dy, VN = ll, YN = it, qN = Ro, XN = Io, $N = ot, KN = hw, QN = Sn, JN = bl, ZN = Pw("slice"), eS = QN("species"), tS = Array, nS = Math.max;
    GN({
        target: "Array",
        proto: !0,
        forced: !ZN
    }, {
        slice: function(e, t) {
            var n, r, o, a = $N(this), i = XN(a), c = qN(e, i), u = qN(void 0 === t ? i : t, i);
            if (WN(a) && (n = a.constructor, (VN(n) && (n === tS || WN(n.prototype)) || YN(n) && null === (n = n[eS])) && (n = void 0), n === tS || void 0 === n)) return JN(a, c, u);
            for(r = new (void 0 === n ? tS : n)(nS(u - c, 0)), o = 0; c < u; c++, o++)c in a && KN(r, o, a[c]);
            return r.length = o, r;
        }
    });
    var rS = me, oS = ct, aS = function(e, t) {
        var n = oS[e + "Prototype"], r = n && n[t];
        if (r) return r;
        var o = rS[e], a = o && o.prototype;
        return a && a[t];
    }, iS = aS("Array", "slice"), cS = mt, uS = iS, lS = Array.prototype, sS = function(e) {
        var t = e.slice;
        return e === lS || cS(lS, e) && t === lS.slice ? uS : t;
    }, fS = se(sS);
    function dS(e, t) {
        if (e) {
            var n;
            if ("string" == typeof e) return Aw(e, t);
            var r = fS(n = ({}).toString.call(e)).call(n, 8, -1);
            return "Object" === r && e.constructor && (r = e.constructor.name), "Map" === r || "Set" === r ? zN(e) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? Aw(e, t) : void 0;
        }
    }
    function mS(e) {
        return function(e) {
            if (kw(e)) return Aw(e);
        }(e) || function(e) {
            if (void 0 !== ON && null != RN(e) || null != e["@@iterator"]) return zN(e);
        }(e) || dS(e) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
    }
    var pS = Pe, vS = Dy, hS = TypeError, gS = Object.getOwnPropertyDescriptor, yS = pS && !function() {
        if (void 0 !== this) return !0;
        try {
            Object.defineProperty([], "length", {
                writable: !1
            }).length = 1;
        } catch (e) {
            return e instanceof TypeError;
        }
    }(), bS = an, ES = Io, wS = yS ? function(e, t) {
        if (vS(e) && !gS(e, "length").writable) throw new hS("Cannot set read only .length");
        return e.length = t;
    } : function(e, t) {
        return e.length = t;
    }, NS = Mw;
    Br({
        target: "Array",
        proto: !0,
        arity: 1,
        forced: pe(function() {
            return 4294967297 !== [].push.call({
                length: 4294967296
            }, 1);
        }) || !function() {
            try {
                Object.defineProperty([], "length", {
                    writable: !1
                }).push();
            } catch (e) {
                return e instanceof TypeError;
            }
        }()
    }, {
        push: function(e) {
            var t = bS(this), n = ES(t), r = arguments.length;
            NS(n + r);
            for(var o = 0; o < r; o++)t[n] = arguments[o], n++;
            return wS(t, n), n;
        }
    });
    var SS = aS("Array", "push"), TS = mt, CS = SS, OS = Array.prototype, RS = se(function(e) {
        var t = e.push;
        return e === OS || TS(OS, e) && t === OS.push ? CS : t;
    });
    function xS(e, t) {
        return function(e) {
            if (kw(e)) return e;
        }(e) || function(e, t) {
            var n = null == e ? null : void 0 !== ON && RN(e) || e["@@iterator"];
            if (null != n) {
                var r, o, a, i, c = [], u = !0, l = !1;
                try {
                    if (a = (n = n.call(e)).next, 0 === t) {
                        if (Object(n) !== n) return;
                        u = !1;
                    } else for(; !(u = (r = a.call(n)).done) && (RS(c).call(c, r.value), c.length !== t); u = !0);
                } catch (e) {
                    l = !0, o = e;
                } finally{
                    try {
                        if (!u && null != n.return && (i = n.return(), Object(i) !== i)) return;
                    } finally{
                        if (l) throw o;
                    }
                }
                return c;
            }
        }(e, t) || dS(e, t) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
    }
    var kS = se(Vr), AS = se(Ty.f("iterator"));
    function IS(e) {
        return IS = "function" == typeof ON && "symbol" == typeof AS ? function(e) {
            return typeof e;
        } : function(e) {
            return e && "function" == typeof ON && e.constructor === ON && e !== ON.prototype ? "symbol" : typeof e;
        }, IS(e);
    }
    var MS = se(Ty.f("toPrimitive"));
    function _S(e) {
        var t = function(e, t) {
            if ("object" != IS(e) || !e) return e;
            var n = e[MS];
            if (void 0 !== n) {
                var r = n.call(e, t || "default");
                if ("object" != IS(r)) return r;
                throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return (("TURBOPACK compile-time truthy", 1) ? String : ("TURBOPACK unreachable", undefined))(e);
        }(e, "string");
        return "symbol" == IS(t) ? t : t + "";
    }
    function LS(e, t, n) {
        return (t = _S(t)) in e ? kS(e, t, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = n, e;
    }
    var jS = Jy.map;
    Br({
        target: "Array",
        proto: !0,
        forced: !Pw("map")
    }, {
        map: function(e) {
            return jS(this, e, arguments.length > 1 ? arguments[1] : void 0);
        }
    });
    var PS = aS("Array", "map"), DS = mt, FS = PS, BS = Array.prototype, HS = se(function(e) {
        var t = e.map;
        return e === BS || DS(BS, e) && t === BS.map ? FS : t;
    }), US = aS("Array", "concat"), zS = mt, GS = US, WS = Array.prototype, VS = se(function(e) {
        var t = e.concat;
        return e === WS || zS(WS, e) && t === WS.concat ? GS : t;
    }), YS = Jy.filter;
    Br({
        target: "Array",
        proto: !0,
        forced: !Pw("filter")
    }, {
        filter: function(e) {
            return YS(this, e, arguments.length > 1 ? arguments[1] : void 0);
        }
    });
    var qS = aS("Array", "filter"), XS = mt, $S = qS, KS = Array.prototype, QS = se(function(e) {
        var t = e.filter;
        return e === KS || XS(KS, e) && t === KS.filter ? $S : t;
    }), JS = ng, ZS = String, eT = function(e) {
        if ("Symbol" === JS(e)) throw new TypeError("Cannot convert a Symbol value to a string");
        return ZS(e);
    }, tT = Wp, nT = function() {
        var e = tT(this), t = "";
        return e.hasIndices && (t += "d"), e.global && (t += "g"), e.ignoreCase && (t += "i"), e.multiline && (t += "m"), e.dotAll && (t += "s"), e.unicode && (t += "u"), e.unicodeSets && (t += "v"), e.sticky && (t += "y"), t;
    }, rT = qp, oT = Km, aT = Qp, iT = nT, cT = RegExp.prototype, uT = Wv.PROPER, lT = Vh, sT = Wp, fT = eT, dT = Lm, mT = function(e) {
        var t = e.flags;
        return void 0 !== t || "flags" in cT || oT(e, "flags") || !aT(cT, e) ? t : rT(iT, e);
    }, pT = "toString", vT = RegExp.prototype, hT = vT[pT], gT = dT(function() {
        return "/a/b" !== hT.call({
            source: "a",
            flags: "b"
        });
    }), yT = uT && hT.name !== pT;
    function bT(e, t) {
        var n = gy(e);
        if (rw) {
            var r = rw(e);
            t && (r = QS(r).call(r, function(t) {
                return dw(e, t).enumerable;
            })), n.push.apply(n, r);
        }
        return n;
    }
    function ET(e) {
        for(var t = 1; t < arguments.length; t++){
            var n = null != arguments[t] ? arguments[t] : {};
            t % 2 ? bT(Object(n), !0).forEach(function(t) {
                LS(e, t, n[t]);
            }) : ww ? xw(e, ww(n)) : bT(Object(n)).forEach(function(t) {
                Yr(e, t, dw(n, t));
            });
        }
        return e;
    }
    (gT || yT) && lT(vT, pT, function() {
        var e = sT(this);
        return "/" + fT(e.source) + "/" + fT(mT(e));
    }, {
        unsafe: !0
    });
    var wT = 0, NT = function(e, t) {
        var n, r = e.createdAt || Date.now(), o = e.hasTime || r - wT > 3e5;
        return o && (wT = r), ET(ET({}, e), {}, {
            _id: e._id || t || (n = 2147483648, Math.floor(Math.random() * n).toString(36) + Math.abs(Math.floor(Math.random() * n) ^ Date.now()).toString(36)),
            createdAt: r,
            position: e.position || "left",
            hasTime: o
        });
    };
    function ST(e) {
        var n = e.active, r = void 0 !== n && n, o = e.ref, a = e.delay, i = void 0 === a ? 300 : a, c = xS(t.useState(!1), 2), u = c[0], l = c[1], s = xS(t.useState(!1), 2), f = s[0], d = s[1], m = t.useRef(), p = function() {
            m.current && clearTimeout(m.current);
        };
        return t.useEffect({
            "ST.useEffect": function() {
                return r ? (p(), d(r)) : (l(r), m.current = setTimeout({
                    "ST.useEffect": function() {
                        d(r);
                    }
                }["ST.useEffect"], i)), p;
            }
        }["ST.useEffect"], [
            r,
            i
        ]), t.useEffect({
            "ST.useEffect": function() {
                o.current && o.current.offsetHeight, l(f);
            }
        }["ST.useEffect"], [
            f,
            o
        ]), {
            didMount: f,
            isShow: u
        };
    }
    function TT(e, t) {
        return Math.floor(Math.random() * (t - e + 1)) + e;
    }
    var CT = se(sS);
    function OT(e) {
        var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r = n.interval, o = void 0 === r ? 80 : r, a = n.step, i = void 0 === a ? 1 : a, c = n.initialIndex, u = void 0 === c ? 5 : c, l = e.length, s = xS(t.useState(u), 2), f = s[0], d = s[1];
        return t.useEffect({
            "OT.useEffect": function() {
                if (f < l) {
                    var e = setTimeout({
                        "OT.useEffect.e": function() {
                            var e = Array.isArray(i) ? TT(i[0], i[1]) : i;
                            d({
                                "OT.useEffect.e": function(t) {
                                    return t + e;
                                }
                            }["OT.useEffect.e"]);
                        }
                    }["OT.useEffect.e"], o);
                    return ({
                        "OT.useEffect": function() {
                            clearTimeout(e);
                        }
                    })["OT.useEffect"];
                }
            }
        }["OT.useEffect"], [
            f,
            o,
            l,
            i
        ]), {
            typedContent: CT(e).call(e, 0, f),
            isTyping: f < l
        };
    }
    var RT = Pe, xT = Ce, kT = Be, AT = pe, IT = ca, MT = qo, _T = He, LT = an, jT = Qe, PT = Object.assign, DT = Object.defineProperty, FT = xT([].concat), BT = !PT || AT(function() {
        if (RT && 1 !== PT({
            b: 1
        }, PT(DT({}, "a", {
            enumerable: !0,
            get: function() {
                DT(this, "b", {
                    value: 3,
                    enumerable: !1
                });
            }
        }), {
            b: 2
        })).b) return !0;
        var e = {}, t = {}, n = Symbol("assign detection"), r = "abcdefghijklmnopqrst";
        return e[n] = 7, r.split("").forEach(function(e) {
            t[e] = e;
        }), 7 !== PT({}, e)[n] || IT(PT({}, t)).join("") !== r;
    }) ? function(e, t) {
        for(var n = LT(e), r = arguments.length, o = 1, a = MT.f, i = _T.f; r > o;)for(var c, u = jT(arguments[o++]), l = a ? FT(IT(u), a(u)) : IT(u), s = l.length, f = 0; s > f;)c = l[f++], RT && !kT(i, u, c) || (n[c] = u[c]);
        return n;
    } : PT, HT = BT;
    Br({
        target: "Object",
        stat: !0,
        arity: 2,
        forced: Object.assign !== HT
    }, {
        assign: HT
    });
    var UT = se(ct.Object.assign), zT = Ce, GT = Bt, WT = it, VT = ln, YT = bl, qT = ve, XT = Function, $T = zT([].concat), KT = zT([].join), QT = {}, JT = qT ? XT.bind : function(e) {
        var t = GT(this), n = t.prototype, r = YT(arguments, 1), o = function() {
            var n = $T(r, YT(arguments));
            return this instanceof o ? function(e, t, n) {
                if (!VT(QT, t)) {
                    for(var r = [], o = 0; o < t; o++)r[o] = "a[" + o + "]";
                    QT[t] = XT("C,a", "return new C(" + KT(r, ",") + ")");
                }
                return QT[t](e, n);
            }(t, n.length, n) : t.apply(e, n);
        };
        return WT(n) && (o.prototype = n), o;
    }, ZT = JT;
    Br({
        target: "Function",
        proto: !0,
        forced: Function.bind !== ZT
    }, {
        bind: ZT
    });
    var eC = aS("Function", "bind"), tC = mt, nC = eC, rC = Function.prototype, oC = se(function(e) {
        var t = e.bind;
        return e === rC || tC(rC, e) && t === rC.bind ? nC : t;
    });
    function aC() {
        var e;
        return aC = UT ? oC(e = UT).call(e) : function(e) {
            for(var t = 1; t < arguments.length; t++){
                var n = arguments[t];
                for(var r in n)({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
            }
            return e;
        }, aC.apply(null, arguments);
    }
    var iC = se(nw), cC = pe, uC = function(e, t) {
        var n = [][e];
        return !!n && cC(function() {
            n.call(null, t || function() {
                return 1;
            }, 1);
        });
    }, lC = Br, sC = Po.indexOf, fC = uC, dC = Me([].indexOf), mC = !!dC && 1 / dC([
        1
    ], 1, -0) < 0;
    lC({
        target: "Array",
        proto: !0,
        forced: mC || !fC("indexOf")
    }, {
        indexOf: function(e) {
            var t = arguments.length > 1 ? arguments[1] : void 0;
            return mC ? dC(this, e, t) || 0 : sC(this, e, t);
        }
    });
    var pC = aS("Array", "indexOf"), vC = mt, hC = pC, gC = Array.prototype, yC = function(e) {
        var t = e.indexOf;
        return e === gC || vC(gC, e) && t === gC.indexOf ? hC : t;
    }, bC = se(yC);
    function EC(e, t) {
        if (null == e) return {};
        var n, r, o = function(e, t) {
            if (null == e) return {};
            var n = {};
            for(var r in e)if (({}).hasOwnProperty.call(e, r)) {
                if (-1 !== bC(t).call(t, r)) continue;
                n[r] = e[r];
            }
            return n;
        }(e, t);
        if (iC) {
            var a = iC(e);
            for(r = 0; r < a.length; r++)n = a[r], -1 === bC(t).call(t, n) && ({}).propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
        }
        return o;
    }
    var wC = Br, NC = Ee, SC = JT, TC = ml, CC = mr, OC = it, RC = ka, xC = pe, kC = dt("Reflect", "construct"), AC = Object.prototype, IC = [].push, MC = xC(function() {
        function e() {}
        return !(kC(function() {}, [], e) instanceof e);
    }), _C = !xC(function() {
        kC(function() {});
    }), LC = MC || _C;
    wC({
        target: "Reflect",
        stat: !0,
        forced: LC,
        sham: LC
    }, {
        construct: function(e, t) {
            TC(e), CC(t);
            var n = arguments.length < 3 ? e : TC(arguments[2]);
            if (_C && !MC) return kC(e, t, n);
            if (e === n) {
                switch(t.length){
                    case 0:
                        return new e;
                    case 1:
                        return new e(t[0]);
                    case 2:
                        return new e(t[0], t[1]);
                    case 3:
                        return new e(t[0], t[1], t[2]);
                    case 4:
                        return new e(t[0], t[1], t[2], t[3]);
                }
                var r = [
                    null
                ];
                return NC(IC, r, t), new (NC(SC, e, r));
            }
            var o = n.prototype, a = RC(OC(o) ? o : AC), i = NC(e, a, t);
            return OC(i) ? i : a;
        }
    });
    var jC = se(ct.Reflect.construct);
    function PC(e, t) {
        for(var n = 0; n < t.length; n++){
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), kS(e, _S(r.key), r);
        }
    }
    function DC(e, t) {
        if (t && ("object" == IS(t) || "function" == typeof t)) return t;
        if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
        return function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e;
        }(e);
    }
    Br({
        target: "Object",
        stat: !0
    }, {
        setPrototypeOf: yo
    });
    var FC = se(ct.Object.setPrototypeOf), BC = an, HC = io, UC = Jr;
    Br({
        target: "Object",
        stat: !0,
        forced: pe(function() {
            HC(1);
        }),
        sham: !UC
    }, {
        getPrototypeOf: function(e) {
            return HC(BC(e));
        }
    });
    var zC = se(ct.Object.getPrototypeOf);
    function GC(e) {
        var t;
        return GC = FC ? oC(t = zC).call(t) : function(e) {
            return e.__proto__ || zC(e);
        }, GC(e);
    }
    Br({
        target: "Object",
        stat: !0,
        sham: !Pe
    }, {
        create: ka
    });
    var WC = ct.Object, VC = se(function(e, t) {
        return WC.create(e, t);
    });
    function YC(e, t) {
        var n;
        return YC = FC ? oC(n = FC).call(n) : function(e, t) {
            return e.__proto__ = t, e;
        }, YC(e, t);
    }
    var qC = [
        "FallbackComponent",
        "children"
    ];
    function XC() {
        try {
            var e = !Boolean.prototype.valueOf.call(jC(Boolean, [], function() {}));
        } catch (e) {}
        return (XC = function() {
            return !!e;
        })();
    }
    var $C = function(e) {
        function t(e) {
            var n, r, o, a;
            return function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
            }(this, t), r = this, a = [
                e
            ], o = GC(o = t), (n = DC(r, XC() ? jC(o, a || [], GC(r).constructor) : o.apply(r, a))).state = {
                error: null,
                errorInfo: null
            }, n;
        }
        return function(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
            e.prototype = VC(t && t.prototype, {
                constructor: {
                    value: e,
                    writable: !0,
                    configurable: !0
                }
            }), kS(e, "prototype", {
                writable: !1
            }), t && YC(e, t);
        }(t, e), function(e, t, n) {
            return t && PC(e.prototype, t), n && PC(e, n), kS(e, "prototype", {
                writable: !1
            }), e;
        }(t, [
            {
                key: "componentDidCatch",
                value: function(e, t) {
                    var n = this.props.onError;
                    n && n(e, t), this.setState({
                        error: e,
                        errorInfo: t
                    });
                }
            },
            {
                key: "render",
                value: function() {
                    var e = this.props, t = e.FallbackComponent, n = e.children, r = EC(e, qC), a = this.state, i = a.error, c = a.errorInfo;
                    return c ? t ? o.default.createElement(t, aC({
                        error: i,
                        errorInfo: c
                    }, r)) : null : n;
                }
            }
        ]);
    }(o.default.Component), KC = [
        "component",
        "onError",
        "fallback"
    ], QC = function(e) {
        var n = e.component, r = e.onError, a = e.fallback, i = EC(e, KC);
        return n ? o.default.createElement($C, {
            onError: r
        }, o.default.createElement(t.Suspense, {
            fallback: a || null
        }, o.default.createElement(n, i))) : null;
    }, JC = o.default.createContext({
        addComponent: function() {},
        hasComponent: function() {
            return !1;
        },
        getComponent: function() {
            return null;
        }
    });
    function ZC() {
        return o.default.useContext(JC);
    }
    var eO = [
        "code",
        "fallback",
        "onLoad",
        "onError"
    ], tO = [
        "component",
        "code",
        "onLoad"
    ], nO = function(e) {
        var t = e.code, n = e.fallback, r = e.onLoad, a = e.onError, i = EC(e, eO), c = (0, ZC().getComponent)(t, function(e) {
            "async" in e && r ? r(e) : "errCode" in e && a && a(new Error(e.errCode));
        });
        return o.default.createElement(QC, aC({
            component: c,
            onError: a,
            fallback: n
        }, i));
    };
    function rO(e, t) {
        var n = gy(e);
        if (rw) {
            var r = rw(e);
            t && (r = QS(r).call(r, function(t) {
                return dw(e, t).enumerable;
            })), n.push.apply(n, r);
        }
        return n;
    }
    function oO(e) {
        for(var t = 1; t < arguments.length; t++){
            var n = null != arguments[t] ? arguments[t] : {};
            t % 2 ? rO(Object(n), !0).forEach(function(t) {
                LS(e, t, n[t]);
            }) : ww ? xw(e, ww(n)) : rO(Object(n)).forEach(function(t) {
                Yr(e, t, dw(n, t));
            });
        }
        return e;
    }
    var aO = function(e) {
        var t = e.className, n = e.src, r = e.alt, a = e.url, i = e.size, u = void 0 === i ? "md" : i, l = e.shape, s = void 0 === l ? "circle" : l, f = e.children, d = a ? "a" : "span";
        return o.default.createElement(d, {
            className: c("Avatar", "Avatar--".concat(u), "Avatar--".concat(s), t),
            href: a
        }, n ? o.default.createElement("img", {
            src: n,
            alt: r
        }) : f);
    }, iO = [
        "className",
        "active",
        "onClick"
    ], cO = function(e) {
        var t = e.className, n = e.active, r = e.onClick, a = EC(e, iO);
        return o.default.createElement("div", aC({
            className: c("Backdrop", t, {
                active: n
            }),
            onClick: r
        }, a));
    }, uO = [
        "type",
        "content",
        "children"
    ], lO = o.default.forwardRef(function(e, t) {
        var n = e.type, r = void 0 === n ? "text" : n, a = e.content, i = e.children, c = EC(e, uO);
        return o.default.createElement("div", aC({
            className: "Bubble ".concat(r),
            "data-type": r
        }, c, {
            ref: t
        }), a && o.default.createElement("p", null, a), i);
    }), sO = [
        "type",
        "className",
        "spin",
        "name"
    ], fO = function(e) {
        var t = e.type, n = e.className, r = e.spin, a = e.name, i = EC(e, sO), u = "string" == typeof a ? {
            "aria-label": a
        } : {
            "aria-hidden": !0
        };
        return o.default.createElement("svg", aC({
            className: c("Icon", {
                "is-spin": r
            }, n)
        }, u, i), o.default.createElement("use", {
            xlinkHref: "#icon-".concat(t)
        }));
    }, dO = [
        "className",
        "label",
        "color",
        "variant",
        "size",
        "icon",
        "loading",
        "block",
        "disabled",
        "children",
        "onClick"
    ];
    function mO(e) {
        return e && "Btn--".concat(e);
    }
    var pO = o.default.forwardRef(function(e, t) {
        var n = e.className, r = e.label, a = e.color, i = e.variant, u = e.size, l = e.icon, s = e.loading, f = e.block, d = e.disabled, m = e.children, p = e.onClick, v = EC(e, dO), h = l || s && "spinner", g = u || (f ? "lg" : "");
        return o.default.createElement("button", aC({
            className: c("Btn", mO(a), mO(i), mO(g), {
                "Btn--block": f
            }, n),
            type: "button",
            disabled: d,
            "data-loading": s,
            onClick: function(e) {
                d || s || !p || p(e);
            },
            ref: t
        }, v), h && o.default.createElement("span", {
            className: "Btn-icon"
        }, o.default.createElement(fO, {
            type: h,
            spin: s
        })), r || m);
    }), vO = [
        "className",
        "size",
        "fluid",
        "children"
    ], hO = o.default.forwardRef(function(e, t) {
        var n = e.className, r = e.size, a = e.fluid, i = e.children, u = EC(e, vO);
        return o.default.createElement("div", aC({
            className: c("Card", r && "Card--".concat(r), {
                "Card--fluid": a
            }, n),
            "data-fluid": a
        }, u, {
            ref: t
        }), i);
    }), gO = [
        "as",
        "className",
        "inline",
        "center",
        "direction",
        "wrap",
        "justifyContent",
        "justify",
        "alignItems",
        "align",
        "children"
    ], yO = {
        row: "Flex--d-r",
        "row-reverse": "Flex--d-rr",
        column: "Flex--d-c",
        "column-reverse": "Flex--d-cr"
    }, bO = {
        nowrap: "Flex--w-n",
        wrap: "Flex--w-w",
        "wrap-reverse": "Flex--w-wr"
    }, EO = {
        "flex-start": "Flex--jc-fs",
        "flex-end": "Flex--jc-fe",
        center: "Flex--jc-c",
        "space-between": "Flex--jc-sb",
        "space-around": "Flex--jc-sa"
    }, wO = {
        "flex-start": "Flex--ai-fs",
        "flex-end": "Flex--ai-fe",
        center: "Flex--ai-c"
    }, NO = o.default.forwardRef(function(e, t) {
        var n = e.as, r = void 0 === n ? "div" : n, a = e.className, i = e.inline, u = e.center, l = e.direction, s = e.wrap, f = e.justifyContent, d = e.justify, m = void 0 === d ? f : d, p = e.alignItems, v = e.align, h = void 0 === v ? p : v, g = e.children, y = EC(e, gO);
        return o.default.createElement(r, aC({
            className: c("Flex", l && yO[l], m && EO[m], h && wO[h], s && bO[s], {
                "Flex--inline": i,
                "Flex--center": u
            }, a),
            ref: t
        }, y), g);
    }), SO = [
        "className",
        "flex",
        "alignSelf",
        "order",
        "style",
        "children"
    ];
    function TO(e, t) {
        var n = gy(e);
        if (rw) {
            var r = rw(e);
            t && (r = QS(r).call(r, function(t) {
                return dw(e, t).enumerable;
            })), n.push.apply(n, r);
        }
        return n;
    }
    function CO(e) {
        for(var t = 1; t < arguments.length; t++){
            var n = null != arguments[t] ? arguments[t] : {};
            t % 2 ? TO(Object(n), !0).forEach(function(t) {
                LS(e, t, n[t]);
            }) : ww ? xw(e, ww(n)) : TO(Object(n)).forEach(function(t) {
                Yr(e, t, dw(n, t));
            });
        }
        return e;
    }
    var OO = function(e) {
        var t = e.className, n = e.flex, r = e.alignSelf, a = e.order, i = e.style, u = e.children, l = EC(e, SO);
        return o.default.createElement("div", aC({
            className: c("FlexItem", t),
            style: CO(CO({}, i), {}, {
                flex: n,
                alignSelf: r,
                order: a
            })
        }, l), u);
    }, RO = [
        "className",
        "aspectRatio",
        "color",
        "image",
        "children"
    ], xO = [
        "className",
        "children"
    ], kO = Po.includes;
    Br({
        target: "Array",
        proto: !0,
        forced: pe(function() {
            return !Array(1).includes();
        })
    }, {
        includes: function(e) {
            return kO(this, e, arguments.length > 1 ? arguments[1] : void 0);
        }
    });
    var AO = aS("Array", "includes"), IO = it, MO = ke, _O = Sn("match"), LO = function(e) {
        var t;
        return IO(e) && (void 0 !== (t = e[_O]) ? !!t : "RegExp" === MO(e));
    }, jO = TypeError, PO = Sn("match"), DO = Br, FO = function(e) {
        if (LO(e)) throw new jO("The method doesn't accept regular expressions");
        return e;
    }, BO = tt, HO = Pi, UO = function(e) {
        var t = /./;
        try {
            "/./"[e](t);
        } catch (n) {
            try {
                return t[PO] = !1, "/./"[e](t);
            } catch (e) {}
        }
        return !1;
    }, zO = Ce("".indexOf);
    DO({
        target: "String",
        proto: !0,
        forced: !UO("includes")
    }, {
        includes: function(e) {
            return !!~zO(HO(BO(this)), HO(FO(e)), arguments.length > 1 ? arguments[1] : void 0);
        }
    });
    var GO = aS("String", "includes"), WO = mt, VO = AO, YO = GO, qO = Array.prototype, XO = String.prototype, $O = se(function(e) {
        var t = e.includes;
        return e === qO || WO(qO, e) && t === qO.includes ? VO : "string" == typeof e || e === XO || WO(XO, e) && t === XO.includes ? YO : t;
    }), KO = it, QO = Math.floor;
    Br({
        target: "Number",
        stat: !0
    }, {
        isInteger: Number.isInteger || function(e) {
            return !KO(e) && isFinite(e) && QO(e) === e;
        }
    });
    var JO = se(ct.Number.isInteger), ZO = [
        "as",
        "className",
        "align",
        "breakWord",
        "truncate",
        "children"
    ], eR = function(e) {
        var t = e.as, n = void 0 === t ? "div" : t, r = e.className, a = e.align, i = e.breakWord, u = e.truncate, l = e.children, s = EC(e, ZO), f = JO(u), d = c(a && "Text--".concat(a), {
            "Text--break": i,
            "Text--truncate": !0 === u,
            "Text--ellipsis": f
        }, r), m = f ? {
            WebkitLineClamp: u
        } : null;
        return o.default.createElement(n, aC({
            className: d,
            style: m
        }, s), l);
    }, tR = [
        "className",
        "src",
        "lazy",
        "fluid",
        "children"
    ], nR = o.default.forwardRef(function(e, n) {
        var r = e.className, a = e.src, i = e.lazy, u = e.fluid;
        e.children;
        var l = EC(e, tR), s = xS(t.useState(i ? void 0 : a), 2), f = s[0], d = s[1], m = gm(n), p = t.useRef(""), v = t.useRef(!1);
        return t.useEffect({
            "nR.useEffect": function() {
                if (i) {
                    var e = new IntersectionObserver({
                        "nR.useEffect": function(t) {
                            var n = xS(t, 1)[0];
                            n.isIntersecting && (d(p.current), v.current = !0, e.unobserve(n.target));
                        }
                    }["nR.useEffect"]);
                    return m.current && e.observe(m.current), ({
                        "nR.useEffect": function() {
                            e.disconnect();
                        }
                    })["nR.useEffect"];
                }
            }
        }["nR.useEffect"], [
            m,
            i
        ]), t.useEffect({
            "nR.useEffect": function() {
                p.current = a, i && !v.current || d(a);
            }
        }["nR.useEffect"], [
            i,
            a
        ]), o.default.createElement("img", aC({
            className: c("Image", {
                "Image--fluid": u
            }, r),
            src: f,
            alt: "",
            ref: m
        }, l));
    }), rR = [
        "className",
        "icon",
        "iconColor",
        "logo",
        "title",
        "desc",
        "hasBg",
        "badge",
        "children"
    ], oR = [
        "className",
        "title",
        "subtitle",
        "center",
        "children"
    ], aR = [
        "className",
        "children"
    ], iR = [
        "children",
        "className",
        "direction"
    ], cR = {}, uR = {}, lR = {}.propertyIsEnumerable, sR = Object.getOwnPropertyDescriptor, fR = sR && !lR.call({
        1: 2
    }, 1);
    uR.f = fR ? function(e) {
        var t = sR(this, e);
        return !!t && t.enumerable;
    } : lR;
    var dR = bg, mR = Wm, pR = function(e) {
        return dR(mR(e));
    }, vR = Ip, hR = qp, gR = uR, yR = th, bR = pR, ER = Ov, wR = Km, NR = Bp, SR = Object.getOwnPropertyDescriptor;
    cR.f = vR ? SR : function(e, t) {
        if (e = bR(e), t = ER(t), NR) try {
            return SR(e, t);
        } catch (e) {}
        if (wR(e, t)) return yR(!hR(gR.f, e, t), e[t]);
    };
    var TR = {}, CR = Sg, OR = Math.max, RR = Math.min, xR = pR, kR = function(e, t) {
        var n = CR(e);
        return n < 0 ? OR(n + t, 0) : RR(n, t);
    }, AR = xg, IR = function(e) {
        return function(t, n, r) {
            var o = xR(t), a = AR(o);
            if (0 === a) return !e && -1;
            var i, c = kR(r, a);
            if (e && n != n) {
                for(; a > c;)if ((i = o[c++]) != i) return !0;
            } else for(; a > c; c++)if ((e || c in o) && o[c] === n) return e || c || 0;
            return !e && -1;
        };
    }, MR = {
        includes: IR(!0),
        indexOf: IR(!1)
    }, _R = Km, LR = pR, jR = MR.indexOf, PR = uh, DR = Hm([].push), FR = function(e, t) {
        var n, r = LR(e), o = 0, a = [];
        for(n in r)!_R(PR, n) && _R(r, n) && DR(a, n);
        for(; t.length > o;)_R(r, n = t[o++]) && (~jR(a, n) || DR(a, n));
        return a;
    }, BR = [
        "constructor",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "toLocaleString",
        "toString",
        "valueOf"
    ], HR = FR, UR = BR.concat("length", "prototype");
    TR.f = Object.getOwnPropertyNames || function(e) {
        return HR(e, UR);
    };
    var zR = {};
    zR.f = Object.getOwnPropertySymbols;
    var GR, WR, VR, YR, qR = Kp, XR = TR, $R = zR, KR = Wp, QR = Hm([].concat), JR = qR("Reflect", "ownKeys") || function(e) {
        var t = XR.f(KR(e)), n = $R.f;
        return n ? QR(t, n(e)) : t;
    }, ZR = Km, ex = JR, tx = cR, nx = Ap, rx = Lm, ox = kp, ax = /#|\.prototype\./, ix = function(e, t) {
        var n = ux[cx(e)];
        return n === sx || n !== lx && (ox(t) ? rx(t) : !!t);
    }, cx = ix.normalize = function(e) {
        return String(e).replace(ax, ".").toLowerCase();
    }, ux = ix.data = {}, lx = ix.NATIVE = "N", sx = ix.POLYFILL = "P", fx = ix, dx = Em, mx = cR.f, px = oh, vx = Vh, hx = Tm, gx = function(e, t, n) {
        for(var r = ex(t), o = nx.f, a = tx.f, i = 0; i < r.length; i++){
            var c = r[i];
            ZR(e, c) || n && ZR(n, c) || o(e, c, a(t, c));
        }
    }, yx = fx, bx = function(e, t) {
        var n, r, o, a, i, c = e.target, u = e.global, l = e.stat;
        if (n = u ? dx : l ? dx[c] || hx(c, {}) : dx[c] && dx[c].prototype) for(r in t){
            if (a = t[r], o = e.dontCallGetSet ? (i = mx(n, r)) && i.value : n[r], !yx(u ? r : c + (l ? "." : "#") + r, e.forced) && void 0 !== o) {
                if (typeof a == typeof o) continue;
                gx(a, o);
            }
            (e.sham || o && o.sham) && px(a, "sham", !0), vx(n, r, a, e);
        }
    }, Ex = Em, wx = op, Nx = $h, Sx = function(e) {
        return wx.slice(0, e.length) === e;
    }, Tx = Sx("Bun/") ? "BUN" : Sx("Cloudflare-Workers") ? "CLOUDFLARE" : Sx("Deno/") ? "DENO" : Sx("Node.js/") ? "NODE" : Ex.Bun && "string" == typeof Bun.version ? "BUN" : Ex.Deno && "object" == typeof Deno.version ? "DENO" : "process" === Nx(Ex.process) ? "NODE" : Ex.window && Ex.document ? "BROWSER" : "REST", Cx = "NODE" === Tx, Ox = Hm, Rx = uv, xx = _p, kx = function(e) {
        return xx(e) || null === e;
    }, Ax = String, Ix = TypeError, Mx = function(e, t, n) {
        try {
            return Ox(Rx(Object.getOwnPropertyDescriptor(e, t)[n]));
        } catch (e) {}
    }, _x = _p, Lx = Wm, jx = function(e) {
        if (kx(e)) return e;
        throw new Ix("Can't set " + Ax(e) + " as a prototype");
    }, Px = Object.setPrototypeOf || ("__proto__" in {} ? function() {
        var e, t = !1, n = {};
        try {
            (e = Mx(Object.prototype, "__proto__", "set"))(n, []), t = n instanceof Array;
        } catch (e) {}
        return function(n, r) {
            return Lx(n), jx(r), _x(n) ? (t ? e(n, r) : n.__proto__ = r, n) : n;
        };
    }() : void 0), Dx = Ap.f, Fx = Km, Bx = Cp("toStringTag"), Hx = Hh, Ux = Ap, zx = Kp, Gx = function(e, t, n) {
        return n.get && Hx(n.get, t, {
            getter: !0
        }), n.set && Hx(n.set, t, {
            setter: !0
        }), Ux.f(e, t, n);
    }, Wx = Ip, Vx = Cp("species"), Yx = Qp, qx = TypeError, Xx = Gg, $x = ov, Kx = TypeError, Qx = Wp, Jx = function(e) {
        if (Xx(e)) return e;
        throw new Kx($x(e) + " is not a constructor");
    }, Zx = Um, ek = Cp("species"), tk = function(e, t) {
        var n, r = Qx(e).constructor;
        return void 0 === r || Zx(n = Qx(r)[ek]) ? t : Jx(n);
    }, nk = jm, rk = Function.prototype, ok = rk.apply, ak = rk.call, ik = "object" == typeof Reflect && Reflect.apply || (nk ? ak.bind(ok) : function() {
        return ak.apply(ok, arguments);
    }), ck = Kp("document", "documentElement"), uk = Hm([].slice), lk = TypeError, sk = /(?:ipad|iphone|ipod).*applewebkit/i.test(op), fk = Em, dk = ik, mk = pg, pk = kp, vk = Km, hk = Lm, gk = ck, yk = uk, bk = Dp, Ek = function(e, t) {
        if (e < t) throw new lk("Not enough arguments");
        return e;
    }, wk = sk, Nk = Cx, Sk = fk.setImmediate, Tk = fk.clearImmediate, Ck = fk.process, Ok = fk.Dispatch, Rk = fk.Function, xk = fk.MessageChannel, kk = fk.String, Ak = 0, Ik = {}, Mk = "onreadystatechange";
    hk(function() {
        GR = fk.location;
    });
    var _k = function(e) {
        if (vk(Ik, e)) {
            var t = Ik[e];
            delete Ik[e], t();
        }
    }, Lk = function(e) {
        return function() {
            _k(e);
        };
    }, jk = function(e) {
        _k(e.data);
    }, Pk = function(e) {
        fk.postMessage(kk(e), GR.protocol + "//" + GR.host);
    };
    Sk && Tk || (Sk = function(e) {
        Ek(arguments.length, 1);
        var t = pk(e) ? e : Rk(e), n = yk(arguments, 1);
        return Ik[++Ak] = function() {
            dk(t, void 0, n);
        }, WR(Ak), Ak;
    }, Tk = function(e) {
        delete Ik[e];
    }, Nk ? WR = function(e) {
        Ck.nextTick(Lk(e));
    } : Ok && Ok.now ? WR = function(e) {
        Ok.now(Lk(e));
    } : xk && !wk ? (YR = (VR = new xk).port2, VR.port1.onmessage = jk, WR = mk(YR.postMessage, YR)) : fk.addEventListener && pk(fk.postMessage) && !fk.importScripts && GR && "file:" !== GR.protocol && !hk(Pk) ? (WR = Pk, fk.addEventListener("message", jk, !1)) : WR = Mk in bk("script") ? function(e) {
        gk.appendChild(bk("script"))[Mk] = function() {
            gk.removeChild(this), _k(e);
        };
    } : function(e) {
        setTimeout(Lk(e), 0);
    });
    var Dk = {
        set: Sk,
        clear: Tk
    }, Fk = Em, Bk = Ip, Hk = Object.getOwnPropertyDescriptor, Uk = function() {
        this.head = null, this.tail = null;
    };
    Uk.prototype = {
        add: function(e) {
            var t = {
                item: e,
                next: null
            }, n = this.tail;
            n ? n.next = t : this.head = t, this.tail = t;
        },
        get: function() {
            var e = this.head;
            if (e) return null === (this.head = e.next) && (this.tail = null), e.item;
        }
    };
    var zk, Gk, Wk, Vk, Yk, qk = Uk, Xk = /ipad|iphone|ipod/i.test(op) && "undefined" != typeof Pebble, $k = /web0s(?!.*chrome)/i.test(op), Kk = Em, Qk = function(e) {
        if (!Bk) return Fk[e];
        var t = Hk(Fk, e);
        return t && t.value;
    }, Jk = pg, Zk = Dk.set, eA = qk, tA = sk, nA = Xk, rA = $k, oA = Cx, aA = Kk.MutationObserver || Kk.WebKitMutationObserver, iA = Kk.document, cA = Kk.process, uA = Kk.Promise, lA = Qk("queueMicrotask");
    if (!lA) {
        var sA = new eA, fA = function() {
            var e, t;
            for(oA && (e = cA.domain) && e.exit(); t = sA.get();)try {
                t();
            } catch (e) {
                throw sA.head && zk(), e;
            }
            e && e.enter();
        };
        tA || oA || rA || !aA || !iA ? !nA && uA && uA.resolve ? ((Vk = uA.resolve(void 0)).constructor = uA, Yk = Jk(Vk.then, Vk), zk = function() {
            Yk(fA);
        }) : oA ? zk = function() {
            cA.nextTick(fA);
        } : (Zk = Jk(Zk, Kk), zk = function() {
            Zk(fA);
        }) : (Gk = !0, Wk = iA.createTextNode(""), new aA(fA).observe(Wk, {
            characterData: !0
        }), zk = function() {
            Wk.data = Gk = !Gk;
        }), lA = function(e) {
            sA.head || zk(), sA.add(e);
        };
    }
    var dA = lA, mA = function(e) {
        try {
            return {
                error: !1,
                value: e()
            };
        } catch (e) {
            return {
                error: !0,
                value: e
            };
        }
    }, pA = Em.Promise, vA = Em, hA = pA, gA = kp, yA = fx, bA = Qv, EA = Cp, wA = Tx, NA = fp;
    hA && hA.prototype;
    var SA = EA("species"), TA = !1, CA = gA(vA.PromiseRejectionEvent), OA = yA("Promise", function() {
        var e = bA(hA), t = e !== String(hA);
        if (!t && 66 === NA) return !0;
        if (!NA || NA < 51 || !/native code/.test(e)) {
            var n = new hA(function(e) {
                e(1);
            }), r = function(e) {
                e(function() {}, function() {});
            };
            if ((n.constructor = {})[SA] = r, !(TA = n.then(function() {}) instanceof r)) return !0;
        }
        return !(t || "BROWSER" !== wA && "DENO" !== wA || CA);
    }), RA = {
        CONSTRUCTOR: OA,
        REJECTION_EVENT: CA,
        SUBCLASSING: TA
    }, xA = {}, kA = uv, AA = TypeError, IA = function(e) {
        var t, n;
        this.promise = new e(function(e, r) {
            if (void 0 !== t || void 0 !== n) throw new AA("Bad Promise constructor");
            t = e, n = r;
        }), this.resolve = kA(t), this.reject = kA(n);
    };
    xA.f = function(e) {
        return new IA(e);
    };
    var MA, _A, LA, jA = bx, PA = Cx, DA = Em, FA = qp, BA = Vh, HA = Px, UA = function(e, t, n) {
        e && !n && (e = e.prototype), e && !Fx(e, Bx) && Dx(e, Bx, {
            configurable: !0,
            value: t
        });
    }, zA = function(e) {
        var t = zx(e);
        Wx && t && !t[Vx] && Gx(t, Vx, {
            configurable: !0,
            get: function() {
                return this;
            }
        });
    }, GA = uv, WA = kp, VA = _p, YA = function(e, t) {
        if (Yx(t, e)) return e;
        throw new qx("Incorrect invocation");
    }, qA = tk, XA = Dk.set, $A = dA, KA = function(e, t) {}, QA = mA, JA = qk, ZA = Nh, eI = pA, tI = xA, nI = "Promise", rI = RA.CONSTRUCTOR, oI = RA.REJECTION_EVENT, aI = RA.SUBCLASSING, iI = ZA.getterFor(nI), cI = ZA.set, uI = eI && eI.prototype, lI = eI, sI = uI, fI = DA.TypeError, dI = DA.document, mI = DA.process, pI = tI.f, vI = pI, hI = !!(dI && dI.createEvent && DA.dispatchEvent), gI = "unhandledrejection", yI = function(e) {
        var t;
        return !(!VA(e) || !WA(t = e.then)) && t;
    }, bI = function(e, t) {
        var n, r, o, a = t.value, i = 1 === t.state, c = i ? e.ok : e.fail, u = e.resolve, l = e.reject, s = e.domain;
        try {
            c ? (i || (2 === t.rejection && TI(t), t.rejection = 1), !0 === c ? n = a : (s && s.enter(), n = c(a), s && (s.exit(), o = !0)), n === e.promise ? l(new fI("Promise-chain cycle")) : (r = yI(n)) ? FA(r, n, u, l) : u(n)) : l(a);
        } catch (e) {
            s && !o && s.exit(), l(e);
        }
    }, EI = function(e, t) {
        e.notified || (e.notified = !0, $A(function() {
            for(var n, r = e.reactions; n = r.get();)bI(n, e);
            e.notified = !1, t && !e.rejection && NI(e);
        }));
    }, wI = function(e, t, n) {
        var r, o;
        hI ? ((r = dI.createEvent("Event")).promise = t, r.reason = n, r.initEvent(e, !1, !0), DA.dispatchEvent(r)) : r = {
            promise: t,
            reason: n
        }, !oI && (o = DA["on" + e]) ? o(r) : e === gI && KA("Unhandled promise rejection", n);
    }, NI = function(e) {
        FA(XA, DA, function() {
            var t, n = e.facade, r = e.value;
            if (SI(e) && (t = QA(function() {
                PA ? mI.emit("unhandledRejection", r, n) : wI(gI, n, r);
            }), e.rejection = PA || SI(e) ? 2 : 1, t.error)) throw t.value;
        });
    }, SI = function(e) {
        return 1 !== e.rejection && !e.parent;
    }, TI = function(e) {
        FA(XA, DA, function() {
            var t = e.facade;
            PA ? mI.emit("rejectionHandled", t) : wI("rejectionhandled", t, e.value);
        });
    }, CI = function(e, t, n) {
        return function(r) {
            e(t, r, n);
        };
    }, OI = function(e, t, n) {
        e.done || (e.done = !0, n && (e = n), e.value = t, e.state = 2, EI(e, !0));
    }, RI = function(e, t, n) {
        if (!e.done) {
            e.done = !0, n && (e = n);
            try {
                if (e.facade === t) throw new fI("Promise can't be resolved itself");
                var r = yI(t);
                r ? $A(function() {
                    var n = {
                        done: !1
                    };
                    try {
                        FA(r, t, CI(RI, n, e), CI(OI, n, e));
                    } catch (t) {
                        OI(n, t, e);
                    }
                }) : (e.value = t, e.state = 1, EI(e, !1));
            } catch (t) {
                OI({
                    done: !1
                }, t, e);
            }
        }
    };
    if (rI && (sI = (lI = function(e) {
        YA(this, sI), GA(e), FA(MA, this);
        var t = iI(this);
        try {
            e(CI(RI, t), CI(OI, t));
        } catch (e) {
            OI(t, e);
        }
    }).prototype, (MA = function(e) {
        cI(this, {
            type: nI,
            done: !1,
            notified: !1,
            parent: !1,
            reactions: new JA,
            rejection: !1,
            state: 0,
            value: null
        });
    }).prototype = BA(sI, "then", function(e, t) {
        var n = iI(this), r = pI(qA(this, lI));
        return n.parent = !0, r.ok = !WA(e) || e, r.fail = WA(t) && t, r.domain = PA ? mI.domain : void 0, 0 === n.state ? n.reactions.add(r) : $A(function() {
            bI(r, n);
        }), r.promise;
    }), _A = function() {
        var e = new MA, t = iI(e);
        this.promise = e, this.resolve = CI(RI, t), this.reject = CI(OI, t);
    }, tI.f = pI = function(e) {
        return e === lI || undefined === e ? new _A(e) : vI(e);
    }, WA(eI) && uI !== Object.prototype)) {
        LA = uI.then, aI || BA(uI, "then", function(e, t) {
            var n = this;
            return new lI(function(e, t) {
                FA(LA, n, e, t);
            }).then(e, t);
        }, {
            unsafe: !0
        });
        try {
            delete uI.constructor;
        } catch (e) {}
        HA && HA(uI, sI);
    }
    jA({
        global: !0,
        constructor: !0,
        wrap: !0,
        forced: rI
    }, {
        Promise: lI
    }), UA(lI, nI, !1), zA(nI);
    var xI = {}, kI = xI, AI = Cp("iterator"), II = Array.prototype, MI = ng, _I = fv, LI = Um, jI = xI, PI = Cp("iterator"), DI = function(e) {
        if (!LI(e)) return _I(e, PI) || _I(e, "@@iterator") || jI[MI(e)];
    }, FI = qp, BI = uv, HI = Wp, UI = ov, zI = DI, GI = TypeError, WI = qp, VI = Wp, YI = fv, qI = pg, XI = qp, $I = Wp, KI = ov, QI = function(e) {
        return void 0 !== e && (kI.Array === e || II[AI] === e);
    }, JI = xg, ZI = Qp, eM = function(e, t) {
        var n = arguments.length < 2 ? zI(e) : t;
        if (BI(n)) return HI(FI(n, e));
        throw new GI(UI(e) + " is not iterable");
    }, tM = DI, nM = function(e, t, n) {
        var r, o;
        VI(e);
        try {
            if (!(r = YI(e, "return"))) {
                if ("throw" === t) throw n;
                return n;
            }
            r = WI(r, e);
        } catch (e) {
            o = !0, r = e;
        }
        if ("throw" === t) throw n;
        if (o) throw r;
        return VI(r), n;
    }, rM = TypeError, oM = function(e, t) {
        this.stopped = e, this.result = t;
    }, aM = oM.prototype, iM = function(e, t, n) {
        var r, o, a, i, c, u, l, s = n && n.that, f = !(!n || !n.AS_ENTRIES), d = !(!n || !n.IS_RECORD), m = !(!n || !n.IS_ITERATOR), p = !(!n || !n.INTERRUPTED), v = qI(t, s), h = function(e) {
            return r && nM(r, "normal", e), new oM(!0, e);
        }, g = function(e) {
            return f ? ($I(e), p ? v(e[0], e[1], h) : v(e[0], e[1])) : p ? v(e, h) : v(e);
        };
        if (d) r = e.iterator;
        else if (m) r = e;
        else {
            if (!(o = tM(e))) throw new rM(KI(e) + " is not iterable");
            if (QI(o)) {
                for(a = 0, i = JI(e); i > a; a++)if ((c = g(e[a])) && ZI(aM, c)) return c;
                return new oM(!1);
            }
            r = eM(e, o);
        }
        for(u = d ? e.next : r.next; !(l = XI(u, r)).done;){
            try {
                c = g(l.value);
            } catch (e) {
                nM(r, "throw", e);
            }
            if ("object" == typeof c && c && ZI(aM, c)) return c;
        }
        return new oM(!1);
    }, cM = Cp("iterator"), uM = !1;
    try {
        var lM = 0, sM = {
            next: function() {
                return {
                    done: !!lM++
                };
            },
            return: function() {
                uM = !0;
            }
        };
        sM[cM] = function() {
            return this;
        }, Array.from(sM, function() {
            throw 2;
        });
    } catch (e) {}
    var fM = pA, dM = function(e, t) {
        try {
            if (!t && !uM) return !1;
        } catch (e) {
            return !1;
        }
        var n = !1;
        try {
            var r = {};
            r[cM] = function() {
                return {
                    next: function() {
                        return {
                            done: n = !0
                        };
                    }
                };
            }, e(r);
        } catch (e) {}
        return n;
    }, mM = RA.CONSTRUCTOR || !dM(function(e) {
        fM.all(e).then(void 0, function() {});
    }), pM = qp, vM = uv, hM = xA, gM = mA, yM = iM;
    bx({
        target: "Promise",
        stat: !0,
        forced: mM
    }, {
        all: function(e) {
            var t = this, n = hM.f(t), r = n.resolve, o = n.reject, a = gM(function() {
                var n = vM(t.resolve), a = [], i = 0, c = 1;
                yM(e, function(e) {
                    var u = i++, l = !1;
                    c++, pM(n, t, e).then(function(e) {
                        l || (l = !0, a[u] = e, --c || r(a));
                    }, o);
                }), --c || r(a);
            });
            return a.error && o(a.value), n.promise;
        }
    });
    var bM = bx, EM = RA.CONSTRUCTOR, wM = pA, NM = Kp, SM = kp, TM = Vh, CM = wM && wM.prototype;
    if (bM({
        target: "Promise",
        proto: !0,
        forced: EM,
        real: !0
    }, {
        catch: function(e) {
            return this.then(void 0, e);
        }
    }), SM(wM)) {
        var OM = NM("Promise").prototype.catch;
        CM.catch !== OM && TM(CM, "catch", OM, {
            unsafe: !0
        });
    }
    var RM = qp, xM = uv, kM = xA, AM = mA, IM = iM;
    bx({
        target: "Promise",
        stat: !0,
        forced: mM
    }, {
        race: function(e) {
            var t = this, n = kM.f(t), r = n.reject, o = AM(function() {
                var o = xM(t.resolve);
                IM(e, function(e) {
                    RM(o, t, e).then(n.resolve, r);
                });
            });
            return o.error && r(o.value), n.promise;
        }
    });
    var MM = xA;
    bx({
        target: "Promise",
        stat: !0,
        forced: RA.CONSTRUCTOR
    }, {
        reject: function(e) {
            var t = MM.f(this);
            return (0, t.reject)(e), t.promise;
        }
    });
    var _M = Wp, LM = _p, jM = xA, PM = bx, DM = RA.CONSTRUCTOR, FM = function(e, t) {
        if (_M(e), LM(t) && t.constructor === e) return t;
        var n = jM.f(e);
        return (0, n.resolve)(t), n.promise;
    };
    Kp("Promise"), PM({
        target: "Promise",
        stat: !0,
        forced: DM
    }, {
        resolve: function(e) {
            return FM(this, e);
        }
    });
    var BM = "\t\n\v\f\r                　\u2028\u2029\ufeff", HM = tt, UM = Pi, zM = BM, GM = Ce("".replace), WM = RegExp("^[" + zM + "]+"), VM = RegExp("(^|[^" + zM + "])[" + zM + "]+$"), YM = function(e) {
        return function(t) {
            var n = UM(HM(t));
            return 1 & e && (n = GM(n, WM, "")), 2 & e && (n = GM(n, VM, "$1")), n;
        };
    }, qM = {
        start: YM(1),
        end: YM(2),
        trim: YM(3)
    }, XM = me, $M = pe, KM = Ce, QM = Pi, JM = qM.trim, ZM = BM, e_ = XM.parseInt, t_ = XM.Symbol, n_ = t_ && t_.iterator, r_ = /^[+-]?0x/i, o_ = KM(r_.exec), a_ = 8 !== e_(ZM + "08") || 22 !== e_(ZM + "0x16") || n_ && !$M(function() {
        e_(Object(n_));
    }) ? function(e, t) {
        var n = JM(QM(e));
        return e_(n, t >>> 0 || (o_(r_, n) ? 16 : 10));
    } : e_;
    Br({
        global: !0,
        forced: parseInt !== a_
    }, {
        parseInt: a_
    });
    var i_ = se(ct.parseInt), c_ = function(e) {
        var t = e.width, n = e.children;
        return o.default.createElement("div", {
            className: "Carousel-item",
            style: {
                width: t
            }
        }, n);
    }, u_ = function(e, t) {
        e && (e.style.transform = t, e.style.webkitTransform = t);
    }, l_ = function(e, t) {
        e && (e.style.transition = t, e.style.webkitTransition = t);
    }, s_ = [
        "TEXTAREA",
        "OPTION",
        "INPUT",
        "SELECT"
    ], f_ = Xr("touch"), d_ = o.default.forwardRef(function(e, n) {
        var r, a, i, u = e.className, l = e.startIndex, s = void 0 === l ? 0 : l, f = e.draggable, d = void 0 === f || f, m = e.duration, p = void 0 === m ? 300 : m, v = e.easing, h = void 0 === v ? "ease" : v, g = e.threshold, y = void 0 === g ? 20 : g, b = e.clickDragThreshold, E = void 0 === b ? 10 : b, w = e.loop, N = void 0 === w || w, S = e.rtl, T = void 0 !== S && S, C = e.autoPlay, O = void 0 === C ? e.autoplay || !1 : C, R = e.interval, x = void 0 === R ? e.autoplaySpeed || 4e3 : R, k = e.dots, A = void 0 === k ? e.indicators || !0 : k, I = e.onChange, M = e.children, _ = o.default.Children.count(M), L = "".concat(100 / _, "%"), j = t.useRef(null), P = t.useRef(null), D = t.useRef(null), F = t.useRef({
            first: !0,
            wrapWidth: 0,
            hover: !1,
            startX: 0,
            endX: 0,
            startY: 0,
            canMove: null,
            pressDown: !1
        }), B = t.useCallback({
            "d_.useCallback[B]": function(e) {
                return N ? e % _ : Math.max(0, Math.min(e, _ - 1));
            }
        }["d_.useCallback[B]"], [
            _,
            N
        ]), H = xS(t.useState(B(s)), 2), U = H[0], z = H[1], G = xS(t.useState(!1), 2), W = G[0], V = G[1], Y = t.useCallback({
            "d_.useCallback[Y]": function() {
                var e;
                l_(P.current, VS(e = "transform ".concat(p, "ms ")).call(e, h));
            }
        }["d_.useCallback[Y]"], [
            p,
            h
        ]), q = function() {
            l_(P.current, "transform 0s");
        }, X = function(e) {
            u_(P.current, "translate3d(".concat(e, "px, 0, 0)"));
        }, $ = t.useCallback({
            "d_.useCallback[$]": function(e, t) {
                var n = (T ? 1 : -1) * (N ? e + 1 : e) * F.current.wrapWidth;
                t ? requestAnimationFrame({
                    "d_.useCallback[$]": function() {
                        requestAnimationFrame({
                            "d_.useCallback[$]": function() {
                                Y(), X(n);
                            }
                        }["d_.useCallback[$]"]);
                    }
                }["d_.useCallback[$]"]) : X(n);
            }
        }["d_.useCallback[$]"], [
            Y,
            N,
            T
        ]), K = t.useCallback({
            "d_.useCallback[K]": function(e) {
                if (!(_ <= 1)) {
                    var t = B(e);
                    t !== U && z(t);
                }
            }
        }["d_.useCallback[K]"], [
            U,
            _,
            B
        ]), Q = t.useCallback({
            "d_.useCallback[Q]": function() {
                if (!(_ <= 1)) {
                    var e = U - 1;
                    if (N) {
                        if (e < 0) {
                            var t = F.current, n = (T ? 1 : -1) * (_ + 1) * t.wrapWidth, r = d ? t.endX - t.startX : 0;
                            q(), X(n + r), e = _ - 1;
                        }
                    } else e = Math.max(e, 0);
                    e !== U && z(e);
                }
            }
        }["d_.useCallback[Q]"], [
            U,
            _,
            d,
            N,
            T
        ]), J = t.useCallback({
            "d_.useCallback[J]": function() {
                if (!(_ <= 1)) {
                    var e = U + 1;
                    if (N) {
                        if (e > _ - 1) {
                            e = 0;
                            var t = F.current, n = d ? t.endX - t.startX : 0;
                            q(), X(n);
                        }
                    } else e = Math.min(e, _ - 1);
                    e !== U && z(e);
                }
            }
        }["d_.useCallback[J]"], [
            U,
            _,
            d,
            N
        ]), Z = t.useCallback({
            "d_.useCallback[Z]": function() {
                O && !F.current.hover && (D.current = setTimeout({
                    "d_.useCallback[Z]": function() {
                        Y(), J();
                    }
                }["d_.useCallback[Z]"], x));
            }
        }["d_.useCallback[Z]"], [
            O,
            x,
            Y,
            J
        ]), ee = function() {
            clearTimeout(D.current);
        }, te = function() {
            $(U, !0), Z();
        }, ne = function() {
            var e = F.current, t = (T ? -1 : 1) * (e.endX - e.startX), n = Math.abs(t), r = t > 0 && U - 1 < 0;
            r || t < 0 && U + 1 > _ - 1 ? N ? r ? Q() : J() : te() : t > 0 && n > y && _ > 1 ? Q() : t < 0 && n > y && _ > 1 ? J() : te();
        }, re = function() {
            var e = F.current;
            e.startX = 0, e.endX = 0, e.startY = 0, e.canMove = null, e.pressDown = !1;
        }, oe = function(e) {
            if (!$O(s_).call(s_, e.target.nodeName)) {
                e.stopPropagation();
                var t = "touches" in e ? e.touches[0] : e, n = F.current;
                n.pressDown = !0, n.startX = t.pageX, n.startY = t.pageY, ee();
            }
        }, ae = function(e) {
            e.stopPropagation();
            var t = "touches" in e ? e.touches[0] : e, n = F.current;
            if (n.pressDown) {
                if ("touches" in e && (null === n.canMove && (n.canMove = Math.abs(n.startY - t.pageY) < Math.abs(n.startX - t.pageX)), !n.canMove)) return;
                e.cancelable && e.preventDefault(), q(), n.endX = t.pageX;
                var r = (N ? U + 1 : U) * n.wrapWidth, o = n.endX - n.startX;
                !W && Math.abs(o) > E && V(!0), X(T ? r + o : o - r);
            }
        }, ie = function(e) {
            e.stopPropagation();
            var t = F.current;
            t.pressDown = !1, V(!1), Y(), t.endX ? ne() : Z(), re();
        }, ce = function() {
            F.current.hover = !0, ee();
        }, ue = function(e) {
            var t = F.current;
            t.hover = !1, t.pressDown && (t.pressDown = !1, t.endX = e.pageX, Y(), ne(), re()), Z();
        }, le = function(e) {
            var t = e.currentTarget.dataset.slideTo;
            if (t) {
                var n = i_(t, 10);
                K(n);
            }
        };
        return t.useImperativeHandle(n, {
            "d_.useImperativeHandle": function() {
                return {
                    goTo: K,
                    prev: Q,
                    next: J
                };
            }
        }["d_.useImperativeHandle"], [
            K,
            Q,
            J
        ]), t.useEffect({
            "d_.useEffect": function() {
                function e() {
                    F.current.wrapWidth = j.current.offsetWidth, $(U);
                }
                return F.current.first && e(), window.addEventListener("resize", e), ({
                    "d_.useEffect": function() {
                        window.removeEventListener("resize", e);
                    }
                })["d_.useEffect"];
            }
        }["d_.useEffect"], [
            U,
            $
        ]), t.useEffect({
            "d_.useEffect": function() {
                I && !F.current.first && I(U);
            }
        }["d_.useEffect"], [
            U,
            I
        ]), t.useEffect({
            "d_.useEffect": function() {
                F.current.first ? ($(U), F.current.first = !1) : $(U, !0);
            }
        }["d_.useEffect"], [
            U,
            $
        ]), t.useEffect({
            "d_.useEffect": function() {
                return Z(), ({
                    "d_.useEffect": function() {
                        ee();
                    }
                })["d_.useEffect"];
            }
        }["d_.useEffect"], [
            O,
            U,
            Z
        ]), i = d && _ > 1 ? f_ ? {
            onTouchStart: oe,
            onTouchMove: ae,
            onTouchEnd: ie
        } : {
            onMouseDown: oe,
            onMouseMove: ae,
            onMouseUp: ie,
            onMouseEnter: ce,
            onMouseLeave: ue
        } : {
            onMouseEnter: ce,
            onMouseLeave: ue
        }, o.default.createElement("div", aC({
            className: c("Carousel", {
                "Carousel--draggable": d,
                "Carousel--rtl": T,
                "Carousel--dragging": W
            }, u),
            ref: j
        }, i), o.default.createElement("div", {
            className: "Carousel-inner",
            style: {
                width: "".concat(N ? _ + 2 : _, "00%")
            },
            ref: P
        }, N && o.default.createElement(c_, {
            width: L
        }, o.default.Children.toArray(M)[_ - 1]), HS(r = o.default.Children).call(r, M, function(e, t) {
            return o.default.createElement(c_, {
                width: L,
                key: t
            }, e);
        }), N && o.default.createElement(c_, {
            width: L
        }, o.default.Children.toArray(M)[0])), A && o.default.createElement("ol", {
            className: "Carousel-dots"
        }, HS(a = o.default.Children).call(a, M, function(e, t) {
            return o.default.createElement("li", {
                key: t
            }, o.default.createElement("button", {
                className: c("Carousel-dot", {
                    active: U === t
                }),
                type: "button",
                "aria-label": "Go to slide ".concat(t + 1),
                "data-slide-to": t,
                onClick: le
            }));
        })));
    }), m_ = [
        "className",
        "label",
        "checked",
        "disabled",
        "onChange"
    ], p_ = function(e) {
        var t = e.className, n = e.label, r = e.checked, a = e.disabled, i = e.onChange, u = EC(e, m_);
        return o.default.createElement("label", {
            className: c("Checkbox", t, {
                "Checkbox--checked": r,
                "Checkbox--disabled": a
            })
        }, o.default.createElement("input", aC({
            type: "checkbox",
            className: "Checkbox-input",
            checked: r,
            disabled: a,
            onChange: i
        }, u)), o.default.createElement("span", {
            className: "Checkbox-text"
        }, n));
    }, v_ = [
        "children",
        "onClick",
        "mouseEvent"
    ], h_ = document, g_ = h_.documentElement, y_ = function(e) {
        var n = e.children, r = e.onClick, a = e.mouseEvent, i = void 0 === a ? "mouseup" : a, c = EC(e, v_), u = t.useRef(null);
        function l(e) {
            u.current && g_.contains(e.target) && !u.current.contains(e.target) && r(e);
        }
        return t.useEffect({
            "y_.useEffect": function() {
                return i && h_.addEventListener(i, l), ({
                    "y_.useEffect": function() {
                        h_.removeEventListener(i, l);
                    }
                })["y_.useEffect"];
            }
        }["y_.useEffect"]), o.default.createElement("div", aC({
            ref: u
        }, c), n);
    }, b_ = [
        "className",
        "position",
        "children"
    ], E_ = [
        "className",
        "theme",
        "children"
    ], w_ = o.default.createContext(""), N_ = [
        "children"
    ], S_ = function(e) {
        var t = e.children, n = EC(e, N_);
        return o.default.createElement("label", aC({
            className: "Label"
        }, n), t);
    }, T_ = [
        "children"
    ], C_ = function(e) {
        var t = e.children, n = EC(e, T_);
        return o.default.createElement("div", aC({
            className: "HelpText"
        }, n), t);
    }, O_ = [
        "children"
    ], R_ = [
        "className",
        "icon",
        "img"
    ], x_ = function(e) {
        var t = e.className, n = e.icon, r = e.img, a = EC(e, R_);
        return o.default.createElement(pO, aC({
            className: c("IconBtn", t),
            "data-icon": n
        }, a), n && o.default.createElement(fO, {
            type: n
        }), !n && r && o.default.createElement("img", {
            src: r,
            alt: ""
        }));
    };
    function k_(e) {
        return e.scrollHeight - e.scrollTop - e.offsetHeight;
    }
    var A_ = [
        "className",
        "disabled",
        "distance",
        "children",
        "onLoadMore",
        "onScroll"
    ], I_ = o.default.forwardRef(function(e, t) {
        var n = e.className, r = e.disabled, a = e.distance, i = void 0 === a ? 0 : a, u = e.children, l = e.onLoadMore, s = e.onScroll, f = EC(e, A_), d = gm(t);
        return o.default.createElement("div", aC({
            className: c("InfiniteScroll", n),
            role: "feed",
            onScroll: r ? void 0 : function(e) {
                s && s(e);
                var t = d.current;
                t && k_(t) <= i && l();
            },
            ref: d
        }, f), u);
    }), M_ = Em, __ = kp, L_ = _p, j_ = Px, P_ = Hm(1..valueOf), D_ = Wm, F_ = eT, B_ = "\t\n\v\f\r                　\u2028\u2029\ufeff", H_ = Hm("".replace), U_ = RegExp("^[" + B_ + "]+"), z_ = RegExp("(^|[^" + B_ + "])[" + B_ + "]+$"), G_ = function(e) {
        return function(t) {
            var n = F_(D_(t));
            return 1 & e && (n = H_(n, U_, "")), 2 & e && (n = H_(n, z_, "$1")), n;
        };
    }, W_ = {
        start: G_(1),
        end: G_(2),
        trim: G_(3)
    }, V_ = bx, Y_ = Ip, q_ = Em, X_ = M_, $_ = Hm, K_ = fx, Q_ = Km, J_ = function(e, t, n) {
        var r, o;
        return j_ && __(r = t.constructor) && r !== n && L_(o = r.prototype) && o !== n.prototype && j_(e, o), e;
    }, Z_ = Qp, eL = nv, tL = Sv, nL = Lm, rL = TR.f, oL = cR.f, aL = Ap.f, iL = P_, cL = W_.trim, uL = "Number", lL = q_[uL];
    X_[uL];
    var sL = lL.prototype, fL = q_.TypeError, dL = $_("".slice), mL = $_("".charCodeAt), pL = function(e) {
        var t, n, r, o, a, i, c, u, l = tL(e, "number");
        if (eL(l)) throw new fL("Cannot convert a Symbol value to a number");
        if ("string" == typeof l && l.length > 2) {
            if (l = cL(l), 43 === (t = mL(l, 0)) || 45 === t) {
                if (88 === (n = mL(l, 2)) || 120 === n) return NaN;
            } else if (48 === t) {
                switch(mL(l, 1)){
                    case 66:
                    case 98:
                        r = 2, o = 49;
                        break;
                    case 79:
                    case 111:
                        r = 8, o = 55;
                        break;
                    default:
                        return +l;
                }
                for(i = (a = dL(l, 2)).length, c = 0; c < i; c++)if ((u = mL(a, c)) < 48 || u > o) return NaN;
                return parseInt(a, r);
            }
        }
        return +l;
    }, vL = K_(uL, !lL(" 0o1") || !lL("0b1") || lL("+0x1")), hL = function(e) {
        var t, n = arguments.length < 1 ? 0 : lL(function(e) {
            var t = tL(e, "number");
            return "bigint" == typeof t ? t : pL(t);
        }(e));
        return Z_(sL, t = this) && nL(function() {
            iL(t);
        }) ? J_(Object(n), this, hL) : n;
    };
    hL.prototype = sL, vL && (sL.constructor = hL), V_({
        global: !0,
        constructor: !0,
        wrap: !0,
        forced: vL
    }, {
        Number: hL
    });
    vL && function(e, t) {
        for(var n, r = Y_ ? rL(t) : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(","), o = 0; r.length > o; o++)Q_(t, n = r[o]) && !Q_(e, n) && aL(e, n, oL(t, n));
    }(X_[uL], lL);
    var gL = Lm, yL = Em.RegExp, bL = gL(function() {
        var e = yL("a", "y");
        return e.lastIndex = 2, null !== e.exec("abcd");
    }), EL = bL || gL(function() {
        return !yL("a", "y").sticky;
    }), wL = {
        BROKEN_CARET: bL || gL(function() {
            var e = yL("^r", "gy");
            return e.lastIndex = 2, null !== e.exec("str");
        }),
        MISSED_STICKY: EL,
        UNSUPPORTED_Y: bL
    }, NL = {}, SL = FR, TL = BR, CL = Object.keys || function(e) {
        return SL(e, TL);
    }, OL = Ip, RL = Hp, xL = Ap, kL = Wp, AL = pR, IL = CL;
    NL.f = OL && !RL ? Object.defineProperties : function(e, t) {
        kL(e);
        for(var n, r = AL(t), o = IL(t), a = o.length, i = 0; a > i;)xL.f(e, n = o[i++], r[n]);
        return e;
    };
    var ML, _L = Wp, LL = NL, jL = BR, PL = uh, DL = ck, FL = Dp, BL = "prototype", HL = "script", UL = ch("IE_PROTO"), zL = function() {}, GL = function(e) {
        return "<" + HL + ">" + e + "</" + HL + ">";
    }, WL = function(e) {
        e.write(GL("")), e.close();
        var t = e.parentWindow.Object;
        return e = null, t;
    }, VL = function() {
        try {
            ML = new ActiveXObject("htmlfile");
        } catch (e) {}
        var e, t, n;
        VL = "undefined" != typeof document ? document.domain && ML ? WL(ML) : (t = FL("iframe"), n = "java" + HL + ":", t.style.display = "none", DL.appendChild(t), t.src = String(n), (e = t.contentWindow.document).open(), e.write(GL("document.F=Object")), e.close(), e.F) : WL(ML);
        for(var r = jL.length; r--;)delete VL[BL][jL[r]];
        return VL();
    };
    PL[UL] = !0;
    var YL, qL, XL = Object.create || function(e, t) {
        var n;
        return null !== e ? (zL[BL] = _L(e), n = new zL, zL[BL] = null, n[UL] = e) : n = VL(), void 0 === t ? n : LL.f(n, t);
    }, $L = Lm, KL = Em.RegExp, QL = $L(function() {
        var e = KL(".", "s");
        return !(e.dotAll && e.test("\n") && "s" === e.flags);
    }), JL = Lm, ZL = Em.RegExp, ej = JL(function() {
        var e = ZL("(?<a>b)", "g");
        return "b" !== e.exec("b").groups.a || "bc" !== "b".replace(e, "$<a>c");
    }), tj = qp, nj = Hm, rj = eT, oj = nT, aj = wL, ij = XL, cj = Nh.get, uj = QL, lj = ej, sj = _m("native-string-replace", String.prototype.replace), fj = RegExp.prototype.exec, dj = fj, mj = nj("".charAt), pj = nj("".indexOf), vj = nj("".replace), hj = nj("".slice), gj = (qL = /b*/g, tj(fj, YL = /a/, "a"), tj(fj, qL, "a"), 0 !== YL.lastIndex || 0 !== qL.lastIndex), yj = aj.BROKEN_CARET, bj = void 0 !== /()??/.exec("")[1];
    (gj || bj || yj || uj || lj) && (dj = function(e) {
        var t, n, r, o, a, i, c, u = this, l = cj(u), s = rj(e), f = l.raw;
        if (f) return f.lastIndex = u.lastIndex, t = tj(dj, f, s), u.lastIndex = f.lastIndex, t;
        var d = l.groups, m = yj && u.sticky, p = tj(oj, u), v = u.source, h = 0, g = s;
        if (m && (p = vj(p, "y", ""), -1 === pj(p, "g") && (p += "g"), g = hj(s, u.lastIndex), u.lastIndex > 0 && (!u.multiline || u.multiline && "\n" !== mj(s, u.lastIndex - 1)) && (v = "(?: " + v + ")", g = " " + g, h++), n = new RegExp("^(?:" + v + ")", p)), bj && (n = new RegExp("^" + v + "$(?!\\s)", p)), gj && (r = u.lastIndex), o = tj(fj, m ? n : u, g), m ? o ? (o.input = hj(o.input, h), o[0] = hj(o[0], h), o.index = u.lastIndex, u.lastIndex += o[0].length) : u.lastIndex = 0 : gj && o && (u.lastIndex = u.global ? o.index + o[0].length : r), bj && o && o.length > 1 && tj(sj, o[0], n, function() {
            for(a = 1; a < arguments.length - 2; a++)void 0 === arguments[a] && (o[a] = void 0);
        }), o && d) for(o.groups = i = ij(null), a = 0; a < d.length; a++)i[(c = d[a])[0]] = o[c[1]];
        return o;
    });
    var Ej = dj;
    bx({
        target: "RegExp",
        proto: !0,
        forced: /./.exec !== Ej
    }, {
        exec: Ej
    });
    var wj = qp, Nj = Vh, Sj = Ej, Tj = Lm, Cj = Cp, Oj = oh, Rj = Cj("species"), xj = RegExp.prototype, kj = function(e, t, n, r) {
        var o = Cj(e), a = !Tj(function() {
            var t = {};
            return t[o] = function() {
                return 7;
            }, 7 !== ""[e](t);
        }), i = a && !Tj(function() {
            var t = !1, n = /a/;
            return "split" === e && ((n = {}).constructor = {}, n.constructor[Rj] = function() {
                return n;
            }, n.flags = "", n[o] = /./[o]), n.exec = function() {
                return t = !0, null;
            }, n[o](""), !t;
        });
        if (!a || !i || n) {
            var c = /./[o], u = t(o, ""[e], function(e, t, n, r, o) {
                var i = t.exec;
                return i === Sj || i === xj.exec ? a && !o ? {
                    done: !0,
                    value: wj(c, t, n, r)
                } : {
                    done: !0,
                    value: wj(e, n, t, r)
                } : {
                    done: !1
                };
            });
            Nj(String.prototype, e, u[0]), Nj(xj, o, u[1]);
        }
        r && Oj(xj[o], "sham", !0);
    }, Aj = Hm, Ij = Sg, Mj = eT, _j = Wm, Lj = Aj("".charAt), jj = Aj("".charCodeAt), Pj = Aj("".slice), Dj = function(e) {
        return function(t, n) {
            var r, o, a = Mj(_j(t)), i = Ij(n), c = a.length;
            return i < 0 || i >= c ? e ? "" : void 0 : (r = jj(a, i)) < 55296 || r > 56319 || i + 1 === c || (o = jj(a, i + 1)) < 56320 || o > 57343 ? e ? Lj(a, i) : r : e ? Pj(a, i, i + 2) : o - 56320 + (r - 55296 << 10) + 65536;
        };
    }, Fj = {
        codeAt: Dj(!1),
        charAt: Dj(!0)
    }.charAt, Bj = function(e, t, n) {
        return t + (n ? Fj(e, t).length : 1);
    }, Hj = Hm, Uj = qm, zj = Math.floor, Gj = Hj("".charAt), Wj = Hj("".replace), Vj = Hj("".slice), Yj = /\$([$&'`]|\d{1,2}|<[^>]*>)/g, qj = /\$([$&'`]|\d{1,2})/g, Xj = qp, $j = Wp, Kj = kp, Qj = $h, Jj = Ej, Zj = TypeError, eP = function(e, t) {
        var n = e.exec;
        if (Kj(n)) {
            var r = Xj(n, e, t);
            return null !== r && $j(r), r;
        }
        if ("RegExp" === Qj(e)) return Xj(Jj, e, t);
        throw new Zj("RegExp#exec called on incompatible receiver");
    }, tP = ik, nP = qp, rP = Hm, oP = kj, aP = Lm, iP = Wp, cP = kp, uP = Um, lP = Sg, sP = Og, fP = eT, dP = Wm, mP = Bj, pP = fv, vP = function(e, t, n, r, o, a) {
        var i = n + e.length, c = r.length, u = qj;
        return void 0 !== o && (o = Uj(o), u = Yj), Wj(a, u, function(a, u) {
            var l;
            switch(Gj(u, 0)){
                case "$":
                    return "$";
                case "&":
                    return e;
                case "`":
                    return Vj(t, 0, n);
                case "'":
                    return Vj(t, i);
                case "<":
                    l = o[Vj(u, 1, -1)];
                    break;
                default:
                    var s = +u;
                    if (0 === s) return a;
                    if (s > c) {
                        var f = zj(s / 10);
                        return 0 === f ? a : f <= c ? void 0 === r[f - 1] ? Gj(u, 1) : r[f - 1] + Gj(u, 1) : a;
                    }
                    l = r[s - 1];
            }
            return void 0 === l ? "" : l;
        });
    }, hP = eP, gP = Cp("replace"), yP = Math.max, bP = Math.min, EP = rP([].concat), wP = rP([].push), NP = rP("".indexOf), SP = rP("".slice), TP = "$0" === "a".replace(/./, "$0"), CP = !!/./[gP] && "" === /./[gP]("a", "$0");
    oP("replace", function(e, t, n) {
        var r = CP ? "$" : "$0";
        return [
            function(e, n) {
                var r = dP(this), o = uP(e) ? void 0 : pP(e, gP);
                return o ? nP(o, e, r, n) : nP(t, fP(r), e, n);
            },
            function(e, o) {
                var a = iP(this), i = fP(e);
                if ("string" == typeof o && -1 === NP(o, r) && -1 === NP(o, "$<")) {
                    var c = n(t, a, i, o);
                    if (c.done) return c.value;
                }
                var u = cP(o);
                u || (o = fP(o));
                var l, s = a.global;
                s && (l = a.unicode, a.lastIndex = 0);
                for(var f, d = []; null !== (f = hP(a, i)) && (wP(d, f), s);){
                    "" === fP(f[0]) && (a.lastIndex = mP(i, sP(a.lastIndex), l));
                }
                for(var m, p = "", v = 0, h = 0; h < d.length; h++){
                    for(var g, y = fP((f = d[h])[0]), b = yP(bP(lP(f.index), i.length), 0), E = [], w = 1; w < f.length; w++)wP(E, void 0 === (m = f[w]) ? m : String(m));
                    var N = f.groups;
                    if (u) {
                        var S = EP([
                            y
                        ], E, b, i);
                        void 0 !== N && wP(S, N), g = fP(tP(o, void 0, S));
                    } else g = vP(y, i, b, E, N, o);
                    b >= v && (p += SP(i, v, b) + g, v = b + y.length);
                }
                return p + SP(i, v);
            }
        ];
    }, !!aP(function() {
        var e = /./;
        return e.exec = function() {
            var e = [];
            return e.groups = {
                a: "7"
            }, e;
        }, "7" !== "".replace(e, "$<a>");
    }) || !TP || CP);
    var OP = [
        "className",
        "type",
        "variant",
        "value",
        "placeholder",
        "rows",
        "minRows",
        "maxRows",
        "maxLength",
        "showCount",
        "multiline",
        "autoSize",
        "onChange"
    ];
    var RP = o.default.forwardRef(function(e, n) {
        var r = e.className, a = e.type, i = void 0 === a ? "text" : a, u = e.variant, l = e.value, s = e.placeholder, f = e.rows, d = void 0 === f ? 1 : f, m = e.minRows, p = void 0 === m ? d : m, v = e.maxRows, h = void 0 === v ? 5 : v, g = e.maxLength, y = e.showCount, b = void 0 === y ? !!g : y, E = e.multiline, w = e.autoSize, N = e.onChange, S = EC(e, OP), T = d;
        T < p ? T = p : T > h && (T = h);
        var C = xS(t.useState(T), 2), O = C[0], R = C[1], x = xS(t.useState(21), 2), k = x[0], A = x[1], I = gm(n), M = t.useContext(w_), _ = u || ("light" === M ? "flushed" : "outline"), L = E || w || d > 1 ? "textarea" : "input";
        t.useEffect({
            "RP.useEffect": function() {
                if (I.current) {
                    var e = getComputedStyle(I.current, null).lineHeight, t = Number(e.replace("px", ""));
                    t !== k && A(t);
                }
            }
        }["RP.useEffect"], [
            I,
            k
        ]);
        var j = t.useCallback({
            "RP.useCallback[j]": function() {
                if (w && I.current) {
                    var e = I.current, t = e.rows;
                    e.rows = p, s && (e.placeholder = "");
                    var n = ~~(e.scrollHeight / k);
                    n === t && (e.rows = n), n >= h && (e.rows = h, e.scrollTop = e.scrollHeight), R(n < h ? n : h), s && (e.placeholder = s);
                }
            }
        }["RP.useCallback[j]"], [
            w,
            I,
            k,
            h,
            p,
            s
        ]);
        t.useEffect({
            "RP.useEffect": function() {
                "" === l ? R(T) : j();
            }
        }["RP.useEffect"], [
            T,
            j,
            l
        ]);
        var P = t.useCallback({
            "RP.useCallback[P]": function(e) {
                if (j(), N) {
                    var t = e.target.value, n = g && t.length > g ? t.substr(0, g) : t;
                    N(n, e);
                }
            }
        }["RP.useCallback[P]"], [
            g,
            N,
            j
        ]), D = o.default.createElement(L, aC({
            className: c("Input", "Input--".concat(_), r),
            type: i,
            value: l,
            placeholder: s,
            maxLength: g,
            ref: I,
            rows: O,
            onChange: P
        }, S));
        return b ? o.default.createElement("div", {
            className: c("InputWrapper", {
                "has-counter": b
            })
        }, D, b && o.default.createElement("div", {
            className: "Input-counter"
        }, function(e, t) {
            var n;
            return VS(n = "".concat("".concat(e).length)).call(n, t ? "/".concat(t) : "");
        }(l, g))) : D;
    }), xP = o.default.forwardRef(function(e, t) {
        var n = e.bordered, r = void 0 !== n && n, a = e.className, i = e.variant, u = e.children;
        return o.default.createElement("div", {
            className: c("List", {
                "List--bordered": r
            }, a),
            "data-variant": i,
            role: "list",
            ref: t
        }, u);
    }), kP = [
        "className",
        "as",
        "content",
        "ellipsis",
        "rightIcon",
        "children",
        "onClick"
    ], AP = o.default.forwardRef(function(e, t) {
        var n = e.className, r = e.as, a = void 0 === r ? "div" : r, i = e.content, u = e.ellipsis, l = e.rightIcon, s = e.children, f = e.onClick, d = EC(e, kP);
        return o.default.createElement(a, aC({
            className: c("ListItem", n),
            onClick: f,
            role: "listitem"
        }, d, {
            ref: t
        }), o.default.createElement(eR, {
            className: "ListItem-content",
            truncate: u
        }, i || s), l && o.default.createElement(fO, {
            type: l
        }));
    }), IP = {
        BackBottom: {
            newMsgOne: "{n} رسالة جديدة",
            newMsgOther: "{n} رسالة جديدة",
            bottom: "الأسفل"
        },
        Time: {
            weekdays: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"),
            formats: {
                LT: "HH:mm",
                lll: "YYYY/M/D HH:mm",
                WT: "HH:mm dddd",
                YT: "HH:mm أمس"
            }
        },
        Composer: {
            send: "إرسال"
        },
        SendConfirm: {
            title: "إرسال صورة",
            send: "أرسل",
            cancel: "إلغاء"
        },
        RateActions: {
            up: "التصويت",
            down: "تصويت سلبي"
        },
        Recorder: {
            hold2talk: "أستمر بالضغط لتتحدث",
            release2send: "حرر للإرسال",
            releaseOrSwipe: "حرر للإرسال ، اسحب لأعلى للإلغاء",
            release2cancel: "حرر للإلغاء"
        },
        Search: {
            search: "يبحث"
        }
    }, MP = {
        BackBottom: {
            newMsgOne: "{n} new message",
            newMsgOther: "{n} new messages",
            bottom: "Bottom"
        },
        Time: {
            weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
            formats: {
                LT: "HH:mm",
                lll: "M/D/YYYY HH:mm",
                WT: "dddd HH:mm",
                YT: "Yesterday HH:mm"
            }
        },
        Composer: {
            send: "Send"
        },
        SendConfirm: {
            title: "Send photo",
            send: "Send",
            cancel: "Cancel"
        },
        RateActions: {
            up: "Up vote",
            down: "Down vote"
        },
        Recorder: {
            hold2talk: "Hold to Talk",
            release2send: "Release to Send",
            releaseOrSwipe: "Release to send, swipe up to cancel",
            release2cancel: "Release to cancel"
        },
        Search: {
            search: "Search"
        }
    }, _P = {
        "ar-EG": IP,
        "fr-FR": {
            BackBottom: {
                newMsgOne: "{n} nouveau message",
                newMsgOther: "{n} nouveau messages",
                bottom: "Fond"
            },
            Time: {
                weekdays: "Dimanche_Lundi_Mardi_Mercredi_Jeudi_Vendredi_Samedi".split("_"),
                formats: {
                    LT: "HH:mm",
                    lll: "D/M/YYYY HH:mm",
                    WT: "dddd HH:mm",
                    YT: "Hier HH:mm"
                }
            },
            Composer: {
                send: "Envoyer"
            },
            SendConfirm: {
                title: "Envoyer une photo",
                send: "Envoyer",
                cancel: "Annuler"
            },
            RateActions: {
                up: "Voter pour",
                down: "Vote négatif"
            },
            Recorder: {
                hold2talk: "Tenir pour parler",
                release2send: "Libérer pour envoyer",
                releaseOrSwipe: "Relâchez pour envoyer, balayez vers le haut pour annuler",
                release2cancel: "Relâcher pour annuler"
            },
            Search: {
                search: "Chercher"
            }
        },
        "en-US": MP,
        "zh-CN": {
            BackBottom: {
                newMsgOne: "{n}条新消息",
                newMsgOther: "{n}条新消息",
                bottom: "回到底部"
            },
            Time: {
                weekdays: "星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"),
                formats: {
                    LT: "HH:mm",
                    lll: "YYYY年M月D日 HH:mm",
                    WT: "dddd HH:mm",
                    YT: "昨天 HH:mm"
                }
            },
            Composer: {
                send: "发送"
            },
            SendConfirm: {
                title: "发送图片",
                send: "发送",
                cancel: "取消"
            },
            RateActions: {
                up: "赞同",
                down: "反对"
            },
            Recorder: {
                hold2talk: "按住 说话",
                release2send: "松开 发送",
                releaseOrSwipe: "松开发送，上滑取消",
                release2cancel: "松开手指，取消发送"
            },
            Search: {
                search: "搜索"
            }
        }
    };
    function LP(e, t) {
        var n = gy(e);
        if (rw) {
            var r = rw(e);
            t && (r = QS(r).call(r, function(t) {
                return dw(e, t).enumerable;
            })), n.push.apply(n, r);
        }
        return n;
    }
    function jP(e) {
        for(var t = 1; t < arguments.length; t++){
            var n = null != arguments[t] ? arguments[t] : {};
            t % 2 ? LP(Object(n), !0).forEach(function(t) {
                LS(e, t, n[t]);
            }) : ww ? xw(e, ww(n)) : LP(Object(n)).forEach(function(t) {
                Yr(e, t, dw(n, t));
            });
        }
        return e;
    }
    var PP = "en-US", DP = o.default.createContext({}), FP = function(e) {
        var t = e.locale, n = void 0 === t ? PP : t, r = e.locales, a = e.colorScheme, i = e.elderMode, c = e.children;
        return o.default.createElement(DP.Provider, {
            value: {
                locale: n,
                locales: r,
                colorScheme: a,
                elderMode: i
            }
        }, c);
    }, BP = function() {
        return t.useContext(DP);
    }, HP = function(e, n) {
        var r = t.useContext(DP), o = r.locale, a = r.locales, i = jP(jP({}, o && _P[o] || _P[PP]), a);
        return o || a || !n ? e && (i = i[e] || {}) : i = n, {
            locale: o,
            trans: function(e) {
                return e ? i[e] : i;
            }
        };
    }, UP = function(e) {
        var n = e.className, r = e.content, a = e.action, i = a || {}, u = i.onClick, l = i.once, s = xS(t.useState(a && a.disabled), 2), f = s[0], d = s[1];
        return o.default.createElement("div", {
            className: c("Message SystemMessage", n)
        }, o.default.createElement("div", {
            className: "SystemMessage-inner"
        }, o.default.createElement("span", null, r), a && o.default.createElement(pO, {
            variant: "text",
            disabled: f,
            onClick: function(e) {
                u && u(e), l && d(!0);
            }
        }, a.text)));
    }, zP = /YYYY|M|D|dddd|HH|mm/g, GP = 864e5, WP = function(e) {
        return (e <= 9 ? "0" : "") + e;
    }, VP = function(e) {
        var t = new Date((new Date).setHours(0, 0, 0, 0)).getTime() - e.getTime();
        return t < 0 ? "LT" : t < GP ? "YT" : t < 6048e5 ? "WT" : "lll";
    };
    function YP(e, t) {
        var n = function(e) {
            return e instanceof Date ? e : new Date(e);
        }(e), r = t.formats[VP(n)], o = {
            YYYY: "".concat(n.getFullYear()),
            M: "".concat(n.getMonth() + 1),
            D: "".concat(n.getDate()),
            dddd: t.weekdays[n.getDay()],
            HH: WP(n.getHours()),
            mm: WP(n.getMinutes())
        };
        return r.replace(zP, function(e) {
            return o[e];
        });
    }
    var qP = function(e) {
        var t = e.date, n = HP("Time").trans, r = new Date(t).toLocaleString("zh").replace(/\//g, "-");
        return o.default.createElement("time", {
            className: "Time",
            dateTime: r
        }, YP(t, n()));
    }, XP = [
        "renderMessageContent"
    ], $P = function(e) {
        var t = e.renderMessageContent, n = void 0 === t ? function() {
            return null;
        } : t, r = EC(e, XP), a = r.type, i = r.content, u = r.user, l = void 0 === u ? {} : u, s = r._id, f = r.position, d = void 0 === f ? "left" : f, m = r.hasTime, p = void 0 === m || m, v = r.createdAt, h = l.name, g = l.avatar;
        if ("system" === a) return o.default.createElement(UP, {
            content: i.text,
            action: i.action
        });
        var y = "right" === d || "left" === d;
        return o.default.createElement("div", {
            className: c("Message", d),
            "data-id": s,
            "data-type": a
        }, p && v && o.default.createElement("div", {
            className: "Message-meta"
        }, o.default.createElement(qP, {
            date: v
        })), o.default.createElement("div", {
            className: "Message-main"
        }, y && g && o.default.createElement(aO, {
            src: g,
            shape: "square",
            alt: h,
            url: l.url
        }), o.default.createElement("div", {
            className: "Message-inner"
        }, y && h && o.default.createElement("div", {
            className: "Message-author"
        }, h), o.default.createElement("div", {
            className: "Message-content",
            role: "alert",
            "aria-live": "assertive",
            "aria-atomic": "false"
        }, n(r)))));
    }, KP = o.default.memo($P), QP = 0;
    function JP() {
        var e, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "id-";
        return t.useRef(VS(e = "".concat(n)).call(e, QP++)).current;
    }
    var ZP = function(e, t) {
        (arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : document.body).classList[t ? "add" : "remove"](e);
    };
    function eD() {
        document.querySelector(".Modal") || document.querySelector(".Popup") || ZP("S--modalOpen", !1);
    }
    var tD = function(e) {
        var r, a, i = e.baseClass, u = e.active, l = e.className, s = e.title, f = e.subTitle, d = e.showClose, m = void 0 === d || d, p = e.autoFocus, v = void 0 === p || p, h = e.backdrop, g = void 0 === h || h, y = e.height, b = e.overflow, E = e.actions, w = e.vertical, N = void 0 === w || w, S = e.btnVariant, T = e.bgColor, C = e.avatar, O = e.children, R = e.onBackdropClick, x = e.onClose, k = JP("modal-"), A = e.titleId || k, I = BP(), M = t.useRef(null), _ = ST({
            active: u,
            ref: M
        }), L = _.didMount, j = _.isShow;
        if (t.useEffect({
            "tD.useEffect": function() {
                setTimeout({
                    "tD.useEffect": function() {
                        v && M.current && M.current.focus();
                    }
                }["tD.useEffect"]);
            }
        }["tD.useEffect"], [
            v
        ]), t.useEffect({
            "tD.useEffect": function() {
                j && ZP("S--modalOpen", j);
            }
        }["tD.useEffect"], [
            j
        ]), t.useEffect({
            "tD.useEffect": function() {
                u || L || eD();
            }
        }["tD.useEffect"], [
            u,
            L
        ]), t.useEffect({
            "tD.useEffect": function() {
                return ({
                    "tD.useEffect": function() {
                        eD();
                    }
                })["tD.useEffect"];
            }
        }["tD.useEffect"], []), !L) return null;
        var P = "Popup" === i, D = C && "Modal" === i;
        return n.createPortal(o.default.createElement("div", {
            className: c(i, l, {
                active: j
            }),
            tabIndex: -1,
            "data-elder-mode": I.elderMode,
            ref: M
        }, g && o.default.createElement(cO, {
            active: j,
            onClick: !0 === g ? R || x : void 0
        }), o.default.createElement("div", {
            className: c("".concat(i, "-dialog"), {
                "pb-safe": P && !E
            }),
            "data-bg-color": T,
            "data-height": P && y ? y : void 0,
            "data-has-avatar": D,
            role: "dialog",
            "aria-labelledby": A,
            "aria-modal": !0
        }, o.default.createElement("div", {
            className: "".concat(i, "-content")
        }, D && o.default.createElement("div", {
            className: "".concat(i, "-avatar"),
            style: {
                "--avatar": "url(".concat(C, ")")
            }
        }), o.default.createElement("div", {
            className: "".concat(i, "-header")
        }, o.default.createElement("h5", {
            className: "".concat(i, "-title"),
            id: A
        }, s), P && f && o.default.createElement("h6", {
            className: "".concat(i, "-subtitle")
        }, f), m && x && o.default.createElement(x_, {
            className: "".concat(i, "-close"),
            icon: "close",
            size: "lg",
            onClick: x,
            "aria-label": "关闭"
        })), o.default.createElement("div", {
            className: c("".concat(i, "-body"), {
                overflow: b
            })
        }, O), E && o.default.createElement("div", {
            className: VS(r = VS(a = "".concat(i, "-footer ")).call(a, i, "-footer--")).call(r, N ? "v" : "h"),
            "data-variant": S || "round"
        }, HS(E).call(E, function(e) {
            return o.default.createElement(pO, aC({
                size: "lg",
                block: P,
                variant: S
            }, e, {
                key: e.label
            }));
        }))))), document.body);
    }, nD = function(e) {
        return o.default.createElement(tD, aC({
            baseClass: "Modal",
            btnVariant: !1 === e.vertical ? void 0 : "outline"
        }, e));
    }, rD = jt, oD = TypeError, aD = bl, iD = Math.floor, cD = function(e, t) {
        var n = e.length;
        if (n < 8) for(var r, o, a = 1; a < n;){
            for(o = a, r = e[a]; o && t(e[o - 1], r) > 0;)e[o] = e[--o];
            o !== a++ && (e[o] = r);
        }
        else for(var i = iD(n / 2), c = cD(aD(e, 0, i), t), u = cD(aD(e, i), t), l = c.length, s = u.length, f = 0, d = 0; f < l || d < s;)e[f + d] = f < l && d < s ? t(c[f], u[d]) <= 0 ? c[f++] : u[d++] : f < l ? c[f++] : u[d++];
        return e;
    }, uD = cD, lD = ht.match(/firefox\/(\d+)/i), sD = !!lD && +lD[1], fD = /MSIE|Trident/.test(ht), dD = ht.match(/AppleWebKit\/(\d+)\./), mD = !!dD && +dD[1], pD = Br, vD = Ce, hD = Bt, gD = an, yD = Io, bD = function(e, t) {
        if (!delete e[t]) throw new oD("Cannot delete property " + rD(t) + " of " + rD(e));
    }, ED = Pi, wD = pe, ND = uD, SD = uC, TD = sD, CD = fD, OD = St, RD = mD, xD = [], kD = vD(xD.sort), AD = vD(xD.push), ID = wD(function() {
        xD.sort(void 0);
    }), MD = wD(function() {
        xD.sort(null);
    }), _D = SD("sort"), LD = !wD(function() {
        if (OD) return OD < 70;
        if (!(TD && TD > 3)) {
            if (CD) return !0;
            if (RD) return RD < 603;
            var e, t, n, r, o = "";
            for(e = 65; e < 76; e++){
                switch(t = String.fromCharCode(e), e){
                    case 66:
                    case 69:
                    case 70:
                    case 72:
                        n = 3;
                        break;
                    case 68:
                    case 71:
                        n = 4;
                        break;
                    default:
                        n = 2;
                }
                for(r = 0; r < 47; r++)xD.push({
                    k: t + r,
                    v: n
                });
            }
            for(xD.sort(function(e, t) {
                return t.v - e.v;
            }), r = 0; r < xD.length; r++)t = xD[r].k.charAt(0), o.charAt(o.length - 1) !== t && (o += t);
            return "DGBEFHACIJK" !== o;
        }
    });
    pD({
        target: "Array",
        proto: !0,
        forced: ID || !MD || !_D || !LD
    }, {
        sort: function(e) {
            void 0 !== e && hD(e);
            var t = gD(this);
            if (LD) return void 0 === e ? kD(t) : kD(t, e);
            var n, r, o = [], a = yD(t);
            for(r = 0; r < a; r++)r in t && AD(o, t[r]);
            for(ND(o, function(e) {
                return function(t, n) {
                    return void 0 === n ? -1 : void 0 === t ? 1 : void 0 !== e ? +e(t, n) || 0 : ED(t) > ED(n) ? 1 : -1;
                };
            }(e)), n = yD(o), r = 0; r < n;)t[r] = o[r++];
            for(; r < a;)bD(t, r++);
            return t;
        }
    });
    var jD = aS("Array", "sort"), PD = mt, DD = jD, FD = Array.prototype, BD = se(function(e) {
        var t = e.sort;
        return e === FD || PD(FD, e) && t === FD.sort ? DD : t;
    }), HD = [
        "className",
        "vertical",
        "actions"
    ], UD = function(e) {
        return "primary" === e.color;
    }, zD = function(e) {
        var t = e.className, n = e.title, r = e.logo, a = e.desc, i = e.leftContent, u = e.rightContent, l = void 0 === u ? [] : u, s = e.rightSlot, f = "left" === e.align, d = !!f || !r;
        return o.default.createElement("header", {
            className: c("Navbar", {
                "Navbar--left": f
            }, t)
        }, o.default.createElement("div", {
            className: "Navbar-left"
        }, i && o.default.createElement(x_, aC({
            size: "lg"
        }, i))), o.default.createElement("div", {
            className: "Navbar-main"
        }, r && o.default.createElement("div", {
            className: "Navbar-brand"
        }, o.default.createElement("img", {
            className: "Navbar-logo",
            src: r,
            alt: n
        })), o.default.createElement("div", {
            className: "Navbar-inner"
        }, d && o.default.createElement("h2", {
            className: "Navbar-title"
        }, n), o.default.createElement("div", {
            className: "Navbar-desc"
        }, a))), o.default.createElement("div", {
            className: "Navbar-right"
        }, o.default.createElement("div", {
            className: "Navbar-rightSlot"
        }, s), HS(l).call(l, function(e) {
            return o.default.createElement(x_, aC({
                size: "lg",
                key: e.icon
            }, e));
        })));
    };
    var GD = qp, WD = Hm, VD = kj, YD = Wp, qD = Um, XD = Wm, $D = tk, KD = Bj, QD = Og, JD = eT, ZD = fv, eF = eP, tF = Lm, nF = wL.UNSUPPORTED_Y, rF = Math.min, oF = WD([].push), aF = WD("".slice), iF = !tF(function() {
        var e = /(?:)/, t = e.exec;
        e.exec = function() {
            return t.apply(this, arguments);
        };
        var n = "ab".split(e);
        return 2 !== n.length || "a" !== n[0] || "b" !== n[1];
    }), cF = "c" === "abbc".split(/(b)*/)[1] || 4 !== "test".split(/(?:)/, -1).length || 2 !== "ab".split(/(?:ab)*/).length || 4 !== ".".split(/(.?)(.?)/).length || ".".split(/()()/).length > 1 || "".split(/.?/).length;
    VD("split", function(e, t, n) {
        var r = "0".split(void 0, 0).length ? function(e, n) {
            return void 0 === e && 0 === n ? [] : GD(t, this, e, n);
        } : t;
        return [
            function(t, n) {
                var o = XD(this), a = qD(t) ? void 0 : ZD(t, e);
                return a ? GD(a, t, o, n) : GD(r, JD(o), t, n);
            },
            function(e, o) {
                var a = YD(this), i = JD(e);
                if (!cF) {
                    var c = n(r, a, i, o, r !== t);
                    if (c.done) return c.value;
                }
                var u = $D(a, RegExp), l = a.unicode, s = (a.ignoreCase ? "i" : "") + (a.multiline ? "m" : "") + (a.unicode ? "u" : "") + (nF ? "g" : "y"), f = new u(nF ? "^(?:" + a.source + ")" : a, s), d = void 0 === o ? 4294967295 : o >>> 0;
                if (0 === d) return [];
                if (0 === i.length) return null === eF(f, i) ? [
                    i
                ] : [];
                for(var m = 0, p = 0, v = []; p < i.length;){
                    f.lastIndex = nF ? 0 : p;
                    var h, g = eF(f, nF ? aF(i, p) : i);
                    if (null === g || (h = rF(QD(f.lastIndex + (nF ? p : 0)), i.length)) === m) p = KD(i, p, l);
                    else {
                        if (oF(v, aF(i, m, p)), v.length === d) return v;
                        for(var y = 1; y <= g.length - 1; y++)if (oF(v, g[y]), v.length === d) return v;
                        p = m = h;
                    }
                }
                return oF(v, aF(i, m)), v;
            }
        ];
    }, cF || !iF, nF);
    var uF = Br, lF = Jy.find, sF = "find", fF = !0;
    sF in [] && Array(1)[sF](function() {
        fF = !1;
    }), uF({
        target: "Array",
        proto: !0,
        forced: fF
    }, {
        find: function(e) {
            return lF(this, e, arguments.length > 1 ? arguments[1] : void 0);
        }
    });
    var dF = aS("Array", "find"), mF = mt, pF = dF, vF = Array.prototype, hF = se(function(e) {
        var t = e.find;
        return e === vF || mF(vF, e) && t === vF.find ? pF : t;
    }), gF = [
        "className",
        "price",
        "currency",
        "locale",
        "original",
        "autoFit"
    ], yF = "Intl" in window && "function" == typeof Intl.NumberFormat.prototype.formatToParts;
    function bF(e) {
        var t = function(t) {
            var n;
            return (null === (n = hF(e).call(e, function(e) {
                return e.type === t;
            })) || void 0 === n || null === (n = n.value) || void 0 === n ? void 0 : n.length) || 0;
        }, n = t("integer"), r = t("fraction");
        return n < 2 ? "xl" : 2 === n ? r ? "lg" : "xl" : 3 === n ? r ? r > 1 ? "md" : "lg" : "xl" : 4 === n ? r ? r > 1 ? "sm" : "md" : "lg" : r ? "sm" : "md";
    }
    var EF = o.default.forwardRef(function(e, t) {
        var n = e.className, r = e.price, a = e.currency, i = e.locale, u = e.original, l = e.autoFit, s = EC(e, gF), f = [];
        if (!(f = i && a && yF ? new Intl.NumberFormat(i, {
            style: "currency",
            currency: a,
            useGrouping: !1,
            minimumFractionDigits: 0
        }).formatToParts(r) : void 0) || f.length < 2) {
            var d = xS("".concat(r).split("."), 2), m = d[0], p = d[1];
            f = [
                {
                    type: "currency",
                    value: a
                },
                {
                    type: "integer",
                    value: m
                },
                {
                    type: "decimal",
                    value: p && "."
                },
                {
                    type: "fraction",
                    value: p
                }
            ];
        }
        return o.default.createElement("div", aC({
            className: c("Price", {
                "Price--original": u
            }, n),
            "data-size": l ? bF(f) : void 0,
            ref: t,
            "aria-label": "价格：".concat(r)
        }, s), HS(f).call(f, function(e, t) {
            return e.value ? o.default.createElement("span", {
                className: "Price-".concat(e.type),
                key: t
            }, e.value) : null;
        }));
    }), wF = [
        "className",
        "value",
        "status",
        "children"
    ], NF = o.default.forwardRef(function(e, t) {
        var n = e.className, r = e.value, a = e.status, i = e.children, u = EC(e, wF);
        return o.default.createElement("div", aC({
            className: c("Progress", a && "Progress--".concat(a), n),
            ref: t
        }, u), o.default.createElement("div", {
            className: "Progress-bar",
            role: "progressbar",
            style: {
                width: "".concat(r, "%")
            },
            "aria-valuenow": r,
            "aria-valuemin": 0,
            "aria-valuemax": 100
        }, i));
    }), SF = requestAnimationFrame, TF = function(e) {
        return window.setTimeout(e, 16);
    };
    function CF(e) {
        var t = e.el, n = e.to, r = e.duration, o = void 0 === r ? 300 : r, a = e.x ? "scrollLeft" : "scrollTop";
        if (SF) {
            var i = t[a], c = Math.round(o / 16), u = (n - i) / c, l = 0;
            !function e() {
                t[a] += u, ++l < c && SF(e);
            }();
        } else t[a] = n;
    }
    !function(e, t) {
        var n = 0, r = Date.now(), o = 0;
        if (requestAnimationFrame) {
            var a = function() {
                var i = Date.now() - r;
                n += 1, i >= 1e3 && (r += i, e(n), t && (o += 1), n = 0), (!t || o <= t) && requestAnimationFrame(a);
            };
            a();
        } else e(0);
    }(function(e) {
        SF = e < 55 ? TF : requestAnimationFrame;
    }, 3);
    var OF = Xr("passiveListener"), RF = !!OF && {
        passive: !0
    }, xF = !!OF && {
        passive: !1
    }, kF = o.default.forwardRef(function(e, n) {
        var r = e.distance, a = void 0 === r ? 20 : r, i = e.loadingDistance, u = void 0 === i ? 30 : i, l = e.maxDistance, s = void 0 === l ? 60 : l, f = e.distanceRatio, d = void 0 === f ? 2 : f, m = e.loadMoreText, p = void 0 === m ? "点击加载更多" : m, v = e.children, h = e.onScroll, g = e.onRefresh, y = e.renderIndicator, b = void 0 === y ? function(e) {
            return "active" === e || "loading" === e ? o.default.createElement(fO, {
                className: "PullToRefresh-spinner",
                type: "spinner",
                spin: !0
            }) : null;
        } : y, E = t.useRef(null), w = t.useRef(null), N = ym(g), S = xS(t.useState(0), 2), T = S[0], C = S[1], O = xS(t.useState("pending"), 2), R = O[0], x = O[1], k = xS(t.useState(!1), 2), A = k[0], I = k[1], M = xS(t.useState(!e.onRefresh), 2), _ = M[0], L = M[1], j = t.useRef({}), P = t.useRef(R), D = t.useRef(), F = t.useRef(), B = !Xr("touch");
        t.useEffect({
            "kF.useEffect": function() {
                P.current = R;
            }
        }["kF.useEffect"], [
            R
        ]);
        var H = function(e) {
            var t = w.current;
            t && u_(t, "translate3d(0px,".concat(e, "px,0)"));
        }, U = function(e) {
            var t = e.y, n = e.animated, r = void 0 === n || n, o = E.current;
            if (o) {
                var a = "100%" === t ? o.scrollHeight - o.offsetHeight : t;
                r ? CF({
                    el: o,
                    to: a,
                    x: !1
                }) : o.scrollTop = a;
            }
        }, z = t.useCallback({
            "kF.useCallback[z]": function() {
                var e = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).animated;
                U({
                    y: "100%",
                    animated: void 0 === e || e
                });
            }
        }["kF.useCallback[z]"], []), G = t.useCallback({
            "kF.useCallback[G]": function() {
                C(0), x("pending"), H(0);
            }
        }["kF.useCallback[G]"], []), W = t.useCallback({
            "kF.useCallback[W]": function() {
                var e = E.current;
                if (e && N.current) {
                    x("loading");
                    try {
                        var t = e.scrollHeight;
                        N.current().then({
                            "kF.useCallback[W]": function(n) {
                                var r = {
                                    "kF.useCallback[W].r": function() {
                                        U({
                                            y: e.scrollHeight - t - 50,
                                            animated: !1
                                        });
                                    }
                                }["kF.useCallback[W].r"];
                                clearTimeout(D.current), clearTimeout(F.current), r(), D.current = setTimeout(r, 150), F.current = setTimeout(r, 250), G(), n && n.noMore && L(!0);
                            }
                        }["kF.useCallback[W]"]);
                    } catch (e) {
                        G();
                    }
                }
            }
        }["kF.useCallback[W]"], [
            N,
            G
        ]), V = function() {
            j.current.startY = 0;
        }, Y = t.useCallback({
            "kF.useCallback[Y]": function(e) {
                var t = e.touches[0].clientY, n = E.current.scrollTop <= 0;
                n ? j.current.startY || (j.current.startY = t, x("pull"), I(!1)) : j.current.startY = 0;
                var r = j.current.startY;
                if (n && !(t < r) && "loading" !== P.current) {
                    var o = (t - r) / d;
                    s && o > s && (o = s), o > 0 && (e.cancelable && e.preventDefault(), e.stopPropagation(), H(o), C(o), x(o >= a ? "active" : "pull"));
                }
            }
        }["kF.useCallback[Y]"], [
            d,
            s,
            a
        ]), q = t.useCallback({
            "kF.useCallback[q]": function() {
                I(!0), j.current.startY && "active" === P.current ? W() : G();
            }
        }["kF.useCallback[q]"], [
            W,
            G
        ]);
        return t.useEffect({
            "kF.useEffect": function() {
                var e = E.current;
                e && !B && (_ ? (e.removeEventListener("touchstart", V), e.removeEventListener("touchmove", Y), e.removeEventListener("touchend", q), e.removeEventListener("touchcancel", q)) : (e.addEventListener("touchstart", V, RF), e.addEventListener("touchmove", Y, xF), e.addEventListener("touchend", q), e.addEventListener("touchcancel", q)));
            }
        }["kF.useEffect"], [
            _,
            q,
            Y,
            B
        ]), t.useEffect({
            "kF.useEffect": function() {
                "loading" !== R || B || H(u);
            }
        }["kF.useEffect"], [
            u,
            R,
            B
        ]), t.useImperativeHandle(n, {
            "kF.useImperativeHandle": function() {
                return {
                    scrollTo: U,
                    scrollToEnd: z,
                    wrapperRef: E
                };
            }
        }["kF.useImperativeHandle"], [
            z
        ]), o.default.createElement("div", {
            className: "PullToRefresh",
            ref: E,
            onScroll: h
        }, o.default.createElement("div", {
            className: "PullToRefresh-inner"
        }, o.default.createElement("div", {
            className: c("PullToRefresh-content", {
                "PullToRefresh-transition": A
            }),
            ref: w
        }, o.default.createElement("div", {
            className: "PullToRefresh-indicator"
        }, b(R, T)), !_ && B && o.default.createElement(NO, {
            className: "PullToRefresh-fallback",
            center: !0
        }, b(R, a), o.default.createElement(pO, {
            className: "PullToRefresh-loadMore",
            variant: "text",
            onClick: W
        }, p)), o.default.Children.only(v))));
    }), AF = {
        threshold: [
            0,
            .1
        ]
    }, IF = function(e) {
        var n = e.item, r = e.effect, a = e.children, i = e.onIntersect, u = t.useRef(null);
        return t.useEffect({
            "IF.useEffect": function() {
                if (i) {
                    var e = new IntersectionObserver({
                        "IF.useEffect": function(t) {
                            var r = xS(t, 1)[0];
                            r.intersectionRatio > 0 && (i(n, r) || e.unobserve(r.target));
                        }
                    }["IF.useEffect"], AF);
                    return u.current && e.observe(u.current), ({
                        "IF.useEffect": function() {
                            e.disconnect();
                        }
                    })["IF.useEffect"];
                }
            }
        }["IF.useEffect"], [
            n,
            i
        ]), o.default.createElement("div", {
            className: c("ScrollView-item", {
                "slide-in-right-item": "slide" === r,
                "A-fadeIn": "fade" === r
            }),
            ref: u
        }, a);
    }, MF = [
        "className",
        "fullWidth",
        "scrollX",
        "effect",
        "data",
        "itemKey",
        "renderItem",
        "onIntersect",
        "onScroll",
        "children"
    ], _F = !Xr("touch"), LF = o.default.forwardRef(function(e, n) {
        var r = e.className, a = e.fullWidth, i = e.scrollX, u = void 0 === i || i, l = e.effect, s = void 0 === l ? "slide" : l, f = e.data, d = e.itemKey, m = e.renderItem, p = e.onIntersect, v = e.onScroll, h = e.children, g = EC(e, MF), y = t.useRef(null);
        var b = t.useCallback({
            "LF.useCallback[b]": function(e, t) {
                var n;
                return d && (n = "function" == typeof d ? d(e, t) : e[d]), n || t;
            }
        }["LF.useCallback[b]"], [
            d
        ]);
        return t.useImperativeHandle(n, {
            "LF.useImperativeHandle": function() {
                return {
                    scrollTo: ({
                        "LF.useImperativeHandle": function(e) {
                            var t = e.x, n = e.y;
                            null != t && (y.current.scrollLeft = t), null != n && (y.current.scrollTop = n);
                        }
                    })["LF.useImperativeHandle"]
                };
            }
        }["LF.useImperativeHandle"]), o.default.createElement("div", aC({
            className: c("ScrollView", {
                "ScrollView--fullWidth": a,
                "ScrollView--x": u,
                "ScrollView--hasControls": _F
            }, r),
            ref: n
        }, g), _F && o.default.createElement(x_, {
            className: "ScrollView-control",
            icon: "chevron-left",
            "aria-label": "Previous",
            onClick: function() {
                var e = y.current;
                e.scrollLeft -= e.offsetWidth;
            }
        }), o.default.createElement("div", {
            className: "ScrollView-scroller",
            ref: y,
            onScroll: v
        }, o.default.createElement("div", {
            className: "ScrollView-inner"
        }, HS(f).call(f, function(e, t) {
            return o.default.createElement(IF, {
                item: e,
                effect: e.effect || s,
                onIntersect: p,
                key: b(e, t)
            }, m(e, t));
        }), h ? o.default.createElement(IF, {
            item: {},
            effect: s,
            onIntersect: p
        }, h) : null)), _F && o.default.createElement(x_, {
            className: "ScrollView-control",
            icon: "chevron-right",
            "aria-label": "Next",
            onClick: function() {
                var e = y.current;
                e.scrollLeft += e.offsetWidth;
            }
        }));
    }), jF = function(e) {
        var t = e.item, n = e.index, r = e.onClick;
        return o.default.createElement("button", {
            className: c("QuickReply", {
                new: t.isNew,
                highlight: t.isHighlight
            }),
            type: "button",
            "data-code": t.code,
            "aria-label": "快捷短语: ".concat(t.name, "，双击发送"),
            onClick: function() {
                r(t, n);
            }
        }, o.default.createElement("div", {
            className: "QuickReply-inner"
        }, t.icon && o.default.createElement(fO, {
            type: t.icon
        }), t.img && o.default.createElement("img", {
            className: "QuickReply-img",
            src: t.img,
            alt: ""
        }), o.default.createElement("span", null, t.name)));
    }, PF = function(e) {
        var n = e.items, r = void 0 === n ? [] : n, a = e.visible, i = void 0 === a || a, c = e.onClick, u = e.onScroll, l = t.useRef(null), s = xS(t.useState(!!u), 2), f = s[0], d = s[1];
        return t.useLayoutEffect({
            "PF.useLayoutEffect": function() {
                var e;
                return l.current && (d(!1), l.current.scrollTo({
                    x: 0
                }), e = setTimeout({
                    "PF.useLayoutEffect": function() {
                        d(!0);
                    }
                }["PF.useLayoutEffect"], 500)), ({
                    "PF.useLayoutEffect": function() {
                        clearTimeout(e);
                    }
                })["PF.useLayoutEffect"];
            }
        }["PF.useLayoutEffect"], [
            r
        ]), r.length ? o.default.createElement(LF, {
            className: "QuickReplies",
            data: r,
            itemKey: "name",
            ref: l,
            "data-visible": i,
            onScroll: f ? u : void 0,
            renderItem: function(e, t) {
                return o.default.createElement(jF, {
                    item: e,
                    index: t,
                    onClick: c,
                    key: e.name
                });
            }
        }) : null;
    }, DF = o.default.memo(PF), FF = [
        "className",
        "label",
        "checked",
        "disabled",
        "onChange"
    ], BF = function(e) {
        var t = e.className, n = e.label, r = e.checked, a = e.disabled, i = e.onChange, u = EC(e, FF);
        return o.default.createElement("label", {
            className: c("Radio", t, {
                "Radio--checked": r,
                "Radio--disabled": a
            })
        }, o.default.createElement("input", aC({
            type: "radio",
            className: "Radio-input",
            checked: r,
            disabled: a,
            onChange: i
        }, u)), o.default.createElement("span", {
            className: "Radio-text"
        }, n));
    }, HF = "up", UF = "down";
    ue.isSupported && (ue.addHook("beforeSanitizeAttributes", function(e) {
        if (e instanceof HTMLElement && e.hasAttribute("href")) {
            var t = e.getAttribute("href");
            t && (e.dataset.cuiHref = t), "_blank" === e.getAttribute("target") && (e.dataset.cuiTarget = "1");
        }
    }), ue.addHook("afterSanitizeAttributes", function(e) {
        e instanceof HTMLElement && (e.dataset.cuiHref && e.hasAttribute("href") && e.removeAttribute("data-cui-href"), e.dataset.cuiTarget && (e.setAttribute("target", "_blank"), e.setAttribute("rel", "noopener noreferrer"), e.removeAttribute("data-cui-target")));
    }));
    var zF = [
        "className",
        "content",
        "options"
    ], GF = o.default.forwardRef(function(e, t) {
        var n = e.className, r = e.content, a = e.options, i = void 0 === a ? {} : a, u = EC(e, zF), l = {
            __html: ue.sanitize(r, i)
        };
        return o.default.createElement("div", aC({
            className: c("RichText", n),
            dangerouslySetInnerHTML: l,
            role: "article",
            ref: t
        }, u));
    });
    var WF = [
        "className",
        "onSearch",
        "onChange",
        "onClear",
        "value",
        "disabled",
        "clearable",
        "showSearch"
    ], VF = [
        "className",
        "placeholder",
        "variant",
        "children"
    ], YF = o.default.forwardRef(function(e, t) {
        var n = e.className, r = e.placeholder, a = e.variant, i = void 0 === a ? "outline" : a, u = e.children, l = EC(e, VF);
        return o.default.createElement("select", aC({
            className: c("Input Select", "Input--".concat(i), n)
        }, l, {
            ref: t
        }), r && o.default.createElement("option", {
            value: ""
        }, r), u);
    });
    function qF(e, t) {
        var n = gy(e);
        if (rw) {
            var r = rw(e);
            t && (r = QS(r).call(r, function(t) {
                return dw(e, t).enumerable;
            })), n.push.apply(n, r);
        }
        return n;
    }
    function XF(e) {
        for(var t = 1; t < arguments.length; t++){
            var n = null != arguments[t] ? arguments[t] : {};
            t % 2 ? qF(Object(n), !0).forEach(function(t) {
                LS(e, t, n[t]);
            }) : ww ? xw(e, ww(n)) : qF(Object(n)).forEach(function(t) {
                Yr(e, t, dw(n, t));
            });
        }
        return e;
    }
    var $F = [
        "className",
        "current",
        "status",
        "inverted",
        "children"
    ];
    function KF(e, t) {
        var n = gy(e);
        if (rw) {
            var r = rw(e);
            t && (r = QS(r).call(r, function(t) {
                return dw(e, t).enumerable;
            })), n.push.apply(n, r);
        }
        return n;
    }
    function QF(e) {
        for(var t = 1; t < arguments.length; t++){
            var n = null != arguments[t] ? arguments[t] : {};
            t % 2 ? KF(Object(n), !0).forEach(function(t) {
                LS(e, t, n[t]);
            }) : ww ? xw(e, ww(n)) : KF(Object(n)).forEach(function(t) {
                Yr(e, t, dw(n, t));
            });
        }
        return e;
    }
    var JF = o.default.forwardRef(function(e, t) {
        var n = e.className, r = e.current, a = void 0 === r ? 0 : r, i = e.status, u = e.inverted, l = e.children, s = EC(e, $F), f = o.default.Children.toArray(l), d = HS(f).call(f, function(e, t) {
            var n = {
                index: t,
                active: !1,
                completed: !1,
                disabled: !1
            };
            return a === t ? (n.active = !0, n.status = i) : a > t ? n.completed = !0 : (n.disabled = !u, n.completed = u), o.default.isValidElement(e) ? o.default.cloneElement(e, QF(QF({}, n), e.props)) : null;
        });
        return o.default.createElement("ul", aC({
            className: c("Stepper", n),
            ref: t
        }, s), d);
    }), ZF = [
        "className",
        "active",
        "completed",
        "disabled",
        "status",
        "index",
        "title",
        "subTitle",
        "desc",
        "children"
    ];
    var eB = o.default.forwardRef(function(e, t) {
        var n = e.className, r = e.active, a = void 0 !== r && r, i = e.completed, u = void 0 !== i && i, l = e.disabled, s = void 0 !== l && l, f = e.status;
        e.index;
        var d = e.title, m = e.subTitle, p = e.desc, v = e.children, h = EC(e, ZF);
        return o.default.createElement("li", aC({
            className: c("Step", {
                "Step--active": a,
                "Step--completed": u,
                "Step--disabled": s
            }, n),
            ref: t,
            "data-status": f
        }, h), o.default.createElement("div", {
            className: "Step-icon"
        }, function(e) {
            if (e) return o.default.createElement(fO, {
                type: {
                    success: "check-circle-fill",
                    fail: "warning-circle-fill",
                    abort: "dash-circle-fill"
                }[e]
            });
            return o.default.createElement("div", {
                className: "Step-dot"
            });
        }(f)), o.default.createElement("div", {
            className: "Step-line"
        }), o.default.createElement("div", {
            className: "Step-content"
        }, d && o.default.createElement("div", {
            className: "Step-title"
        }, d && o.default.createElement("span", null, d), m && o.default.createElement("small", null, m)), p && o.default.createElement("div", {
            className: "Step-desc"
        }, p), v));
    }), tB = [
        "active",
        "index",
        "children",
        "onClick"
    ], nB = [
        "active",
        "children"
    ], rB = function(e) {
        var t = e.active, n = e.index, r = e.children, a = e.onClick, i = EC(e, tB);
        return o.default.createElement("div", {
            className: "Tabs-navItem"
        }, o.default.createElement("button", aC({
            className: c("Tabs-navLink", {
                active: t
            }),
            type: "button",
            role: "tab",
            "aria-selected": t,
            onClick: function(e) {
                a(n, e);
            }
        }, i), o.default.createElement("span", null, r)));
    }, oB = function(e) {
        var t = e.active, n = e.children, r = EC(e, nB);
        return o.default.createElement("div", aC({
            className: c("Tabs-pane", {
                active: t
            })
        }, r, {
            role: "tabpanel"
        }), n);
    }, aB = [
        "as",
        "className",
        "color",
        "children"
    ], iB = o.default.forwardRef(function(e, t) {
        var n = e.as, r = void 0 === n ? "span" : n, a = e.className, i = e.color, u = e.children, l = EC(e, aB);
        return o.default.createElement(r, aC({
            className: c("Tag", i && "Tag--".concat(i), a),
            ref: t
        }, l), u);
    });
    var cB = function(e) {
        var n = e.content, r = e.type, a = e.duration, i = void 0 === a ? 2e3 : a, u = e.onUnmount, l = xS(t.useState(!1), 2), s = l[0], f = l[1];
        return t.useEffect({
            "cB.useEffect": function() {
                f(!0), -1 !== i && (setTimeout({
                    "cB.useEffect": function() {
                        f(!1);
                    }
                }["cB.useEffect"], i), setTimeout({
                    "cB.useEffect": function() {
                        u && u();
                    }
                }["cB.useEffect"], i + 300));
            }
        }["cB.useEffect"], [
            i,
            u
        ]), o.default.createElement("div", {
            className: c("Toast", {
                show: s
            }),
            "data-type": r,
            role: "alert",
            "aria-live": "assertive",
            "aria-atomic": "true"
        }, o.default.createElement("div", {
            className: "Toast-content",
            role: "presentation"
        }, function(e) {
            switch(e){
                case "success":
                    return o.default.createElement(fO, {
                        type: "check-circle"
                    });
                case "error":
                    return o.default.createElement(fO, {
                        type: "warning-circle"
                    });
                case "loading":
                    return o.default.createElement(fO, {
                        type: "spinner",
                        spin: !0
                    });
                default:
                    return null;
            }
        }(r), o.default.createElement("p", {
            className: "Toast-message"
        }, n)));
    };
    function uB(e, t, n) {
        vm(o.default.createElement(cB, {
            content: e,
            type: t,
            duration: n
        }));
    }
    var lB = {
        show: uB,
        success: function(e, t) {
            uB(e, "success", t);
        },
        fail: function(e, t) {
            uB(e, "error", t);
        },
        loading: function(e, t) {
            uB(e, "loading", t);
        }
    }, sB = function(e) {
        var t = e.item, n = e.onClick, r = t.type, a = t.icon, i = t.img, c = t.title;
        return o.default.createElement("div", {
            className: "Toolbar-item",
            "data-type": r
        }, o.default.createElement(pO, {
            className: "Toolbar-btn",
            onClick: function(e) {
                return n(t, e);
            }
        }, o.default.createElement("span", {
            className: "Toolbar-btnIcon"
        }, a && o.default.createElement(fO, {
            type: a
        }), i && o.default.createElement("img", {
            className: "Toolbar-img",
            src: i,
            alt: ""
        })), o.default.createElement("span", {
            className: "Toolbar-btnText"
        }, c)));
    }, fB = function(e) {
        var t = e.items, n = e.onClick;
        return o.default.createElement("div", {
            className: "Toolbar"
        }, HS(t).call(t, function(e) {
            return o.default.createElement(sB, {
                item: e,
                onClick: n,
                key: e.type
            });
        }));
    };
    function dB(e, t) {
        var n = gy(e);
        if (rw) {
            var r = rw(e);
            t && (r = QS(r).call(r, function(t) {
                return dw(e, t).enumerable;
            })), n.push.apply(n, r);
        }
        return n;
    }
    function mB(e) {
        for(var t = 1; t < arguments.length; t++){
            var n = null != arguments[t] ? arguments[t] : {};
            t % 2 ? dB(Object(n), !0).forEach(function(t) {
                LS(e, t, n[t]);
            }) : ww ? xw(e, ww(n)) : dB(Object(n)).forEach(function(t) {
                Yr(e, t, dw(n, t));
            });
        }
        return e;
    }
    var pB = [
        "content",
        "className",
        "isRichText",
        "options",
        "messageRender",
        "onResize",
        "children"
    ];
    var vB = [
        "className",
        "src",
        "cover",
        "duration",
        "onClick",
        "onCoverLoad",
        "style",
        "videoRef",
        "children"
    ], hB = {
        position: "absolute",
        height: "1px",
        width: "1px",
        overflow: "hidden",
        clip: "rect(0 0 0 0)",
        margin: "-1px",
        whiteSpace: "nowrap"
    }, gB = Ee, yB = ot, bB = So, EB = Io, wB = uC, NB = Math.min, SB = [].lastIndexOf, TB = !!SB && 1 / [
        1
    ].lastIndexOf(1, -0) < 0, CB = wB("lastIndexOf"), OB = TB || !CB ? function(e) {
        if (TB) return gB(SB, this, arguments) || 0;
        var t = yB(this), n = EB(t);
        if (0 === n) return -1;
        var r = n - 1;
        for(arguments.length > 1 && (r = NB(r, bB(arguments[1]))), r < 0 && (r = n + r); r >= 0; r--)if (r in t && t[r] === e) return r || 0;
        return -1;
    } : SB;
    Br({
        target: "Array",
        proto: !0,
        forced: OB !== [].lastIndexOf
    }, {
        lastIndexOf: OB
    });
    var RB = aS("Array", "lastIndexOf"), xB = mt, kB = RB, AB = Array.prototype, IB = se(function(e) {
        var t = e.lastIndexOf;
        return e === AB || xB(AB, e) && t === AB.lastIndexOf ? kB : t;
    }), MB = me, _B = pe, LB = Pi, jB = qM.trim, PB = BM, DB = Ce("".charAt), FB = MB.parseFloat, BB = MB.Symbol, HB = BB && BB.iterator, UB = 1 / FB(PB + "-0") != -1 / 0 || HB && !_B(function() {
        FB(Object(HB));
    }) ? function(e) {
        var t = jB(LB(e)), n = FB(t);
        return 0 === n && "-" === DB(t, 0) ? -0 : n;
    } : FB;
    Br({
        global: !0,
        forced: parseFloat !== UB
    }, {
        parseFloat: UB
    });
    var zB = se(ct.parseFloat), GB = [
        "B",
        "KB",
        "MB",
        "GB",
        "TB",
        "PB",
        "EB",
        "ZB",
        "YB"
    ], WB = [
        "className",
        "type",
        "img",
        "name",
        "desc",
        "tags",
        "locale",
        "currency",
        "price",
        "count",
        "unit",
        "action",
        "elderMode",
        "variant",
        "children",
        "originalPrice",
        "meta",
        "status",
        "asideContent"
    ], VB = o.default.forwardRef(function(e, t) {
        var n = BP(), r = e.className, a = e.type, i = e.img, u = e.name, l = e.desc, s = e.tags, f = void 0 === s ? [] : s, d = e.locale, m = e.currency, p = e.price, v = e.count, h = e.unit, g = e.action, y = e.elderMode, b = e.variant, E = e.children, w = e.originalPrice, N = e.meta, S = e.status, T = e.asideContent, C = EC(e, WB), O = y || n.elderMode, R = "order" === a && !O, x = "order" !== a && !O, k = "inList" === b, A = {
            currency: m,
            locale: d
        }, I = null != p && o.default.createElement(EF, aC({
            price: p
        }, A)), M = o.default.createElement("div", {
            className: "Goods-countUnit"
        }, v && o.default.createElement("span", {
            className: "Goods-count"
        }, "×", v), h && o.default.createElement("span", {
            className: "Goods-unit"
        }, h)), _ = S ? o.default.createElement("span", {
            className: "Goods-status"
        }, S, C.onClick && !k && o.default.createElement(fO, {
            type: "chevron-right"
        })) : null, L = g ? o.default.createElement(pO, aC({
            size: "sm"
        }, g)) : null;
        return o.default.createElement(NO, aC({
            className: c("Goods", r),
            "data-type": a,
            "data-elder-mode": O,
            "data-variant": b,
            ref: t
        }, C), i && o.default.createElement("img", {
            className: "Goods-img",
            src: i,
            alt: u
        }), o.default.createElement(OO, null, o.default.createElement(NO, null, o.default.createElement(OO, {
            className: "Goods-main"
        }, x && g && o.default.createElement(x_, aC({
            className: "Goods-buyBtn",
            icon: "cart"
        }, g)), o.default.createElement(eR, {
            as: "h4",
            truncate: !(R && !l) || 2,
            className: "Goods-name"
        }, u), l && o.default.createElement(eR, {
            className: "Goods-desc",
            truncate: !(R && !S && k) || 2
        }, l), O ? o.default.createElement(NO, {
            alignItems: "center",
            justifyContent: "space-between"
        }, I, L) : f.length > 0 && o.default.createElement("div", {
            className: "Goods-tags"
        }, HS(f).call(f, function(e) {
            return o.default.createElement(iB, {
                color: "primary",
                key: e.name
            }, e.name);
        })), x && o.default.createElement(NO, {
            alignItems: "flex-end"
        }, o.default.createElement(OO, null, I, w && o.default.createElement(EF, aC({
            price: w,
            original: !0
        }, A)), N && o.default.createElement("span", {
            className: "Goods-meta"
        }, N)), M)), R && o.default.createElement("div", {
            className: "Goods-aside"
        }, I, M, T && o.default.createElement("div", {
            className: "Goods-slot"
        }, T), L)), k && _, E && o.default.createElement("div", {
            className: "Goods-slot"
        }, E), !k && _));
    }), YB = function(e) {
        var n = e.count, r = e.onClick, a = e.onDidMount, i = HP("BackBottom").trans, c = i("bottom");
        return n && (c = i(1 === n ? "newMsgOne" : "newMsgOther").replace("{n}", n)), t.useEffect({
            "YB.useEffect": function() {
                a && a();
            }
        }["YB.useEffect"], [
            a
        ]), o.default.createElement("div", {
            className: "BackBottom"
        }, o.default.createElement(pO, {
            className: "slide-in-right-item",
            onClick: r
        }, c, o.default.createElement(fO, {
            type: "chevron-double-down"
        })));
    };
    var qB = !!Xr("passiveListener") && {
        passive: !0
    };
    function XB(e, t) {
        var n = Math.max(e.offsetHeight, 600);
        return k_(e) < n * t;
    }
    var $B = o.default.forwardRef(function(e, n) {
        var r = e.messages, a = e.isTyping, i = e.loadMoreText, c = e.onRefresh, u = e.onScroll, l = e.renderBeforeMessageList, s = e.renderMessageContent, f = e.onBackBottomShow, d = e.onBackBottomClick, m = xS(t.useState(!1), 2), p = m[0], v = m[1], h = xS(t.useState(0), 2), g = h[0], y = h[1], b = t.useRef(p), E = t.useRef(g), w = t.useRef(null), N = t.useRef(null), S = r[r.length - 1], T = function() {
            y(0), v(!1);
        }, C = t.useCallback({
            "$B.useCallback[C]": function(e) {
                N.current && (!b.current || e && e.force) && (N.current.scrollToEnd(e), b.current && T());
            }
        }["$B.useCallback[C]"], []), O = t.useRef(({
            "$B.useRef[O]": function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 300, n = !0;
                return ({
                    "$B.useRef[O]": function() {
                        n && (n = !1, e.apply(void 0, arguments), setTimeout({
                            "$B.useRef[O]": function() {
                                n = !0;
                            }
                        }["$B.useRef[O]"], t));
                    }
                })["$B.useRef[O]"];
            }
        })["$B.useRef[O]"]({
            "$B.useRef[O]": function(e) {
                XB(e, 3) ? E.current ? XB(e, .5) && T() : v(!1) : v(!0);
            }
        }["$B.useRef[O]"]));
        return t.useEffect({
            "$B.useEffect": function() {
                E.current = g;
            }
        }["$B.useEffect"], [
            g
        ]), t.useEffect({
            "$B.useEffect": function() {
                b.current = p;
            }
        }["$B.useEffect"], [
            p
        ]), t.useEffect({
            "$B.useEffect": function() {
                var e = N.current, t = e && e.wrapperRef.current;
                if (t && S && "pop" !== S.position) if ("right" === S.position) C({
                    force: !0
                });
                else if (XB(t, 2)) {
                    var n = !!t.scrollTop;
                    C({
                        animated: n,
                        force: !0
                    });
                } else y({
                    "$B.useEffect": function(e) {
                        return e + 1;
                    }
                }["$B.useEffect"]), v(!0);
            }
        }["$B.useEffect"], [
            S,
            C
        ]), t.useEffect({
            "$B.useEffect": function() {
                C();
            }
        }["$B.useEffect"], [
            a,
            C
        ]), t.useEffect({
            "$B.useEffect": function() {
                var e = w.current, t = !1, n = 0;
                function r() {
                    t = !1, n = 0;
                }
                function o(e) {
                    var r = document.activeElement;
                    r && "TEXTAREA" === r.nodeName && (t = !0, n = e.touches[0].clientY);
                }
                function a(e) {
                    t && Math.abs(e.touches[0].clientY - n) > 20 && (document.activeElement.blur(), r());
                }
                return e.addEventListener("touchstart", o, qB), e.addEventListener("touchmove", a, qB), e.addEventListener("touchend", r), e.addEventListener("touchcancel", r), ({
                    "$B.useEffect": function() {
                        e.removeEventListener("touchstart", o), e.removeEventListener("touchmove", a), e.removeEventListener("touchend", r), e.removeEventListener("touchcancel", r);
                    }
                })["$B.useEffect"];
            }
        }["$B.useEffect"], []), t.useImperativeHandle(n, {
            "$B.useImperativeHandle": function() {
                return {
                    ref: w,
                    scrollToEnd: C
                };
            }
        }["$B.useImperativeHandle"], [
            C
        ]), o.default.createElement("div", {
            className: "MessageContainer",
            ref: w,
            tabIndex: -1
        }, o.default.createElement("div", {
            className: "MessageContainer-before"
        }, l && l()), o.default.createElement(kF, {
            onRefresh: c,
            onScroll: function(e) {
                O.current(e.target), u && u(e);
            },
            loadMoreText: i,
            ref: N
        }, o.default.createElement("div", {
            className: "MessageList"
        }, HS(r).call(r, function(e) {
            return o.default.createElement(KP, aC({}, e, {
                renderMessageContent: s,
                key: e._id
            }));
        }), a && o.default.createElement(KP, {
            type: "typing",
            _id: "typing"
        }))), p && o.default.createElement(YB, {
            count: g,
            onClick: function() {
                C({
                    animated: !1,
                    force: !0
                }), d && d();
            },
            onDidMount: f
        }));
    }), KB = Xr("passiveListener"), QB = !!KB && {
        passive: !0
    }, JB = !!KB && {
        passive: !1
    }, ZB = {
        inited: "hold2talk",
        recording: "release2send",
        willCancel: "release2send"
    }, eH = 0, tH = 0, nH = o.default.forwardRef(function(e, n) {
        var r = e.volume, a = e.onStart, i = e.onEnd, u = e.onCancel, l = xS(t.useState("inited"), 2), s = l[0], f = l[1], d = t.useRef(null), m = HP("Recorder").trans, p = t.useCallback({
            "nH.useCallback[p]": function() {
                var e = Date.now() - eH;
                i && i({
                    duration: e
                });
            }
        }["nH.useCallback[p]"], [
            i
        ]);
        t.useImperativeHandle(n, {
            "nH.useImperativeHandle": function() {
                return {
                    stop: ({
                        "nH.useImperativeHandle": function() {
                            f("inited"), p(), eH = 0;
                        }
                    })["nH.useImperativeHandle"]
                };
            }
        }["nH.useImperativeHandle"]), t.useEffect({
            "nH.useEffect": function() {
                var e = d.current;
                function t(e) {
                    e.cancelable && e.preventDefault();
                    var t = e.touches[0];
                    tH = t.pageY, eH = Date.now(), f("recording"), a && a();
                }
                function n(e) {
                    if (eH) {
                        var t = e.touches[0].pageY;
                        f(tH - t > 80 ? "willCancel" : "recording");
                    }
                }
                function r(e) {
                    if (eH) {
                        var t = e.changedTouches[0].pageY, n = tH - t < 80;
                        f("inited"), n ? p() : u && u();
                    }
                }
                return e.addEventListener("touchstart", t, JB), e.addEventListener("touchmove", n, QB), e.addEventListener("touchend", r), e.addEventListener("touchcancel", r), ({
                    "nH.useEffect": function() {
                        e.removeEventListener("touchstart", t), e.removeEventListener("touchmove", n), e.removeEventListener("touchend", r), e.removeEventListener("touchcancel", r);
                    }
                })["nH.useEffect"];
            }
        }["nH.useEffect"], [
            p,
            u,
            a
        ]);
        var v = "willCancel" === s, h = {
            transform: "scale(".concat((r || 1) / 100 + 1, ")")
        };
        return o.default.createElement("div", {
            className: c("Recorder", {
                "Recorder--cancel": v
            }),
            ref: d
        }, "inited" !== s && o.default.createElement(NO, {
            className: "RecorderToast",
            direction: "column",
            center: !0
        }, o.default.createElement("div", {
            className: "RecorderToast-waves",
            hidden: "recording" !== s,
            style: h
        }, o.default.createElement(fO, {
            className: "RecorderToast-wave-1",
            type: "hexagon"
        }), o.default.createElement(fO, {
            className: "RecorderToast-wave-2",
            type: "hexagon"
        }), o.default.createElement(fO, {
            className: "RecorderToast-wave-3",
            type: "hexagon"
        })), o.default.createElement(fO, {
            className: "RecorderToast-icon",
            type: v ? "cancel" : "mic"
        }), o.default.createElement("span", null, m(v ? "release2cancel" : "releaseOrSwipe"))), o.default.createElement("div", {
            className: "Recorder-btn",
            role: "button",
            "aria-label": m("hold2talk")
        }, o.default.createElement("span", null, m(ZB[s]))));
    }), rH = function(e) {
        var t = e.onClickOutside, n = e.children;
        return o.default.createElement(y_, {
            onClick: t
        }, n);
    };
    var oH = function(e) {
        var r, a, i = e.className, u = e.active, l = e.target, s = e.children, f = hm(e.onClose, "mousedown"), d = ST({
            active: u,
            ref: f
        }), m = d.didMount, p = d.isShow, v = xS(t.useState({}), 2), h = v[0], g = v[1], y = t.useCallback({
            "oH.useCallback[y]": function() {
                if (f.current) {
                    var e = l.getBoundingClientRect(), t = f.current.getBoundingClientRect();
                    g({
                        top: "".concat(e.top - t.height, "px"),
                        left: "".concat(e.left, "px")
                    });
                }
            }
        }["oH.useCallback[y]"], [
            l,
            f
        ]);
        return t.useEffect({
            "oH.useEffect": function() {
                f.current && (f.current.focus(), y());
            }
        }["oH.useEffect"], [
            m,
            y,
            f
        ]), r = y, a = t.useRef(!1), t.useEffect({
            "oH.useEffect": function() {
                function e() {
                    r(), a.current = !1;
                }
                function t() {
                    a.current || (a.current = !0, window.requestAnimationFrame ? window.requestAnimationFrame(e) : setTimeout(e, 66));
                }
                return window.addEventListener("resize", t), ({
                    "oH.useEffect": function() {
                        window.removeEventListener("resize", t);
                    }
                })["oH.useEffect"];
            }
        }["oH.useEffect"], [
            r
        ]), m ? n.createPortal(o.default.createElement("div", {
            className: c("Popover", i, {
                active: p
            }),
            ref: f,
            style: h
        }, o.default.createElement("div", {
            className: "Popover-body"
        }, s), o.default.createElement("svg", {
            className: "Popover-arrow",
            viewBox: "0 0 9 5"
        }, o.default.createElement("polygon", {
            points: "0,0 5,5, 9,0"
        }))), document.body) : null;
    }, aH = function(e) {
        return o.default.createElement("div", {
            className: "Composer-actions",
            "data-action-icon": e.icon
        }, o.default.createElement(x_, aC({
            size: "lg"
        }, e)));
    }, iH = function(e) {
        var t = e.item, n = e.onClick;
        return o.default.createElement(aH, {
            icon: t.icon,
            img: t.img,
            "data-icon": t.icon,
            "data-tooltip": t.title || null,
            "aria-label": t.title,
            onClick: n
        });
    }, cH = function(e) {
        var n = e.file, r = e.onCancel, a = e.onSend, i = xS(t.useState(""), 2), c = i[0], u = i[1], l = HP("SendConfirm").trans;
        return t.useEffect({
            "cH.useEffect": function() {
                var e = new FileReader;
                e.onload = ({
                    "cH.useEffect": function(e) {
                        e.target && u(e.target.result);
                    }
                })["cH.useEffect"], e.readAsDataURL(n);
            }
        }["cH.useEffect"], [
            n
        ]), o.default.createElement(nD, {
            className: "SendConfirm",
            title: l("title"),
            active: !!c,
            vertical: !1,
            actions: [
                {
                    label: l("cancel"),
                    onClick: r
                },
                {
                    label: l("send"),
                    color: "primary",
                    onClick: a
                }
            ]
        }, o.default.createElement(NO, {
            className: "SendConfirm-inner",
            center: !0
        }, o.default.createElement("img", {
            src: c,
            alt: ""
        })));
    }, uH = qp, lH = Wp, sH = Um, fH = Og, dH = eT, mH = Wm, pH = fv, vH = Bj, hH = eP;
    kj("match", function(e, t, n) {
        return [
            function(t) {
                var n = mH(this), r = sH(t) ? void 0 : pH(t, e);
                return r ? uH(r, t, n) : new RegExp(t)[e](dH(n));
            },
            function(e) {
                var r = lH(this), o = dH(e), a = n(t, r, o);
                if (a.done) return a.value;
                if (!r.global) return hH(r, o);
                var i = r.unicode;
                r.lastIndex = 0;
                for(var c, u = [], l = 0; null !== (c = hH(r, o));){
                    var s = dH(c[0]);
                    u[l] = s, "" === s && (r.lastIndex = vH(o, fH(r.lastIndex), i)), l++;
                }
                return 0 === l ? null : u;
            }
        ];
    });
    var gH = navigator.userAgent, yH = /iPad|iPhone|iPod/.test(gH), bH = /^((?!chrome|android|crios|fxios).)*safari/i.test(gH), EH = $O(gH).call(gH, "Safari/") || /OS 11_[0-3]\D/.test(gH);
    function wH() {
        var e = gH.match(/OS (\d+)_/);
        return e ? +e[1] : 0;
    }
    var NH = $O(gH).call(gH, "ArkWeb");
    function SH(e, t) {
        var n, r = function() {
            if (yH) {
                if (EH) return 0;
                if (wH() < 13) return 1;
            }
            return 2;
        }(), o = t || e, a = function() {
            0 !== r && (1 === r ? document.body.scrollTop = document.body.scrollHeight : o.scrollIntoView(!1));
        };
        e.addEventListener("focus", function() {
            setTimeout(a, 300), n = setTimeout(a, 1e3);
        }), e.addEventListener("blur", function() {
            clearTimeout(n), r && yH && setTimeout(function() {
                document.body.scrollIntoView();
            });
        });
    }
    var TH = se(yC);
    var CH, OH, RH = [
        "inputRef",
        "invisible",
        "onImageSend"
    ], xH = Xr("touch"), kH = function(e) {
        var n = e.inputRef, r = e.invisible, a = e.onImageSend, i = EC(e, RH), u = xS(t.useState(null), 2), l = u[0], s = u[1], f = t.useCallback({
            "kH.useCallback[f]": function(e) {
                !({
                    "kH.useCallback[f]": function(e, t) {
                        var n = e.clipboardData.items;
                        if (n && n.length) for(var r = 0; r < n.length; r++){
                            var o, a = n[r];
                            if (-1 !== TH(o = a.type).call(o, "image")) {
                                var i = a.getAsFile();
                                i && t(i), e.preventDefault();
                                break;
                            }
                        }
                    }
                })["kH.useCallback[f]"](e, s);
            }
        }["kH.useCallback[f]"], []), d = t.useCallback({
            "kH.useCallback[d]": function() {
                s(null);
            }
        }["kH.useCallback[d]"], []), m = t.useCallback({
            "kH.useCallback[m]": function() {
                a && l && dm.resolve(a(l)).then({
                    "kH.useCallback[m]": function() {
                        s(null);
                    }
                }["kH.useCallback[m]"]);
            }
        }["kH.useCallback[m]"], [
            a,
            l
        ]);
        return t.useEffect({
            "kH.useEffect": function() {
                if (xH && n.current) {
                    var e = document.querySelector(".Composer");
                    SH(n.current, e);
                }
            }
        }["kH.useEffect"], [
            n
        ]), o.default.createElement("div", {
            className: c({
                "S--invisible": r
            })
        }, o.default.createElement(RP, aC({
            className: "Composer-input",
            rows: 1,
            autoSize: !0,
            enterKeyHint: "send",
            onPaste: a ? f : void 0,
            ref: n
        }, i)), l && o.default.createElement(cH, {
            file: l,
            onCancel: d,
            onSend: m
        }));
    }, AH = function(e) {
        var n = e.disabled, r = e.onClick, a = HP("Composer").trans, i = t.useRef(null), c = t.useRef(null);
        return t.useEffect({
            "AH.useEffect": function() {
                var e = i.current, t = c.current;
                e && t && e.style.setProperty("--send-width", "".concat(t.offsetWidth, "px"));
            }
        }["AH.useEffect"], []), o.default.createElement("div", {
            className: "Composer-actions",
            "data-action": "send",
            ref: i
        }, o.default.createElement(pO, {
            className: "Composer-sendBtn",
            disabled: n,
            onMouseDown: r,
            color: "primary",
            ref: c
        }, a("send")));
    }, IH = document.documentElement;
    function MH(e) {
        cancelAnimationFrame(OH), IH.style.setProperty("--viewport-top", "".concat(e, "px"));
    }
    function _H() {
        if (CH || (CH = document.querySelector(".ChatApp")), CH) {
            var e = CH.getBoundingClientRect().top;
            0 === e ? OH = requestAnimationFrame(_H) : MH(Math.abs(e));
        }
    }
    function LH(e, t) {
        var n = gy(e);
        if (rw) {
            var r = rw(e);
            t && (r = QS(r).call(r, function(t) {
                return dw(e, t).enumerable;
            })), n.push.apply(n, r);
        }
        return n;
    }
    function jH(e) {
        for(var t = 1; t < arguments.length; t++){
            var n = null != arguments[t] ? arguments[t] : {};
            t % 2 ? LH(Object(n), !0).forEach(function(t) {
                LS(e, t, n[t]);
            }) : ww ? xw(e, ww(n)) : LH(Object(n)).forEach(function(t) {
                Yr(e, t, dw(n, t));
            });
        }
        return e;
    }
    var PH = "S--focusing", DH = o.default.forwardRef(function(e, n) {
        var r = e.text, a = void 0 === r ? "" : r, i = e.textOnce, u = e.inputType, l = void 0 === u ? "text" : u, s = e.wideBreakpoint, f = e.placeholder, d = void 0 === f ? "请输入..." : f, m = e.recorder, p = void 0 === m ? {} : m, v = e.onInputTypeChange, h = e.onFocus, g = e.onBlur, y = e.onChange, b = e.onSend, E = e.onImageSend, w = e.onAccessoryToggle, N = e.toolbar, S = void 0 === N ? [] : N, T = e.onToolbarClick, C = e.rightAction, O = e.inputOptions, R = xS(t.useState(a), 2), x = R[0], k = R[1], A = xS(t.useState(i), 2), I = A[0], M = A[1], _ = xS(t.useState(!!x), 2), L = _[0], j = _[1], P = xS(t.useState(i || d), 2), D = P[0], F = P[1], B = xS(t.useState(l || "text"), 2), H = B[0], U = B[1], z = xS(t.useState(!1), 2), G = z[0], W = z[1], V = xS(t.useState(""), 2), Y = V[0], q = V[1], X = t.useRef(null), $ = t.useRef(!1), K = t.useRef(), Q = t.useRef(), J = t.useRef(), Z = t.useRef(!1), ee = xS(t.useState(!1), 2), te = ee[0], ne = ee[1];
        t.useEffect({
            "DH.useEffect": function() {
                var e = !(!s || !window.matchMedia) && window.matchMedia("(min-width: ".concat(s, ")"));
                function t(e) {
                    ne(e.matches);
                }
                return ne(e && e.matches), e && e.addListener(t), ({
                    "DH.useEffect": function() {
                        e && e.removeListener(t);
                    }
                })["DH.useEffect"];
            }
        }["DH.useEffect"], [
            s
        ]), t.useEffect({
            "DH.useEffect": function() {
                ZP("S--wide", te), te || q("");
            }
        }["DH.useEffect"], [
            te
        ]), t.useEffect({
            "DH.useEffect": function() {
                Z.current && w && w(G);
            }
        }["DH.useEffect"], [
            G,
            w
        ]), t.useEffect({
            "DH.useEffect": function() {
                Z.current = !0;
            }
        }["DH.useEffect"], []), t.useEffect({
            "DH.useEffect": function() {
                var e = window.visualViewport;
                if (e) {
                    var t = window.innerHeight;
                    return e.addEventListener("resize", n), ({
                        "DH.useEffect": function() {
                            e.removeEventListener("resize", n);
                        }
                    })["DH.useEffect"];
                }
                function n() {
                    var n;
                    (yH || NH) && (window.innerHeight > t && (t = window.innerHeight), $.current && e.height >= t && (null === (n = X.current) || void 0 === n || n.blur()));
                }
            }
        }["DH.useEffect"], []), t.useEffect({
            "DH.useEffect": function() {
                x ? (clearTimeout(Q.current), j(!0)) : Q.current = setTimeout({
                    "DH.useEffect": function() {
                        j(!1);
                    }
                }["DH.useEffect"]);
            }
        }["DH.useEffect"], [
            x
        ]), t.useImperativeHandle(n, {
            "DH.useImperativeHandle": function() {
                return {
                    setText: k
                };
            }
        }["DH.useImperativeHandle"]);
        var re = t.useCallback({
            "DH.useCallback[re]": function() {
                var e = "voice" === H, t = e ? "text" : "voice";
                if (U(t), e) {
                    var n = X.current;
                    n.focus(), n.selectionStart = n.selectionEnd = n.value.length;
                }
                v && v(t);
            }
        }["DH.useCallback[re]"], [
            H,
            v
        ]), oe = t.useCallback({
            "DH.useCallback[oe]": function(e) {
                clearTimeout(K.current), ZP(PH, !0), $.current = !0, yH && _H(), h && h(e);
            }
        }["DH.useCallback[oe]"], [
            h
        ]), ae = t.useCallback({
            "DH.useCallback[ae]": function(e) {
                K.current = setTimeout({
                    "DH.useCallback[ae]": function() {
                        ZP(PH, !1), $.current = !1;
                    }
                }["DH.useCallback[ae]"], 0), yH && MH(0), g && g(e);
            }
        }["DH.useCallback[ae]"], [
            g
        ]), ie = t.useCallback({
            "DH.useCallback[ie]": function() {
                x ? (b("text", x), k("")) : I && b("text", I), I && (M(""), F(d)), $.current && X.current.focus();
            }
        }["DH.useCallback[ie]"], [
            d,
            b,
            x,
            I
        ]), ce = t.useCallback({
            "DH.useCallback[ce]": function(e) {
                e.shiftKey || 13 !== e.keyCode || (ie(), e.preventDefault());
            }
        }["DH.useCallback[ce]"], [
            ie
        ]), ue = t.useCallback({
            "DH.useCallback[ue]": function(e, t) {
                k(e), y && y(e, t);
            }
        }["DH.useCallback[ue]"], [
            y
        ]), le = t.useCallback({
            "DH.useCallback[le]": function(e) {
                ie(), e.preventDefault();
            }
        }["DH.useCallback[le]"], [
            ie
        ]), se = t.useCallback({
            "DH.useCallback[se]": function() {
                W(!G);
            }
        }["DH.useCallback[se]"], [
            G
        ]), fe = t.useCallback({
            "DH.useCallback[fe]": function() {
                setTimeout({
                    "DH.useCallback[fe]": function() {
                        W(!1), q("");
                    }
                }["DH.useCallback[fe]"]);
            }
        }["DH.useCallback[fe]"], []), de = t.useCallback({
            "DH.useCallback[de]": function(e, t) {
                T && T(e, t), e.render && (J.current = t.currentTarget, q(e.render));
            }
        }["DH.useCallback[de]"], [
            T
        ]), me = t.useCallback({
            "DH.useCallback[me]": function() {
                q("");
            }
        }["DH.useCallback[me]"], []), pe = "text" === H, ve = pe ? "mic" : "keyboard", he = S.length > 0, ge = jH(jH({}, O), {}, {
            value: x,
            inputRef: X,
            placeholder: D,
            onFocus: oe,
            onBlur: ae,
            onKeyDown: ce,
            onChange: ue,
            onImageSend: E
        });
        return te ? o.default.createElement("div", {
            className: "Composer Composer--lg"
        }, he && HS(S).call(S, function(e) {
            return o.default.createElement(iH, {
                item: e,
                onClick: function(t) {
                    return de(e, t);
                },
                key: e.type
            });
        }), Y && o.default.createElement(oH, {
            active: !!Y,
            target: J.current,
            onClose: me
        }, Y), o.default.createElement("div", {
            className: "Composer-inputWrap"
        }, o.default.createElement(kH, aC({
            invisible: !1
        }, ge))), o.default.createElement(AH, {
            onClick: le,
            disabled: !L
        })) : o.default.createElement(o.default.Fragment, null, o.default.createElement("div", {
            className: "Composer",
            "data-has-value": L,
            "data-has-text-once": !!I
        }, p.canRecord && o.default.createElement(aH, {
            className: "Composer-inputTypeBtn",
            "data-icon": ve,
            icon: ve,
            onClick: re,
            "aria-label": pe ? "切换到语音输入" : "切换到键盘输入"
        }), o.default.createElement("div", {
            className: "Composer-inputWrap"
        }, o.default.createElement(kH, aC({
            invisible: !pe
        }, ge)), !pe && o.default.createElement(nH, p)), !x && C && o.default.createElement(aH, C), he && o.default.createElement(aH, {
            className: c("Composer-toggleBtn", {
                active: G
            }),
            icon: "plus",
            onClick: se,
            "aria-label": G ? "关闭工具栏" : "展开工具栏"
        }), L && o.default.createElement(AH, {
            onClick: le,
            disabled: !L
        })), G && o.default.createElement(rH, {
            onClickOutside: fe
        }, Y || o.default.createElement(fB, {
            items: S,
            onClick: de
        })));
    }), FH = o.default.forwardRef(function(e, n) {
        var r = e.wideBreakpoint, a = e.locale, i = void 0 === a ? "zh-CN" : a, c = e.locales, u = e.colorScheme, l = e.elderMode, s = e.navbar, f = e.renderNavbar, d = e.loadMoreText, m = e.renderBeforeMessageList, p = e.messagesRef, v = e.onRefresh, h = e.onScroll, g = e.messages, y = void 0 === g ? [] : g, b = e.isTyping, E = e.renderMessageContent, w = e.onBackBottomShow, N = e.onBackBottomClick, S = e.quickReplies, T = void 0 === S ? [] : S, C = e.quickRepliesVisible, O = e.onQuickReplyClick, R = void 0 === O ? function() {} : O, x = e.onQuickReplyScroll, k = e.renderQuickReplies, A = e.text, I = e.textOnce, M = e.placeholder, _ = e.onInputFocus, L = e.onInputChange, j = e.onInputBlur, P = e.onSend, D = e.onImageSend, F = e.inputOptions, B = e.composerRef, H = e.inputType, U = e.onInputTypeChange, z = e.recorder, G = e.toolbar, W = e.onToolbarClick, V = e.onAccessoryToggle, Y = e.rightAction, q = e.Composer, X = void 0 === q ? DH : q, $ = e.isX, K = xS(t.useState("light"), 2), Q = K[0], J = K[1];
        return t.useEffect({
            "FH.useEffect": function() {
                var e = document.documentElement;
                bH && (e.dataset.safari = "");
                var t = wH();
                t && (t < 11 && e.classList.add("no-btn-flex"), t < 13 && e.classList.add("no-scrolling"));
            }
        }["FH.useEffect"], []), t.useEffect({
            "FH.useEffect": function() {
                var e = {
                    "FH.useEffect.e": function(e) {
                        J(e), document.documentElement.dataset.colorScheme = e;
                    }
                }["FH.useEffect.e"];
                if ("auto" === u) {
                    var t = window.matchMedia("(prefers-color-scheme: dark)"), n = {
                        "FH.useEffect.n": function(t) {
                            e(t.matches ? "dark" : "light");
                        }
                    }["FH.useEffect.n"];
                    return t.addEventListener("change", n), n(t), ({
                        "FH.useEffect": function() {
                            t.removeEventListener("change", n);
                        }
                    })["FH.useEffect"];
                }
                "dark" === u && e(u);
            }
        }["FH.useEffect"], [
            u
        ]), o.default.createElement(FP, {
            locale: i,
            locales: c,
            colorScheme: Q,
            elderMode: l
        }, o.default.createElement("div", {
            className: "ChatApp",
            "data-elder-mode": l,
            "data-x": $,
            ref: n
        }, f ? f() : s && o.default.createElement(zD, s), o.default.createElement($B, {
            ref: p,
            loadMoreText: d,
            messages: y,
            isTyping: b,
            renderBeforeMessageList: m,
            renderMessageContent: E,
            onRefresh: v,
            onScroll: h,
            onBackBottomShow: w,
            onBackBottomClick: N
        }), o.default.createElement("div", {
            className: "ChatFooter"
        }, k ? k() : o.default.createElement(DF, {
            items: T,
            visible: C,
            onClick: R,
            onScroll: x
        }), o.default.createElement(X, {
            wideBreakpoint: r,
            ref: B,
            inputType: H,
            text: A,
            textOnce: I,
            inputOptions: F,
            placeholder: M,
            onAccessoryToggle: V,
            recorder: z,
            toolbar: G,
            onToolbarClick: W,
            onInputTypeChange: U,
            onFocus: function(e) {
                p && p.current && p.current.scrollToEnd({
                    animated: !1,
                    force: !0
                }), _ && _(e);
            },
            onChange: L,
            onBlur: j,
            onSend: P,
            onImageSend: D,
            rightAction: Y
        }))));
    });
    e.Avatar = aO, e.Backdrop = cO, e.Bubble = lO, e.Button = pO, e.Card = hO, e.CardActions = function(e) {
        var t = e.children, n = e.className, r = e.direction, a = EC(e, iR);
        return o.default.createElement("div", aC({
            className: c("CardActions", n, r && "CardActions--".concat(r))
        }, a), t);
    }, e.CardContent = function(e) {
        var t = e.className, n = e.children, r = EC(e, xO);
        return o.default.createElement("div", aC({
            className: c("CardContent", t)
        }, r), n);
    }, e.CardHeader = function(e) {
        var t = e.className, n = e.icon, r = e.iconColor, a = e.logo, i = e.title, u = e.desc, l = e.hasBg, s = e.badge, f = e.children, d = EC(e, rR);
        return o.default.createElement(NO, aC({
            className: c("CardHeader", t),
            "data-has-bg": !!l
        }, d), n && ($O(n).call(n, "//") ? o.default.createElement(nR, {
            className: "CardHeader-icon",
            src: n
        }) : o.default.createElement(fO, {
            className: "CardHeader-icon",
            style: {
                color: r
            },
            type: n
        })), o.default.createElement(OO, null, a ? o.default.createElement(nR, {
            className: "CardHeader-logo",
            src: a
        }) : o.default.createElement(eR, {
            as: "h4",
            className: "CardHeader-title",
            truncate: 2
        }, i), u && o.default.createElement(eR, {
            as: "h5",
            className: "CardHeader-desc",
            truncate: !0
        }, u)), s ? o.default.createElement("div", {
            className: "CardHeader-badge",
            style: {
                backgroundImage: "url(".concat(s, ")")
            }
        }) : f && o.default.createElement("div", {
            className: "CardHeader-slot"
        }, f));
    }, e.CardMedia = function(e) {
        var t = e.className, n = e.aspectRatio, r = void 0 === n ? "square" : n, a = e.color, i = e.image, u = e.children, l = EC(e, RO), s = {
            backgroundColor: a || void 0,
            backgroundImage: "string" == typeof i ? "url('".concat(i, "')") : void 0
        };
        return o.default.createElement("div", aC({
            className: c("CardMedia", {
                "CardMedia--wide": "wide" === r,
                "CardMedia--square": "square" === r
            }, t),
            style: s
        }, l), u && o.default.createElement(NO, {
            className: "CardMedia-content",
            direction: "column",
            center: !0
        }, u));
    }, e.CardText = function(e) {
        var t = e.className, n = e.children, r = EC(e, aR);
        return o.default.createElement("div", aC({
            className: c("CardText", t)
        }, r), "string" == typeof n ? o.default.createElement("p", null, n) : n);
    }, e.CardTitle = function(e) {
        var t = e.className, n = e.title, r = e.subtitle, a = e.center, i = e.children, u = EC(e, oR);
        return o.default.createElement("div", aC({
            className: c("CardTitle", {
                "CardTitle--center": a
            }, t)
        }, u), n && o.default.createElement("h5", {
            className: "CardTitle-title"
        }, n), i && "string" == typeof i && o.default.createElement("h5", {
            className: "CardTitle-title"
        }, i), r && o.default.createElement("p", {
            className: "CardTitle-subtitle"
        }, r), i && "string" != typeof i && i);
    }, e.Carousel = d_, e.Checkbox = p_, e.CheckboxGroup = function(e) {
        var t = e.className, n = e.options, r = e.value, a = e.name, i = e.disabled, u = e.block, l = e.onChange;
        function s(e, t) {
            var n = t.target.checked ? VS(r).call(r, e) : QS(r).call(r, function(t) {
                return t !== e;
            });
            l(n, t);
        }
        return o.default.createElement("div", {
            className: c("CheckboxGroup", {
                "CheckboxGroup--block": u
            }, t)
        }, HS(n).call(n, function(e) {
            return o.default.createElement(p_, {
                label: e.label || e.value,
                value: e.value,
                name: a,
                checked: $O(r).call(r, e.value),
                disabled: "disabled" in e ? e.disabled : i,
                onChange: function(t) {
                    s(e.value, t);
                },
                key: e.value
            });
        }));
    }, e.ClickOutside = y_, e.ComponentsProvider = function(e) {
        var n = e.components, r = e.children, a = o.default.useRef(oO({}, n));
        return t.useEffect(function() {
            a.current = oO(oO({}, n), a.current);
        }, [
            n
        ]), o.default.createElement(JC.Provider, {
            value: {
                addComponent: function(e, t) {
                    a.current[e] = t;
                },
                hasComponent: function(e) {
                    return a.current.hasOwnProperty(e);
                },
                getComponent: function(e) {
                    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : function() {}, n = a.current[e];
                    if (!n) return t({
                        code: e,
                        errCode: "NO_CODE"
                    }), null;
                    if ("component" in n) return "decorator" !== n.type && t({
                        code: e,
                        async: !1,
                        component: n.component
                    }), n.component;
                    if ("decorator" in n) {
                        var r = function(e) {
                            return o.default.createElement(nO, aC({
                                code: n.decorator,
                                decoratorData: n.data,
                                onLoad: t
                            }, e));
                        };
                        return a.current[e] = {
                            component: r,
                            type: "decorator"
                        }, r;
                    }
                    if ("url" in n) {
                        var i = pm(n.url, n.name, function() {
                            a.current[e] = {
                                component: i
                            }, t({
                                code: e,
                                async: !0,
                                component: i
                            });
                        }, function() {
                            t({
                                code: e,
                                errCode: "ERR_IMPORT_SCRIPT"
                            });
                        });
                        return i;
                    }
                    return t({
                        code: e,
                        errCode: "NO_HANDLER"
                    }), null;
                }
            }
        }, r);
    }, e.ConfigContext = DP, e.ConfigProvider = FP, e.Confirm = function(e) {
        var t = e.className, n = e.vertical, r = e.actions, a = EC(e, HD), i = HP().locale, u = void 0 === i ? "" : i, l = $O(u).call(u, "zh"), s = null != n ? n : !l;
        return Array.isArray(r) && BD(r).call(r, function(e, t) {
            return UD(e) ? s ? -1 : 1 : UD(t) ? s ? 1 : -1 : 0;
        }), o.default.createElement(tD, aC({
            baseClass: "Modal",
            className: c("Confirm", t),
            showClose: !1,
            btnVariant: "outline",
            vertical: s,
            actions: r
        }, a));
    }, e.DOMPurify = ue, e.Divider = function(e) {
        var t = e.className, n = e.position, r = void 0 === n ? "center" : n, a = e.children, i = EC(e, b_);
        return o.default.createElement("div", aC({
            className: c("Divider", !!a && "Divider--text-".concat(r), t),
            role: "separator"
        }, i), a);
    }, e.Empty = function(e) {
        var t = e.className, n = e.type, r = e.image, a = e.tip, i = e.children, u = r || ("error" === n ? "https://gw.alicdn.com/imgextra/i3/O1CN011bYju01hGYK2LMydz_!!6000000004250-55-tps-280-280.svg" : "https://gw.alicdn.com/imgextra/i3/O1CN01c0BqGH1Jx6L1ihheM_!!6000000001094-55-tps-280-280.svg");
        return o.default.createElement(NO, {
            className: c("Empty", t),
            direction: "column",
            center: !0
        }, o.default.createElement("img", {
            className: "Empty-img",
            src: u,
            alt: a
        }), a && o.default.createElement("p", {
            className: "Empty-tip"
        }, a), i);
    }, e.ErrorBoundary = $C, e.FileCard = function(e) {
        var t, n = e.className, r = e.file, a = e.extension, i = e.children, u = r.name, l = r.size, s = a || CT(t = u).call(t, 2 + (IB(t).call(t, ".") - 1 >>> 0));
        return o.default.createElement(hO, {
            className: c("FileCard", n),
            size: "xl"
        }, o.default.createElement(NO, null, o.default.createElement("div", {
            className: "FileCard-icon",
            "data-type": s
        }, o.default.createElement(fO, {
            type: "file"
        }), o.default.createElement(eR, {
            truncate: !0,
            as: "span",
            className: "FileCard-ext"
        }, s)), o.default.createElement(OO, null, o.default.createElement(eR, {
            truncate: 2,
            breakWord: !0,
            className: "FileCard-name"
        }, u), o.default.createElement("div", {
            className: "FileCard-meta"
        }, null != l && o.default.createElement("span", {
            className: "FileCard-size"
        }, function(e, t) {
            var n, r;
            if (e < 1) return VS(r = "".concat(e, " ")).call(r, GB[0]);
            var o = t || 2, a = Math.floor(Math.log(e) / Math.log(1024));
            return VS(n = "".concat(zB((e / Math.pow(1024, a)).toFixed(o)), " ")).call(n, GB[a]);
        }(l)), i))));
    }, e.Flex = NO, e.FlexItem = OO, e.Form = function(e) {
        var t = e.className, n = e.theme, r = void 0 === n ? "" : n, a = e.children, i = EC(e, E_);
        return o.default.createElement(w_.Provider, {
            value: r
        }, o.default.createElement("form", aC({
            className: c("Form", {
                "is-light": "light" === r
            }, t)
        }, i), a));
    }, e.FormActions = function(e) {
        var t = e.children, n = EC(e, O_);
        return o.default.createElement("div", aC({
            className: c("FormActions")
        }, n), t);
    }, e.FormItem = function(e) {
        var t = e.label, n = e.help, r = e.required, a = e.invalid, i = e.hidden, u = e.children;
        return o.default.createElement("div", {
            className: c("FormItem", {
                required: r,
                "is-invalid": a
            }),
            hidden: i
        }, t && o.default.createElement(S_, null, t), u, n && o.default.createElement(C_, null, n));
    }, e.Goods = VB, e.Icon = fO, e.IconButton = x_, e.Image = nR, e.InfiniteScroll = I_, e.Input = RP, e.LazyComponent = function(e) {
        var t = e.component, n = e.code, r = e.onLoad, a = EC(e, tO);
        return t ? (r && r({
            async: !1,
            component: t
        }), o.default.createElement(QC, aC({
            component: t
        }, a))) : o.default.createElement(nO, aC({
            code: n,
            onLoad: r
        }, a));
    }, e.List = xP, e.ListItem = AP, e.Loading = function(e) {
        var t = e.tip, n = e.children;
        return o.default.createElement(NO, {
            className: "Loading",
            center: !0
        }, o.default.createElement(fO, {
            type: "spinner",
            spin: !0
        }), t && o.default.createElement("p", {
            className: "Loading-tip"
        }, t), n);
    }, e.LocaleContext = DP, e.LocaleProvider = FP, e.MediaObject = function(e) {
        var t = e.className, n = e.picUrl, r = e.picSize, a = e.title, i = e.picAlt, u = e.meta;
        return o.default.createElement("div", {
            className: c("MediaObject", t)
        }, n && o.default.createElement("div", {
            className: c("MediaObject-pic", r && "MediaObject-pic--".concat(r))
        }, o.default.createElement("img", {
            src: n,
            alt: i || a
        })), o.default.createElement("div", {
            className: "MediaObject-info"
        }, o.default.createElement("h3", {
            className: "MediaObject-title"
        }, a), o.default.createElement("div", {
            className: "MediaObject-meta"
        }, u)));
    }, e.Message = KP, e.MessageStatus = function(e) {
        var n = e.status, r = e.delay, a = void 0 === r ? 800 : r, i = e.maxDelay, c = void 0 === i ? 12e3 : i, u = e.retryInterval, l = void 0 === u ? 5e3 : u, s = e.onRetry, f = e.onChange, d = xS(t.useState(""), 2), m = d[0], p = d[1], v = t.useRef(), h = t.useRef(), g = t.useRef();
        function y() {
            v.current && clearTimeout(v.current), h.current && clearTimeout(h.current), g.current && clearInterval(g.current);
        }
        var b = t.useCallback({
            "useCallback[b]": function() {
                y(), v.current = setTimeout({
                    "useCallback[b]": function() {
                        p("loading");
                    }
                }["useCallback[b]"], a), h.current = setTimeout({
                    "useCallback[b]": function() {
                        p("fail"), y();
                    }
                }["useCallback[b]"], c), g.current = setInterval({
                    "useCallback[b]": function() {
                        s && s(!0);
                    }
                }["useCallback[b]"], l);
            }
        }["useCallback[b]"], [
            a,
            c,
            s,
            l
        ]);
        return t.useEffect(function() {
            return y(), "pending" === n ? b() : "sent" === n ? p("") : "fail" === n && p("fail"), y;
        }, [
            n,
            b
        ]), t.useEffect(function() {
            f && f(m);
        }, [
            f,
            m
        ]), m ? o.default.createElement("div", {
            className: "MessageStatus",
            "data-status": m
        }, "fail" === m ? o.default.createElement(x_, {
            icon: "warning-circle-fill",
            onClick: function() {
                p("loading"), b(), s && s();
            }
        }) : o.default.createElement(fO, {
            type: "spinner",
            spin: !0
        })) : null;
    }, e.Modal = nD, e.Navbar = zD, e.Notice = function(e) {
        var t = e.content, n = e.closable, r = void 0 === n || n, a = e.leftIcon, i = void 0 === a ? "bullhorn" : a, c = e.onClick, u = e.onClose;
        return o.default.createElement("div", {
            className: "Notice",
            role: "alert",
            "aria-atomic": !0,
            "aria-live": "assertive"
        }, i && o.default.createElement(fO, {
            className: "Notice-icon",
            type: i
        }), o.default.createElement("div", {
            className: "Notice-content",
            onClick: c
        }, o.default.createElement(eR, {
            className: "Notice-text",
            truncate: !0
        }, t)), r && o.default.createElement(x_, {
            className: "Notice-close",
            icon: "close",
            onClick: u,
            "aria-label": "关闭通知"
        }));
    }, e.Popup = function(e) {
        return o.default.createElement(tD, aC({
            baseClass: "Popup",
            overflow: !0
        }, e));
    }, e.Portal = function(e) {
        var r = e.children, o = e.container, a = void 0 === o ? document.body : o, i = e.onRendered, c = xS(t.useState(null), 2), u = c[0], l = c[1];
        return t.useEffect(function() {
            var e;
            l((e = a) ? e instanceof Element ? e : "function" == typeof e ? e() : e.current || e : null);
        }, [
            a
        ]), t.useLayoutEffect(function() {
            i && u && i();
        }, [
            u,
            i
        ]), u ? n.createPortal(r, u) : u;
    }, e.Price = EF, e.Progress = NF, e.PullToRefresh = kF, e.QuickReplies = DF, e.Quote = function(e) {
        var t = e.className, n = e.author, r = e.children, a = e.onClick;
        return o.default.createElement("div", {
            className: c("Quote", t),
            onClick: a
        }, n && o.default.createElement("div", {
            className: "Quote-author"
        }, n), o.default.createElement("div", {
            className: "Quote-content"
        }, r));
    }, e.Radio = BF, e.RadioGroup = function(e) {
        var t = e.className, n = e.options, r = e.value, a = e.name, i = e.disabled, u = e.block, l = e.onChange;
        return o.default.createElement("div", {
            className: c("RadioGroup", {
                "RadioGroup--block": u
            }, t)
        }, HS(n).call(n, function(e) {
            return o.default.createElement(BF, {
                label: e.label || e.value,
                value: e.value,
                name: a,
                checked: r === e.value,
                disabled: "disabled" in e ? e.disabled : i,
                onChange: function(t) {
                    l(e.value, t);
                },
                key: e.value
            });
        }));
    }, e.RateActions = function(e) {
        var n = HP("RateActions", {
            up: "赞同",
            down: "反对"
        }).trans, r = e.upTitle, a = void 0 === r ? n("up") : r, i = e.downTitle, u = void 0 === i ? n("down") : i, l = e.onClick, s = xS(t.useState(""), 2), f = s[0], d = s[1];
        function m(e) {
            f || (d(e), l(e));
        }
        return o.default.createElement("div", {
            className: "RateActions"
        }, f !== UF && o.default.createElement(x_, {
            className: c("RateBtn", {
                active: f === HF
            }),
            title: a,
            "data-type": HF,
            icon: "thumbs-up",
            onClick: function() {
                m(HF);
            }
        }), f !== HF && o.default.createElement(x_, {
            className: c("RateBtn", {
                active: f === UF
            }),
            title: u,
            "data-type": UF,
            icon: "thumbs-down",
            onClick: function() {
                m(UF);
            }
        }));
    }, e.RichText = GF, e.ScrollGrid = function(e) {
        var n = e.wrap, r = void 0 !== n && n, a = e.children, i = e.onIndicatorToggle, c = xS(t.useState(!1), 2), u = c[0], l = c[1], s = xS(t.useState(0), 2), f = s[0], d = s[1], m = xS(t.useState(0), 2), p = m[0], v = m[1], h = t.useRef(null), g = t.useRef(.04), y = ym(i);
        return t.useEffect(function() {
            if (!r) return e(), window.addEventListener("resize", e), function() {
                window.removeEventListener("resize", e);
            };
            function e() {
                var e = h.current;
                if (e) {
                    var t = e.scrollWidth, n = e.clientWidth;
                    if (t !== n) {
                        var r = 20 / t;
                        g.current = r, l(!0), d(n * r);
                    } else l(!1);
                }
            }
        }, [
            r
        ]), t.useEffect(function() {
            var e;
            null === (e = y.current) || void 0 === e || e.call(y, u);
        }, [
            y,
            u
        ]), o.default.createElement("div", {
            className: "ScrollGrid",
            "data-wrap": r
        }, o.default.createElement("div", {
            className: "ScrollGrid-scroller",
            ref: h,
            onScroll: r ? void 0 : function(e) {
                var t = e.target.scrollLeft;
                v(t * g.current);
            }
        }, o.default.createElement("div", {
            className: "ScrollGrid-inner"
        }, a)), u && o.default.createElement("div", {
            className: "ScrollGrid-indicator"
        }, o.default.createElement("div", {
            className: "ScrollGrid-indicatorBar",
            style: {
                width: f,
                transform: "translateX(".concat(p, "px)")
            }
        })));
    }, e.ScrollView = LF, e.Search = function(e) {
        var n = e.className, r = e.onSearch, a = e.onChange, i = e.onClear, u = e.value, l = e.disabled, s = e.clearable, f = void 0 === s || s, d = e.showSearch, m = void 0 === d || d, p = EC(e, WF), v = xS(t.useState(u || ""), 2), h = v[0], g = v[1], y = HP("Search").trans;
        return o.default.createElement("div", {
            className: c("Search", n),
            "data-disabled": l
        }, o.default.createElement(fO, {
            className: "Search-icon",
            type: "search"
        }), o.default.createElement(RP, aC({
            className: "Search-input",
            type: "search",
            value: h,
            disabled: l,
            enterKeyHint: "search",
            onChange: function(e) {
                g(e), a && a(e);
            },
            onKeyDown: function(e) {
                13 === e.keyCode && (r && r(h, e), e.preventDefault());
            }
        }, p)), f && h && o.default.createElement(x_, {
            className: "Search-clear",
            icon: "x-circle-fill",
            onClick: function() {
                g(""), i && i();
            }
        }), m && o.default.createElement(pO, {
            className: "Search-btn",
            color: "primary",
            onClick: function(e) {
                r && r(h, e);
            }
        }, y("search")));
    }, e.Select = YF, e.Skeleton = function(e) {
        var t = e.className, n = e.w, r = e.h, a = e.mb, i = e.r, u = e.style;
        return o.default.createElement("div", {
            className: c("Skeleton", i && "Skeleton--r-".concat(i), t),
            style: XF(XF({}, u), {}, {
                width: n,
                height: r,
                marginBottom: a
            })
        });
    }, e.Step = eB, e.Stepper = JF, e.SystemMessage = UP, e.Tab = function(e) {
        var t = e.children;
        return o.default.createElement("div", null, t);
    }, e.Tabs = function(e) {
        var n = e.className, r = e.index, a = void 0 === r ? 0 : r, i = e.scrollable, u = e.hideNavIfOnlyOne, l = e.children, s = e.onChange, f = xS(t.useState({}), 2), d = f[0], m = f[1], p = xS(t.useState(a || 0), 2), v = p[0], h = p[1], g = t.useRef(v), y = t.useRef(null), b = [], E = [], w = JP("tabs-");
        function N(e, t) {
            h(e), s && s(e, t);
        }
        o.default.Children.forEach(l, function(e, t) {
            var n;
            if (e) {
                var r = v === t, a = VS(n = "".concat(w, "-")).call(n, t);
                b.push(o.default.createElement(rB, {
                    active: r,
                    index: t,
                    key: a,
                    onClick: N,
                    "aria-controls": a,
                    tabIndex: r ? -1 : 0
                }, e.props.label)), e.props.children && E.push(o.default.createElement(oB, {
                    active: r,
                    key: a,
                    id: a
                }, e.props.children));
            }
        }), t.useEffect(function() {
            h(a);
        }, [
            a
        ]);
        var S = t.useCallback({
            "useCallback[S]": function() {
                var e = y.current;
                if (e) {
                    var t = e.children[g.current];
                    if (t) {
                        var n = t.querySelector("span");
                        if (n) {
                            var r = t, o = r.offsetWidth, a = r.offsetLeft, c = n.getBoundingClientRect().width, u = Math.max(c - 16, 26), l = a + o / 2;
                            m({
                                transform: "translateX(".concat(l - u / 2, "px)"),
                                width: "".concat(u, "px")
                            }), i && CF({
                                el: e,
                                to: l - e.offsetWidth / 2,
                                x: !0
                            });
                        }
                    }
                }
            }
        }["useCallback[S]"], [
            i
        ]);
        t.useEffect(function() {
            var e, t = y.current;
            return t && "ResizeObserver" in window && (e = new ResizeObserver(S)).observe(t), function() {
                e && t && e.unobserve(t);
            };
        }, [
            S
        ]), t.useEffect(function() {
            g.current = v, S();
        }, [
            v,
            S
        ]);
        var T = b.length > (u ? 1 : 0);
        return o.default.createElement("div", {
            className: c("Tabs", {
                "Tabs--scrollable": i
            }, n)
        }, T && o.default.createElement("div", {
            className: "Tabs-nav",
            role: "tablist",
            ref: y
        }, b, o.default.createElement("span", {
            className: "Tabs-navPointer",
            style: d
        })), o.default.createElement("div", {
            className: "Tabs-content"
        }, E));
    }, e.Tag = iB, e.Text = eR, e.Think = function(e) {
        var n = e.className, r = e.isDone, a = e.thinkTime, i = e.children, u = xS(t.useState(!0), 2), l = u[0], s = u[1];
        return o.default.createElement("div", {
            className: c("Think", n),
            "data-collapsed": !l
        }, o.default.createElement("div", {
            className: "Think-toggle",
            onClick: function() {
                s(function(e) {
                    return !e;
                });
            }
        }, function() {
            if (r) {
                var e = a ? "（用时".concat(a, "秒）") : "";
                return "已深度思考".concat(e);
            }
            return "思考中...";
        }(), o.default.createElement(fO, {
            type: "chevron-up"
        })), l && o.default.createElement("div", {
            className: "Think-content"
        }, i));
    }, e.Time = qP, e.Toast = cB, e.Toolbar = fB, e.Tree = function(e) {
        var t = e.className, n = e.children;
        return o.default.createElement("div", {
            className: c("Tree", t),
            role: "tree"
        }, n);
    }, e.TreeNode = function(e) {
        var n = e.title, r = e.content, a = e.link, i = e.children, u = void 0 === i ? [] : i, l = e.onClick, s = e.onExpand, f = xS(t.useState(!1), 2), d = f[0], m = f[1], p = u.length > 0;
        return o.default.createElement("div", {
            className: "TreeNode",
            role: "treeitem",
            "aria-expanded": d
        }, o.default.createElement("div", {
            className: "TreeNode-title",
            onClick: function() {
                p ? (m(!d), s(n, !d)) : l({
                    title: n,
                    content: r,
                    link: a
                });
            },
            role: "treeitem",
            "aria-expanded": d,
            tabIndex: 0
        }, o.default.createElement("span", {
            className: "TreeNode-title-text"
        }, n), p ? o.default.createElement(fO, {
            className: "TreeNode-title-icon",
            type: d ? "chevron-up" : "chevron-down"
        }) : null), p ? HS(u).call(u, function(e, t) {
            return o.default.createElement("div", {
                className: c("TreeNode-children", {
                    "TreeNode-children-active": d
                }),
                key: t
            }, o.default.createElement("div", {
                className: "TreeNode-title TreeNode-children-title",
                onClick: function() {
                    return l(mB(mB({}, e), {
                        index: t
                    }));
                },
                role: "treeitem"
            }, o.default.createElement("span", {
                className: "TreeNode-title-text"
            }, e.title)));
        }) : null);
    }, e.Typing = function(e) {
        var t = e.text;
        return o.default.createElement(lO, {
            type: "typing"
        }, o.default.createElement("div", {
            className: "Typing",
            "aria-busy": "true"
        }, t && o.default.createElement("span", {
            className: "Typing-text"
        }, t), o.default.createElement("div", {
            className: "Typing-dot"
        }), o.default.createElement("div", {
            className: "Typing-dot"
        }), o.default.createElement("div", {
            className: "Typing-dot"
        })));
    }, e.TypingBubble = function(e) {
        var n = e.content, r = e.className, a = e.isRichText, i = e.options, u = e.messageRender, l = e.onResize, s = e.children, f = EC(e, pB), d = OT(u ? u(n) : n, i), m = d.typedContent, p = d.isTyping, v = t.useRef(null);
        t.useEffect(function() {
            if ("ResizeObserver" in window) {
                var e = new ResizeObserver(function() {
                    null == l || l(v.current);
                });
                return v.current && e.observe(v.current), function() {
                    e.disconnect();
                };
            }
        }, [
            l
        ]);
        var h = p ? "typing" : null;
        return o.default.createElement("div", aC({
            className: c("Bubble richtext", r)
        }, f, {
            ref: v
        }), m && (a ? o.default.createElement(GF, {
            "data-effect": h,
            content: m
        }) : o.default.createElement("div", {
            "data-effect": h
        }, o.default.createElement("p", null, m))), s);
    }, e.Video = function(e) {
        var n = e.className, r = e.src, a = e.cover, i = e.duration, u = e.onClick, l = e.onCoverLoad, s = e.style, f = e.videoRef, d = e.children, m = EC(e, vB), p = t.useRef(null), v = f || p, h = xS(t.useState(!1), 2), g = h[0], y = h[1], b = xS(t.useState(!0), 2), E = b[0], w = b[1];
        function N() {
            w(!0);
        }
        var S = !g && !!a, T = S && !!i;
        return o.default.createElement("div", {
            className: c("Video", "Video--".concat(E ? "paused" : "playing"), n),
            style: s
        }, S && o.default.createElement("img", {
            className: "Video-cover",
            src: a,
            onLoad: l,
            alt: ""
        }), T && o.default.createElement("span", {
            className: "Video-duration"
        }, function(e) {
            if (!e) return "";
            var t = Math.floor(e / 3600), n = Math.floor((e - 3600 * t) / 60), r = Math.floor(e - 3600 * t - 60 * n), o = "";
            return t > 0 && (o += "".concat(t, ":")), o += "".concat(n, ":"), r < 10 && (o += "0"), o + r;
        }(+i)), o.default.createElement("video", aC({
            className: "Video-video",
            src: r,
            ref: v,
            hidden: S,
            controls: !0,
            onPlay: function() {
                w(!1);
            },
            onPause: N,
            onEnded: N
        }, m), d), S && o.default.createElement("button", {
            className: c("Video-playBtn", {
                paused: E
            }),
            type: "button",
            onClick: function(e) {
                y(!0);
                var t = v.current;
                t && (t.ended || t.paused ? t.play() : t.pause()), u && u(E, e);
            }
        }, o.default.createElement(fO, {
            className: "Video-playIcon",
            type: "play-fill"
        })));
    }, e.VisuallyHidden = function(e) {
        return o.default.createElement("span", aC({
            style: hB
        }, e));
    }, e.canUse = Xr, e.clsx = c, e.default = FH, e.importScript = mm, e.lazyComponent = pm, e.mountComponent = vm, e.toast = lB, e.useClickOutside = hm, e.useComponents = ZC, e.useConfig = BP, e.useForwardRef = gm, e.useLatest = ym, e.useLocale = HP, e.useMessages = function() {
        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], n = t.useMemo({
            "useMemo[n]": function() {
                return HS(e).call(e, {
                    "useMemo[n]": function(e) {
                        return NT(e);
                    }
                }["useMemo[n]"]);
            }
        }["useMemo[n]"], [
            e
        ]), r = xS(t.useState(n), 2), o = r[0], a = r[1], i = t.useCallback({
            "useCallback[i]": function(e) {
                a({
                    "useCallback[i]": function(t) {
                        var n;
                        return VS(n = []).call(n, mS(e), mS(t));
                    }
                }["useCallback[i]"]);
            }
        }["useCallback[i]"], []), c = t.useCallback({
            "useCallback[c]": function(e, t) {
                a({
                    "useCallback[c]": function(n) {
                        return HS(n).call(n, {
                            "useCallback[c]": function(n) {
                                return n._id === e ? NT(t, e) : n;
                            }
                        }["useCallback[c]"]);
                    }
                }["useCallback[c]"]);
            }
        }["useCallback[c]"], []), u = t.useCallback({
            "useCallback[u]": function(e) {
                var t = NT(e);
                return a({
                    "useCallback[u]": function(e) {
                        var n;
                        return VS(n = []).call(n, mS(e), [
                            t
                        ]);
                    }
                }["useCallback[u]"]), t._id;
            }
        }["useCallback[u]"], []), l = t.useCallback({
            "useCallback[l]": function(e) {
                a({
                    "useCallback[l]": function(t) {
                        return QS(t).call(t, {
                            "useCallback[l]": function(t) {
                                return t._id !== e;
                            }
                        }["useCallback[l]"]);
                    }
                }["useCallback[l]"]);
            }
        }["useCallback[l]"], []), s = t.useCallback({
            "useCallback[s]": function() {
                a(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []);
            }
        }["useCallback[s]"], []);
        return {
            messages: o,
            prependMsgs: i,
            appendMsg: u,
            updateMsg: c,
            deleteMsg: l,
            resetList: s
        };
    }, e.useMount = ST, e.useQuickReplies = function() {
        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], n = xS(t.useState(e), 2), r = n[0], o = n[1], a = xS(t.useState(!0), 2), i = a[0], c = a[1], u = t.useRef(), l = t.useRef();
        return t.useEffect(function() {
            u.current = r;
        }, [
            r
        ]), {
            quickReplies: r,
            prepend: function(e) {
                o(function(t) {
                    var n;
                    return VS(n = []).call(n, mS(e), mS(t));
                });
            },
            replace: o,
            visible: i,
            setVisible: c,
            save: function() {
                l.current = u.current;
            },
            pop: function() {
                l.current && o(l.current);
            }
        };
    }, e.useTitleTyping = function() {
        var e = xS(t.useState(!1), 2), n = e[0], r = e[1], o = t.useRef(), a = t.useRef(), i = function(e, t) {
            var n = xS(e, 2), r = TT(n[0], n[1]);
            o.current = setTimeout(t, r);
        }, c = t.useCallback({
            "useCallback[c]": function() {
                clearTimeout(o.current), clearTimeout(a.current), r(!1);
            }
        }["useCallback[c]"], []), u = t.useCallback({
            "useCallback[u]": function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t = e.delay, n = e.timeout;
                clearTimeout(o.current), o.current = setTimeout({
                    "useCallback[u]": function() {
                        r(!0), i([
                            2500,
                            3500
                        ], {
                            "useCallback[u]": function() {
                                r(!1), i([
                                    1e3,
                                    1800
                                ], {
                                    "useCallback[u]": function() {
                                        u();
                                    }
                                }["useCallback[u]"]);
                            }
                        }["useCallback[u]"]);
                    }
                }["useCallback[u]"], t), n && (a.current = setTimeout({
                    "useCallback[u]": function() {
                        c();
                    }
                }["useCallback[u]"], n));
            }
        }["useCallback[u]"], [
            c
        ]);
        return {
            isTyping: n,
            start: u,
            stop: c
        };
    }, e.useTypewriter = OT, Object.defineProperty(e, "__esModule", {
        value: !0
    });
});
}}),
}]);

//# sourceMappingURL=node_modules_5c02abb8._.js.map