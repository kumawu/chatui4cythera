{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 60, "column": 0}, "map": {"version":3,"sources":["file:///Users/lihan2/Documents/project/chatui4cythera/src/app/api/utils/chatApiHandler.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\n\n/**\n * 通用聊天API处理函数\n * @param requestData 已解析的请求数据\n * @param apiKey Dify API密钥\n * @returns 流式响应\n */\nexport async function handleChatRequest(requestData: any, apiKey: string) {\n  try {\n    // 从请求数据中提取需要的字段\n    const { message, role, conversationId, language, assistantIndex } = requestData;\n    \n    console.log(\"Chat API 请求:\", { message, role, conversationId, language, assistantIndex });\n    \n    // 构建发送到 Dify 的请求体\n    const difyRequestBody = {\n      inputs: {\n        language: language || 'zh-CN' // 使用请求中的语言或默认值\n      },\n      query: message,\n      response_mode: \"streaming\", // 流式响应\n      conversation_id: conversationId, // 如果有会话ID则传递\n      user: role || \"default_user\" // 用户标识，这里使用角色名称\n    };\n\n    // 发送请求到 Dify API\n    const difyResponse = await fetch(process.env.DIFY_API_URL || \"https://api.dify.ai/v1/chat-messages\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Authorization\": `Bearer ${apiKey}`\n      },\n      body: JSON.stringify(difyRequestBody)\n    });\n\n    if (!difyResponse.ok) {\n      const errorText = await difyResponse.text();\n      console.error(`Dify API 错误 (${difyResponse.status}):`, errorText);\n      return NextResponse.json(\n        { error: `Dify API 请求失败: ${difyResponse.status} ${difyResponse.statusText}` },\n        { status: difyResponse.status }\n      );\n    }\n\n    // 创建一个 TransformStream 来处理流式响应\n    const { readable, writable } = new TransformStream();\n    const writer = writable.getWriter();\n    const encoder = new TextEncoder();\n\n    // 处理 Dify 的流式响应\n    const reader = difyResponse.body?.getReader();\n    if (!reader) {\n      throw new Error(\"无法读取响应流\");\n    }\n    \n    // 用于累积不完整的 JSON 数据\n    let accumulatedJson = '';\n    // 用于累积不完整的行数据\n    let partialLine = '';\n\n    // 异步处理流\n    (async () => {\n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done) {\n            // 处理可能剩余的不完整数据\n            if (partialLine && partialLine.startsWith(\"data: \") && partialLine.length > 6) {\n              const data = partialLine.slice(6);\n              console.log('处理剩余的不完整行:', data);\n              // 尝试处理最后一个不完整的数据\n              try {\n                const jsonToProcess = accumulatedJson + data;\n                const parsedData = JSON.parse(jsonToProcess);\n                const responseChunk = {\n                  type: 'text',\n                  content: parsedData.answer || '',\n                  delta: parsedData.delta || '',\n                  position: 'left',\n                  metadata: {\n                    conversation_id: conversationId,\n                    event_type: 'message_end', // 标记为结束消息\n                    created_at: new Date().toISOString()\n                  }\n                };\n                await writer.write(encoder.encode(`data: ${JSON.stringify(responseChunk)}\\n\\n`));\n              } catch (e) {\n                console.error('处理最后一个数据块时出错:', e);\n              }\n            }\n            await writer.close();\n            break;\n          }\n\n          // 解码二进制数据\n          const chunk = new TextDecoder().decode(value);\n          \n          // 处理可能跨块的行\n          const fullData = partialLine + chunk;\n          partialLine = ''; // 重置部分行\n          \n          // 按行分割，但保留可能不完整的最后一行\n          const lines = fullData.split(\"\\n\");\n          if (!fullData.endsWith(\"\\n\") && lines.length > 0) {\n            partialLine = lines.pop() || '';\n          }\n\n          for (const line of lines) {\n            if (line.startsWith(\"data: \") && line.length > 6) {\n              const data = line.slice(6);\n              \n              if (data === \"[DONE]\") {\n                continue;\n              }\n\n              // 尝试累积并解析 JSON 数据\n              try {\n                // 检查数据是否是有效的 JSON 格式\n                if (!data || data.trim() === '') {\n                  console.warn('收到空数据块，跳过处理');\n                  continue;\n                }\n                \n                // 合并之前累积的数据（如果有）\n                const jsonToProcess = accumulatedJson + data;\n                let parsedData;\n                \n                try {\n                  // 尝试解析合并后的数据\n                  parsedData = JSON.parse(jsonToProcess);\n                  \n                  // 解析成功，重置累积的数据\n                  accumulatedJson = '';\n                  console.log('JSON 解析成功');\n                } catch (parseError) {\n                  // 解析失败，检查是否是因为 JSON 不完整\n                  if (parseError instanceof SyntaxError && parseError.message.includes('Unexpected end of JSON input')) {\n                    // 可能是不完整的 JSON，累积数据等待下一个数据块\n                    accumulatedJson = jsonToProcess;\n                    console.log('累积不完整的 JSON 数据，等待下一个数据块');\n                    continue; // 跳过当前数据块，等待更多数据\n                  } else {\n                    // 其他类型的错误，尝试修复\n                    console.warn('JSON 解析失败，尝试修复数据');\n                    \n                    // // 检查字符串结构，计算左右括号数量\n                    // const leftBraces = (jsonToProcess.match(/\\{/g) || []).length;\n                    // const rightBraces = (jsonToProcess.match(/\\}/g) || []).length;\n                    // const missingBraces = leftBraces - rightBraces;\n                    \n                    // if (missingBraces > 0) {\n                    //   // 添加缺失的右括号\n                    //   const fixedData = jsonToProcess + '}'.repeat(missingBraces);\n                    //   console.warn(`添加了 ${missingBraces} 个右括号尝试修复 JSON`);\n                      \n                    //   try {\n                    //     parsedData = JSON.parse(fixedData);\n                    //     accumulatedJson = ''; // 重置累积数据\n                    //     console.log('修复成功！');\n                    //   } catch (fixError) {\n                    //     // 修复失败，检查是否包含 tools_data_result\n                    //     if (jsonToProcess.includes('<tools_data_result>')) {\n                    //       // 如果包含工具数据，尝试发送特殊消息\n                    //       try {\n                    //         const specialMessage = {\n                    //           type: 'text',\n                    //           content: jsonToProcess,\n                    //           position: 'left',\n                    //           metadata: {\n                    //             conversation_id: conversationId,\n                    //             event_type: 'message_end',\n                    //             created_at: new Date().toISOString()\n                    //           }\n                    //         };\n                            \n                    //         await writer.write(encoder.encode(`data: ${JSON.stringify(specialMessage)}\\n\\n`));\n                    //         accumulatedJson = ''; // 重置累积数据\n                    //         console.log('发送了包含 tools_data_result 的特殊消息');\n                    //         continue;\n                    //       } catch (specialError) {\n                    //         console.error('发送特殊消息失败:', specialError);\n                    //       }\n                    //     }\n                        \n                    //     // 如果不包含工具数据或特殊处理失败，尝试构造最小可用对象\n                    //     if (jsonToProcess.includes('\"event\":') && jsonToProcess.includes('\"conversation_id\":')) {\n                    //       try {\n                    //         const minimalData = `{\"event\": \"message\", \"conversation_id\": \"${conversationId || 'unknown'}\", \"answer\": \"\", \"delta\": \"\"}`;\n                    //         parsedData = JSON.parse(minimalData);\n                    //         accumulatedJson = ''; // 重置累积数据\n                    //         console.log('使用最小化数据替代');\n                    //       } catch (e) {\n                    //         console.error('无法构造最小可用数据');\n                    //         accumulatedJson = ''; // 重置累积数据，放弃这个数据块\n                    //         continue;\n                    //       }\n                    //     } else {\n                    //       accumulatedJson = ''; // 重置累积数据，放弃这个数据块\n                    //       continue;\n                    //     }\n                    //   }\n                    // } else {\n                    //   // 括号数量匹配但仍然解析失败，放弃这个数据块\n                    //   console.error('JSON 格式错误且无法修复');\n                    //   accumulatedJson = ''; // 重置累积数据\n                    //   continue;\n                    // }\n                  }\n                }\n                \n                // 验证解析后的数据是否有效\n                if (!parsedData || typeof parsedData !== 'object') {\n                  console.warn('解析后的数据无效:', parsedData);\n                  continue;\n                }\n                \n                const responseChunk = {\n                  type: 'text',\n                  content: parsedData.answer || '',\n                  delta: parsedData.delta || '',\n                  position: 'left',\n                  metadata: {\n                    conversation_id: conversationId,\n                    event_type: parsedData.event || 'message',\n                    created_at: new Date().toISOString()\n                  }\n                };\n                \n                await writer.write(encoder.encode(`data: ${JSON.stringify(responseChunk)}\\n\\n`));\n              } catch (e) {\n                console.error('处理数据时出现意外错误:', e);\n                console.log('原始数据:', data);\n                \n                // 重置累积数据，避免错误累积\n                accumulatedJson = '';\n                \n                // 如果数据包含 tools_data_result 标签，尝试发送一个特殊的消息通知客户端处理\n                if (data.includes('<tools_data_result>')) {\n                  try {\n                    const specialMessage = {\n                      type: 'text',\n                      content: data, // 直接传递原始数据，客户端可以处理\n                      position: 'left',\n                      metadata: {\n                        conversation_id: conversationId,\n                        event_type: 'message_end', // 标记为结束消息，触发客户端处理\n                        created_at: new Date().toISOString()\n                      }\n                    };\n                    \n                    await writer.write(encoder.encode(`data: ${JSON.stringify(specialMessage)}\\n\\n`));\n                    console.log('发送了特殊消息处理 tools_data_result');\n                  } catch (specialError) {\n                    console.error('发送特殊消息失败:', specialError);\n                  }\n                }\n                \n                // 继续处理下一个数据块，不中断流程\n              }\n            }\n          }\n        }\n      } catch (error) {\n        console.error('读取流错误:', error);\n        await writer.abort(error as Error);\n      }\n    })();\n\n    // 返回流式响应\n    return new Response(readable, {\n      headers: {\n        \"Content-Type\": \"text/event-stream\",\n        \"Cache-Control\": \"no-cache\",\n        \"Connection\": \"keep-alive\"\n      }\n    });\n  } catch (error) {\n    console.error(\"处理聊天请求时出错:\", error);\n    return NextResponse.json(\n      { error: \"处理请求时发生错误\" },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 326, "column": 0}, "map": {"version":3,"sources":["file:///Users/lihan2/Documents/project/chatui4cythera/src/app/api/chat/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport { handleChatRequest } from '../utils/chatApiHandler';\n\n// 根据助手索引获取对应的API密钥\nfunction getApiKeyByIndex(index: number): string {\n  switch (index) {\n    case 0: // 数字能效分析师\n      return process.env.DIFY_API_KEY_1 || '';\n    case 1: // 数字环境专员\n      return process.env.DIFY_API_KEY_2 || '';\n    case 2: // 数字设备健康主管\n      return process.env.DIFY_API_KEY_3 || '';\n    case 3: // 数字综合运营协调员\n      return process.env.DIFY_API_KEY_4 || '';\n    default: // 默认使用第4个API密钥\n      return process.env.DIFY_API_KEY_4 || '';\n  }\n}\n\nexport async function POST(request: Request) {\n  try {\n    const requestData = await request.json();\n    const { assistantIndex = -1 } = requestData;\n    \n    console.log(\"统一聊天API请求:\", requestData);\n    \n    // 根据助手索引获取对应的API密钥\n    const apiKey = getApiKeyByIndex(typeof assistantIndex === 'number' ? assistantIndex : -1);\n    \n    // 使用通用处理函数处理请求，传递已解析的请求数据\n    return handleChatRequest(requestData, apiKey);\n  } catch (error) {\n    console.error(\"处理聊天请求时出错:\", error);\n    return NextResponse.json(\n      { error: \"处理请求时发生错误\" },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAEA,mBAAmB;AACnB,SAAS,iBAAiB,KAAa;IACrC,OAAQ;QACN,KAAK;YACH,OAAO,QAAQ,GAAG,CAAC,cAAc,IAAI;QACvC,KAAK;YACH,OAAO,QAAQ,GAAG,CAAC,cAAc,IAAI;QACvC,KAAK;YACH,OAAO,QAAQ,GAAG,CAAC,cAAc,IAAI;QACvC,KAAK;YACH,OAAO,QAAQ,GAAG,CAAC,cAAc,IAAI;QACvC;YACE,OAAO,QAAQ,GAAG,CAAC,cAAc,IAAI;IACzC;AACF;AAEO,eAAe,KAAK,OAAgB;IACzC,IAAI;QACF,MAAM,cAAc,MAAM,QAAQ,IAAI;QACtC,MAAM,EAAE,iBAAiB,CAAC,CAAC,EAAE,GAAG;QAEhC,QAAQ,GAAG,CAAC,cAAc;QAE1B,mBAAmB;QACnB,MAAM,SAAS,iBAAiB,OAAO,mBAAmB,WAAW,iBAAiB,CAAC;QAEvF,0BAA0B;QAC1B,OAAO,CAAA,GAAA,8IAAA,CAAA,oBAAiB,AAAD,EAAE,aAAa;IACxC,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,cAAc;QAC5B,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAY,GACrB;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}